diff -uBbw -Nr ../zlib-1.2.8/circharbuf.c ./circharbuf.c
--- ../zlib-1.2.8/circharbuf.c	1970-01-01 01:00:00.000000000 +0100
+++ ./circharbuf.c	2016-09-06 13:13:26.507258000 +0100
@@ -0,0 +1,115 @@
+/* circharbuf.c -- Support code for Intel QAT hardware acceleration of zlib.
+ * Copyright (C) 2012 Intel Corporation. All rights reserved.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+ 
+#include "circharbuf.h"
+
+/*==========================================================*/
+int csbInit(CircularCharBuffer *csb, int size)
+{
+   if ((!csb) || (size <= 0))
+       return 0;
+
+   csb->size = size;
+   csb->start_index = 0;
+   csb->count = 0;
+   csb->items = (unsigned char *)calloc(csb->size, sizeof(unsigned char));
+   if (csb->items)
+       return 1;
+   else
+       return 0;
+}
+
+/*==========================================================*/
+void csbReset(CircularCharBuffer *csb)
+{
+   if (!csb)
+       return;
+
+   csb->start_index = 0;
+   csb->count = 0;
+}
+
+/*==========================================================*/
+void csbFree(CircularCharBuffer *csb)
+{
+   if (csb) {
+       if (csb->items) {
+           free(csb->items);
+           csb->items = NULL;
+       }
+   }
+}
+
+/*==========================================================*/
+int csbCount(CircularCharBuffer *csb)
+{ 
+   if (!csb)
+       return 0;
+
+   return csb->count;
+}
+
+/*==========================================================*/
+int csbIsFull(CircularCharBuffer *csb)
+{
+   if (!csb)
+       return 0;
+
+   return (csb->count == csb->size);
+}
+
+/*==========================================================*/
+int csbIsEmpty(CircularCharBuffer *csb)
+{
+   if (!csb)
+       return 0;
+
+   return (0 == csb->count);
+}
+
+/*==========================================================*/
+int csbSize(CircularCharBuffer *csb)
+{
+   if (!csb)
+       return 0;
+ 
+   return csb->size;
+}
+
+/*==========================================================*/
+int csbWrite(CircularCharBuffer *csb, unsigned char *item)
+{
+   if ((!csb) || (!item))
+       return 0;
+
+   if (!csbSize(csb))
+       return 0;
+ 
+   int end = (csb->start_index + csb->count) % csb->size;
+   csb->items[end] = *item;
+   if (csbIsFull(csb)) {
+      csb->start_index = (csb->start_index + 1) % csb->size;
+   }
+   else {
+      ++csb->count;
+   }
+   return 1;
+}
+
+/*==========================================================*/
+int csbRead(CircularCharBuffer *csb, unsigned char *item)
+{
+   if (!csb)
+       return 0;
+
+   if (!csbIsEmpty(csb)) {
+      *item = csb->items[csb->start_index];
+      csb->start_index = (csb->start_index + 1) % csb->size;
+      --csb->count;
+      return 1;
+   }
+   return 0;
+}
+   
diff -uBbw -Nr ../zlib-1.2.8/circharbuf.h ./circharbuf.h
--- ../zlib-1.2.8/circharbuf.h	1970-01-01 01:00:00.000000000 +0100
+++ ./circharbuf.h	2016-09-06 13:13:26.508258000 +0100
@@ -0,0 +1,37 @@
+/* circharbuf.h -- Support code for Intel QAT hardware acceleration of zlib.
+ * Copyright (C) 2012 Intel Corporation. All rights reserved.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+#ifndef CIRCHARBUF_H
+#define CIRCHARBUF_H
+
+#include <stdio.h>
+#include <malloc.h>
+
+typedef struct {
+    int  size;
+    int  start_index;
+    int  count;
+    unsigned char *items;
+} CircularCharBuffer;
+
+int csbInit(CircularCharBuffer *csb, int size);
+
+void csbReset(CircularCharBuffer * csb);
+
+void csbFree(CircularCharBuffer *csb);
+
+int csbCount(CircularCharBuffer *csb);
+
+int csbIsFull(CircularCharBuffer *csb);
+
+int csbIsEmpty(CircularCharBuffer *csb);
+
+int csbSize(CircularCharBuffer *csb);
+
+int csbWrite(CircularCharBuffer *csb, unsigned char *item);
+
+int csbRead(CircularCharBuffer *csb, unsigned char *item);
+
+#endif /* CIRCHARBUF_H */
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/cmn_mem_drv/cmn_mem_drv_inf.c ./contrib/qat/cmn_mem_drv/cmn_mem_drv_inf.c
--- ../zlib-1.2.8/contrib/qat/cmn_mem_drv/cmn_mem_drv_inf.c	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/cmn_mem_drv/cmn_mem_drv_inf.c	2016-09-06 13:13:26.514254000 +0100
@@ -0,0 +1,94 @@
+/* cmn_mem_drv_inf.c -- Support code for Intel QAT hardware acceleration of
+ * zlib.
+ * Copyright (C) 2014 Intel Corporation. All rights reserved.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/*****************************************************************************
+ * @file cmn_mem_drv_inf.c
+ *
+ * This file provides an interface to use a memory driver to provide contig
+ * pinned memory.
+ *
+ *****************************************************************************/
+
+#include <stdio.h>
+#include <pthread.h>
+#include <string.h>
+#include "cmn_mem_drv_inf.h"
+#include "qae_mem.h"
+
+#ifdef QAT_MEM_DEBUG
+# define MEM_DEBUG(...) fprintf(stderr, __VA_ARGS__)
+#else
+# define MEM_DEBUG(...)
+#endif
+
+#define MEM_ERROR(...) fprintf(stderr, __VA_ARGS__)
+
+#ifdef QAT_MEM_WARN
+# define MEM_WARN(...) fprintf (stderr, __VA_ARGS__)
+#else
+# define MEM_WARN(...)
+#endif
+
+static pthread_mutex_t mem_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+void *qaeZlibPinnedMemAlloc(size_t memsize, Cpa32U nodeId, 
+                            const char *file, int line)
+{
+    CpaStatus status = CPA_STATUS_SUCCESS;
+    int rc;
+    void *pAddress = NULL;
+
+    MEM_DEBUG("%s: pthread_mutex_lock\n", __func__);
+    if ((rc = pthread_mutex_lock(&mem_mutex)) != 0) {
+        MEM_ERROR("%s: pthread_mutex_lock: %s\n", __func__, strerror(rc));
+        return NULL;
+    }
+
+    pAddress = qaeMemAllocNUMA(memsize, nodeId, QAT_BYTE_ALIGNMENT);
+    MEM_DEBUG("%s: Address: %p Size: %d File: %s:%d\n", __func__, pAddress,
+          memsize, file, line);
+    if ((rc = pthread_mutex_unlock(&mem_mutex)) != 0) {
+        MEM_ERROR("%s: pthread_mutex_unlock: %s\n", __func__, strerror(rc));
+    }
+    MEM_DEBUG("%s: pthread_mutex_unlock\n", __func__);
+    return pAddress;
+}
+
+void qaeZlibPinnedMemFree(void *ptr)
+{
+    int rc;
+
+    MEM_DEBUG("%s: Address: %p\n", __func__, ptr);
+
+    if (NULL == ptr) {
+        MEM_WARN("%s: trying to free NULL pointer.\n", __func__);
+        return;
+    }
+
+    MEM_DEBUG("%s: pthread_mutex_lock\n", __func__);
+    if ((rc = pthread_mutex_lock(&mem_mutex)) != 0) {
+        MEM_ERROR("%s: pthread_mutex_lock: %s\n", __func__, strerror(rc));
+        return;
+    }
+
+    qaeMemFreeNUMA(&ptr);
+
+    if ((rc = pthread_mutex_unlock(&mem_mutex)) != 0) {
+        MEM_ERROR("%s: pthread_mutex_unlock: %s\n", __func__, strerror(rc));
+        return;
+    }
+    MEM_DEBUG("%s: pthread_mutex_unlock\n", __func__);
+}
+
+CpaPhysicalAddr qaeZlibMemV2P(void *v)
+{
+    return qaeVirtToPhysNUMA(v);
+}
+
+void qaeZlibAtFork()
+{
+    qaeAtFork();
+}
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/cmn_mem_drv/cmn_mem_drv_inf.h ./contrib/qat/cmn_mem_drv/cmn_mem_drv_inf.h
--- ../zlib-1.2.8/contrib/qat/cmn_mem_drv/cmn_mem_drv_inf.h	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/cmn_mem_drv/cmn_mem_drv_inf.h	2016-09-06 13:13:26.518254000 +0100
@@ -0,0 +1,84 @@
+/* cmn_mem_drv_inf.h -- Support code for Intel QAT hardware acceleration of
+ * zlib.
+ * Copyright (C) 2012 Intel Corporation. All rights reserved.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/*****************************************************************************
+ * @file cmn_mem_drv_inf.h
+ *
+ * This file provides an interface to a memory driver that supplies contig
+ * pinned memory.
+ *
+ *****************************************************************************/
+
+#ifndef CMN_MEM_DRV_INF_H
+#define CMN_MEM_DRV_INF_H
+
+#include "cpa.h"
+
+#define QAT_BYTE_ALIGNMENT 0x0040 /* 64 bytes */
+/*****************************************************************************
+ * function:
+ *         qaeZlibPinnedMemAlloc(size_t memsize, Cpa32U nodeId,
+                                 const char *file, int line);
+ *
+ * @description
+ *      allocates memsize bytes of memory aligned to a 64 byte address.
+ *      The returned pointer will always be 64 byte aligned to ensure
+ *      best performance from the accelerator.
+ *
+ * @param[in] memsize, the amount of memory in bytes to be allocated
+ * @param[in] nodeId, the NUMA node to allocate memory on
+ *
+ * @retval pointer to the allocated memory
+ *
+ *****************************************************************************/
+void *qaeZlibPinnedMemAlloc(size_t memsize, Cpa32U nodeId,
+                            const char *file, int line);
+
+
+/*****************************************************************************
+ * function:
+ *         qaeZlibPinnedMemFree(void *ptr)
+ *
+ * @description
+ *      frees memory allocated by the qaeMemAlloc function
+ *
+ *
+ * @param[in] pointer to the memory to be freed
+ *
+ * @retval none
+ *
+ *****************************************************************************/
+void qaeZlibPinnedMemFree(void *ptr);
+
+
+/*****************************************************************************
+ * function:
+ *         qaeZlibMemV2P(void *v)
+ *
+ * @description
+ * 	find the physical address of a block of memory referred to by virtual
+ * 	address v in the current process's address map
+ *
+ *
+ * @param[in] ptr, virtual pointer to the memory
+ *
+ * @retval the physical address of the memory referred to by ptr
+ *
+ *****************************************************************************/
+CpaPhysicalAddr qaeZlibMemV2P(void *v);
+
+
+/*****************************************************************************
+ * function:
+ *         qaeZlibAtFork()
+ *
+ * @description
+ * 	allocate and remap memory following a fork
+ *
+ *****************************************************************************/
+void qaeZlibAtFork();
+
+#endif /*CMN_MEM_DRV_INF_H*/
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/config/dh895xcc/multi_process_optimized/dh895xcc_qa_dev0.conf ./contrib/qat/config/dh895xcc/multi_process_optimized/dh895xcc_qa_dev0.conf
--- ../zlib-1.2.8/contrib/qat/config/dh895xcc/multi_process_optimized/dh895xcc_qa_dev0.conf	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/config/dh895xcc/multi_process_optimized/dh895xcc_qa_dev0.conf	2016-04-06 08:50:13.786274000 +0100
@@ -0,0 +1,203 @@
+#########################################################################
+#
+# @par
+# This file is provided under a dual BSD/GPLv2 license.  When using or 
+#   redistributing this file, you may do so under either license.
+# 
+#   GPL LICENSE SUMMARY
+# 
+#   Copyright(c) 2007-2013 Intel Corporation. All rights reserved.
+# 
+#   This program is free software; you can redistribute it and/or modify 
+#   it under the terms of version 2 of the GNU General Public License as
+#   published by the Free Software Foundation.
+# 
+#   This program is distributed in the hope that it will be useful, but 
+#   WITHOUT ANY WARRANTY; without even the implied warranty of 
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+#   General Public License for more details.
+# 
+#   You should have received a copy of the GNU General Public License 
+#   along with this program; if not, write to the Free Software 
+#   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#   The full GNU General Public License is included in this distribution 
+#   in the file called LICENSE.GPL.
+# 
+#   Contact Information:
+#   Intel Corporation
+# 
+#   BSD LICENSE 
+# 
+#   Copyright(c) 2007-2013 Intel Corporation. All rights reserved.
+#   All rights reserved.
+# 
+#   Redistribution and use in source and binary forms, with or without 
+#   modification, are permitted provided that the following conditions 
+#   are met:
+# 
+#     * Redistributions of source code must retain the above copyright 
+#       notice, this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above copyright 
+#       notice, this list of conditions and the following disclaimer in 
+#       the documentation and/or other materials provided with the 
+#       distribution.
+#     * Neither the name of Intel Corporation nor the names of its 
+#       contributors may be used to endorse or promote products derived 
+#       from this software without specific prior written permission.
+# 
+#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+#   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+# 
+# 
+#########################################################################
+########################################################
+#
+# This file is the configuration for a single dh895xcc_qa
+# device.
+#
+# Each device has 32 independent banks.
+# - The interrupt for each can be directed to a
+#   specific core.
+# Each bank can contain up to 2 crypto and/or up to 2 data
+# compression services.
+#
+########################################################
+
+##############################################
+# General Section
+##############################################
+
+[GENERAL]
+ServicesEnabled = dc
+
+# Use version 2 of the config file
+ConfigVersion = 2
+
+# Look Aside Cryptographic Configuration
+cyHmacAuthMode = 1
+
+# Wireless Enable/Disable, valid values: 1,0
+WirelessEnabled = 0
+
+# Firmware Location Configuration
+Firmware_MofPath = dh895xcc/mof_firmware.bin
+Firmware_MmpPath = dh895xcc/mmp_firmware.bin
+
+# Default selection of CY concurrent requests.
+CyNumConcurrentSymRequests = 512
+CyNumConcurrentAsymRequests = 64
+
+# Default number of DC concurrent requests.
+DcNumConcurrentRequests = 512
+
+#Statistics, valid values: 1,0
+statsGeneral = 1
+statsDc = 1
+statsDh = 1
+statsDrbg = 1
+statsDsa = 1
+statsEcc = 1
+statsKeyGen = 1
+statsLn = 1
+statsPrime = 1
+statsRsa = 1
+statsSym = 1
+
+# Debug feature, if set to 1 it enables additional entries in /proc filesystem
+ProcDebug = 1
+
+# Enables or disables Single Root Complex IO Virtualization.
+# If this is enabled (1) then SRIOV and VT-d need to be enabled in
+# BIOS and there can be no Cy or Dc instances created in PF (Dom0).
+# If this is disabled (0) then SRIOV and VT-d needs to be disabled
+# in the BIOS and Cy and/or Dc instances can be used in PF (Dom0)
+SRIOV_Enabled = 0
+
+#######################################################
+#
+# Logical Instances Section
+# A logical instance allows each address domain
+# (kernel space and individual user space processes)
+# to configure rings (i.e. hardware assisted queues)
+# to be used by that address domain and to define the
+# behavior of that ring.
+#
+# The address domains are in the following format
+# - For kernel address domains
+#       [KERNEL]
+# - For user process address domains
+#   [xxxxx]
+#   Where xxxxx may be any ascii value which uniquely identifies
+#   the user mode process.
+#   To allow the driver correctly configure the
+#   logical instances associated with this user process,
+#   the process must call the icp_sal_userStartMultiProcess(...)
+#   passing the xxxxx string during process initialisation.
+#   When the user space process is finished it must call
+#   icp_sal_userStop(...) to free resources.
+#   NumProcesses will indicate the maximum number of processes
+#   that can call icp_sal_userStartMultiProcess on this instance.
+#   Warning: the resources are preallocated: if NumProcesses
+#   is too high, the driver will fail to load
+#
+# Items configurable by a logical instance are:
+# - Name of the logical instance
+# - The response mode associated wth this logical instance (0
+#   for IRQ or 1 for polled).
+# - The core the instance is affinitized to (optional)
+#
+# The format of the logical instances are:
+# - For crypto:
+#               Cy<n>Name = "xxxx"
+#               Cy<n>IsPolled = 0|1
+#               Cy<n>CoreAffinity = 0-7
+#
+# - For Data Compression
+#               Dc<n>Name = "xxxx"
+#               Dc<n>IsPolled = 0|1
+#               Dc<n>CoreAffinity = 0-7
+#
+# Where:
+#       - n is the number of this logical instance starting at 0.
+#       - xxxx may be any ascii value which identifies the logical instance.
+#
+# Note: for user space processes, a list of values can be specified for
+# the core affinity: for example
+#              Cy0CoreAffinity = 0,2,4
+# These comma-separated lists will allow multiple processes to use
+# different accelerators and cores, and will wrap around the numbers
+# in the list. In the above example, process 0 will have affinity 0,
+# and process 1 will have affinity 2 etc.
+#
+########################################################
+
+##############################################
+# Kernel Instances Section
+##############################################
+[KERNEL]
+NumberCyInstances = 0
+NumberDcInstances = 0
+
+##############################################
+# User Process Instance Section
+##############################################
+[SHIM]
+NumberCyInstances = 0 
+NumberDcInstances = 1 
+NumProcesses = 16
+LimitDevAccess = 1
+
+# Data Compression - User space
+Dc0Name = "UserDC0"
+Dc0IsPolled = 1
+Dc0CoreAffinity = 0
+
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/config/dh895xcc/multi_process_optimized/dh895xcc_qa_dev1.conf ./contrib/qat/config/dh895xcc/multi_process_optimized/dh895xcc_qa_dev1.conf
--- ../zlib-1.2.8/contrib/qat/config/dh895xcc/multi_process_optimized/dh895xcc_qa_dev1.conf	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/config/dh895xcc/multi_process_optimized/dh895xcc_qa_dev1.conf	2016-04-06 08:50:13.800271000 +0100
@@ -0,0 +1,203 @@
+#########################################################################
+#
+# @par
+# This file is provided under a dual BSD/GPLv2 license.  When using or 
+#   redistributing this file, you may do so under either license.
+# 
+#   GPL LICENSE SUMMARY
+# 
+#   Copyright(c) 2007-2013 Intel Corporation. All rights reserved.
+# 
+#   This program is free software; you can redistribute it and/or modify 
+#   it under the terms of version 2 of the GNU General Public License as
+#   published by the Free Software Foundation.
+# 
+#   This program is distributed in the hope that it will be useful, but 
+#   WITHOUT ANY WARRANTY; without even the implied warranty of 
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+#   General Public License for more details.
+# 
+#   You should have received a copy of the GNU General Public License 
+#   along with this program; if not, write to the Free Software 
+#   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#   The full GNU General Public License is included in this distribution 
+#   in the file called LICENSE.GPL.
+# 
+#   Contact Information:
+#   Intel Corporation
+# 
+#   BSD LICENSE 
+# 
+#   Copyright(c) 2007-2013 Intel Corporation. All rights reserved.
+#   All rights reserved.
+# 
+#   Redistribution and use in source and binary forms, with or without 
+#   modification, are permitted provided that the following conditions 
+#   are met:
+# 
+#     * Redistributions of source code must retain the above copyright 
+#       notice, this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above copyright 
+#       notice, this list of conditions and the following disclaimer in 
+#       the documentation and/or other materials provided with the 
+#       distribution.
+#     * Neither the name of Intel Corporation nor the names of its 
+#       contributors may be used to endorse or promote products derived 
+#       from this software without specific prior written permission.
+# 
+#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+#   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+# 
+# 
+#########################################################################
+########################################################
+#
+# This file is the configuration for a single dh895xcc_qa
+# device.
+#
+# Each device has 32 independent banks.
+# - The interrupt for each can be directed to a
+#   specific core.
+# Each bank can contain up to 2 crypto and/or up to 2 data
+# compression services.
+#
+########################################################
+
+##############################################
+# General Section
+##############################################
+
+[GENERAL]
+ServicesEnabled = dc
+
+# Use version 2 of the config file
+ConfigVersion = 2
+
+# Look Aside Cryptographic Configuration
+cyHmacAuthMode = 1
+
+# Wireless Enable/Disable, valid values: 1,0
+WirelessEnabled = 0
+
+# Firmware Location Configuration
+Firmware_MofPath = dh895xcc/mof_firmware.bin
+Firmware_MmpPath = dh895xcc/mmp_firmware.bin
+
+# Default selection of CY concurrent requests.
+CyNumConcurrentSymRequests = 512
+CyNumConcurrentAsymRequests = 64
+
+# Default number of DC concurrent requests.
+DcNumConcurrentRequests = 512
+
+#Statistics, valid values: 1,0
+statsGeneral = 1
+statsDc = 1
+statsDh = 1
+statsDrbg = 1
+statsDsa = 1
+statsEcc = 1
+statsKeyGen = 1
+statsLn = 1
+statsPrime = 1
+statsRsa = 1
+statsSym = 1
+
+# Debug feature, if set to 1 it enables additional entries in /proc filesystem
+ProcDebug = 1
+
+# Enables or disables Single Root Complex IO Virtualization.
+# If this is enabled (1) then SRIOV and VT-d need to be enabled in
+# BIOS and there can be no Cy or Dc instances created in PF (Dom0).
+# If this is disabled (0) then SRIOV and VT-d needs to be disabled
+# in the BIOS and Cy and/or Dc instances can be used in PF (Dom0)
+SRIOV_Enabled = 0
+
+#######################################################
+#
+# Logical Instances Section
+# A logical instance allows each address domain
+# (kernel space and individual user space processes)
+# to configure rings (i.e. hardware assisted queues)
+# to be used by that address domain and to define the
+# behavior of that ring.
+#
+# The address domains are in the following format
+# - For kernel address domains
+#       [KERNEL]
+# - For user process address domains
+#   [xxxxx]
+#   Where xxxxx may be any ascii value which uniquely identifies
+#   the user mode process.
+#   To allow the driver correctly configure the
+#   logical instances associated with this user process,
+#   the process must call the icp_sal_userStartMultiProcess(...)
+#   passing the xxxxx string during process initialisation.
+#   When the user space process is finished it must call
+#   icp_sal_userStop(...) to free resources.
+#   NumProcesses will indicate the maximum number of processes
+#   that can call icp_sal_userStartMultiProcess on this instance.
+#   Warning: the resources are preallocated: if NumProcesses
+#   is too high, the driver will fail to load
+#
+# Items configurable by a logical instance are:
+# - Name of the logical instance
+# - The response mode associated wth this logical instance (0
+#   for IRQ or 1 for polled).
+# - The core the instance is affinitized to (optional)
+#
+# The format of the logical instances are:
+# - For crypto:
+#               Cy<n>Name = "xxxx"
+#               Cy<n>IsPolled = 0|1
+#               Cy<n>CoreAffinity = 0-7
+#
+# - For Data Compression
+#               Dc<n>Name = "xxxx"
+#               Dc<n>IsPolled = 0|1
+#               Dc<n>CoreAffinity = 0-7
+#
+# Where:
+#       - n is the number of this logical instance starting at 0.
+#       - xxxx may be any ascii value which identifies the logical instance.
+#
+# Note: for user space processes, a list of values can be specified for
+# the core affinity: for example
+#              Cy0CoreAffinity = 0,2,4
+# These comma-separated lists will allow multiple processes to use
+# different accelerators and cores, and will wrap around the numbers
+# in the list. In the above example, process 0 will have affinity 0,
+# and process 1 will have affinity 2 etc.
+#
+########################################################
+
+##############################################
+# Kernel Instances Section
+##############################################
+[KERNEL]
+NumberCyInstances = 0
+NumberDcInstances = 0
+
+##############################################
+# User Process Instance Section
+##############################################
+[SHIM]
+NumberCyInstances = 0 
+NumberDcInstances = 1 
+NumProcesses = 16
+LimitDevAccess = 1
+
+# Data Compression - User space
+Dc0Name = "UserDC0"
+Dc0IsPolled = 1
+Dc0CoreAffinity = 0
+
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/config/dh895xcc/multi_thread_optimized/dh895xcc_qa_dev0.conf ./contrib/qat/config/dh895xcc/multi_thread_optimized/dh895xcc_qa_dev0.conf
--- ../zlib-1.2.8/contrib/qat/config/dh895xcc/multi_thread_optimized/dh895xcc_qa_dev0.conf	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/config/dh895xcc/multi_thread_optimized/dh895xcc_qa_dev0.conf	2016-04-06 08:50:13.809272000 +0100
@@ -0,0 +1,207 @@
+#########################################################################
+#
+# @par
+# This file is provided under a dual BSD/GPLv2 license.  When using or 
+#   redistributing this file, you may do so under either license.
+# 
+#   GPL LICENSE SUMMARY
+# 
+#   Copyright(c) 2007-2013 Intel Corporation. All rights reserved.
+# 
+#   This program is free software; you can redistribute it and/or modify 
+#   it under the terms of version 2 of the GNU General Public License as
+#   published by the Free Software Foundation.
+# 
+#   This program is distributed in the hope that it will be useful, but 
+#   WITHOUT ANY WARRANTY; without even the implied warranty of 
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+#   General Public License for more details.
+# 
+#   You should have received a copy of the GNU General Public License 
+#   along with this program; if not, write to the Free Software 
+#   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#   The full GNU General Public License is included in this distribution 
+#   in the file called LICENSE.GPL.
+# 
+#   Contact Information:
+#   Intel Corporation
+# 
+#   BSD LICENSE 
+# 
+#   Copyright(c) 2007-2013 Intel Corporation. All rights reserved.
+#   All rights reserved.
+# 
+#   Redistribution and use in source and binary forms, with or without 
+#   modification, are permitted provided that the following conditions 
+#   are met:
+# 
+#     * Redistributions of source code must retain the above copyright 
+#       notice, this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above copyright 
+#       notice, this list of conditions and the following disclaimer in 
+#       the documentation and/or other materials provided with the 
+#       distribution.
+#     * Neither the name of Intel Corporation nor the names of its 
+#       contributors may be used to endorse or promote products derived 
+#       from this software without specific prior written permission.
+# 
+#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+#   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+# 
+# 
+#########################################################################
+########################################################
+#
+# This file is the configuration for a single dh895xcc_qa
+# device.
+#
+# Each device has 32 independent banks.
+# - The interrupt for each can be directed to a
+#   specific core.
+# Each bank can contain up to 2 crypto and/or up to 2 data
+# compression services.
+#
+########################################################
+
+##############################################
+# General Section
+##############################################
+
+[GENERAL]
+ServicesEnabled = dc
+
+# Use version 2 of the config file
+ConfigVersion = 2
+
+# Look Aside Cryptographic Configuration
+cyHmacAuthMode = 1
+
+# Wireless Enable/Disable, valid values: 1,0
+WirelessEnabled = 0
+
+# Firmware Location Configuration
+Firmware_MofPath = dh895xcc/mof_firmware.bin
+Firmware_MmpPath = dh895xcc/mmp_firmware.bin
+
+# Default selection of CY concurrent requests.
+CyNumConcurrentSymRequests = 512
+CyNumConcurrentAsymRequests = 64
+
+# Default number of DC concurrent requests.
+DcNumConcurrentRequests = 512
+
+#Statistics, valid values: 1,0
+statsGeneral = 1
+statsDc = 1
+statsDh = 1
+statsDrbg = 1
+statsDsa = 1
+statsEcc = 1
+statsKeyGen = 1
+statsLn = 1
+statsPrime = 1
+statsRsa = 1
+statsSym = 1
+
+# Debug feature, if set to 1 it enables additional entries in /proc filesystem
+ProcDebug = 1
+
+# Enables or disables Single Root Complex IO Virtualization.
+# If this is enabled (1) then SRIOV and VT-d need to be enabled in
+# BIOS and there can be no Cy or Dc instances created in PF (Dom0).
+# If this is disabled (0) then SRIOV and VT-d needs to be disabled
+# in the BIOS and Cy and/or Dc instances can be used in PF (Dom0)
+SRIOV_Enabled = 0
+
+#######################################################
+#
+# Logical Instances Section
+# A logical instance allows each address domain
+# (kernel space and individual user space processes)
+# to configure rings (i.e. hardware assisted queues)
+# to be used by that address domain and to define the
+# behavior of that ring.
+#
+# The address domains are in the following format
+# - For kernel address domains
+#       [KERNEL]
+# - For user process address domains
+#   [xxxxx]
+#   Where xxxxx may be any ascii value which uniquely identifies
+#   the user mode process.
+#   To allow the driver correctly configure the
+#   logical instances associated with this user process,
+#   the process must call the icp_sal_userStartMultiProcess(...)
+#   passing the xxxxx string during process initialisation.
+#   When the user space process is finished it must call
+#   icp_sal_userStop(...) to free resources.
+#   NumProcesses will indicate the maximum number of processes
+#   that can call icp_sal_userStartMultiProcess on this instance.
+#   Warning: the resources are preallocated: if NumProcesses
+#   is too high, the driver will fail to load
+#
+# Items configurable by a logical instance are:
+# - Name of the logical instance
+# - The response mode associated wth this logical instance (0
+#   for IRQ or 1 for polled).
+# - The core the instance is affinitized to (optional)
+#
+# The format of the logical instances are:
+# - For crypto:
+#               Cy<n>Name = "xxxx"
+#               Cy<n>IsPolled = 0|1
+#               Cy<n>CoreAffinity = 0-7
+#
+# - For Data Compression
+#               Dc<n>Name = "xxxx"
+#               Dc<n>IsPolled = 0|1
+#               Dc<n>CoreAffinity = 0-7
+#
+# Where:
+#       - n is the number of this logical instance starting at 0.
+#       - xxxx may be any ascii value which identifies the logical instance.
+#
+# Note: for user space processes, a list of values can be specified for
+# the core affinity: for example
+#              Cy0CoreAffinity = 0,2,4
+# These comma-separated lists will allow multiple processes to use
+# different accelerators and cores, and will wrap around the numbers
+# in the list. In the above example, process 0 will have affinity 0,
+# and process 1 will have affinity 2 etc.
+#
+########################################################
+
+##############################################
+# Kernel Instances Section
+##############################################
+[KERNEL]
+NumberCyInstances = 0
+NumberDcInstances = 0
+
+##############################################
+# User Process Instance Section
+##############################################
+[SHIM]
+NumberCyInstances = 0
+NumberDcInstances = 2
+NumProcesses = 1
+LimitDevAccess = 0
+
+# Data Compression - User space
+Dc0Name = "UserDC0"
+Dc0IsPolled = 1
+Dc0CoreAffinity = 0
+
+# Data Compression - User space
+Dc1Name = "UserDC1"
+Dc1IsPolled = 1
+Dc1CoreAffinity = 0
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/config/dh895xcc/multi_thread_optimized/dh895xcc_qa_dev1.conf ./contrib/qat/config/dh895xcc/multi_thread_optimized/dh895xcc_qa_dev1.conf
--- ../zlib-1.2.8/contrib/qat/config/dh895xcc/multi_thread_optimized/dh895xcc_qa_dev1.conf	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/config/dh895xcc/multi_thread_optimized/dh895xcc_qa_dev1.conf	2016-04-06 08:50:13.810273000 +0100
@@ -0,0 +1,207 @@
+#########################################################################
+#
+# @par
+# This file is provided under a dual BSD/GPLv2 license.  When using or 
+#   redistributing this file, you may do so under either license.
+# 
+#   GPL LICENSE SUMMARY
+# 
+#   Copyright(c) 2007-2013 Intel Corporation. All rights reserved.
+# 
+#   This program is free software; you can redistribute it and/or modify 
+#   it under the terms of version 2 of the GNU General Public License as
+#   published by the Free Software Foundation.
+# 
+#   This program is distributed in the hope that it will be useful, but 
+#   WITHOUT ANY WARRANTY; without even the implied warranty of 
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+#   General Public License for more details.
+# 
+#   You should have received a copy of the GNU General Public License 
+#   along with this program; if not, write to the Free Software 
+#   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#   The full GNU General Public License is included in this distribution 
+#   in the file called LICENSE.GPL.
+# 
+#   Contact Information:
+#   Intel Corporation
+# 
+#   BSD LICENSE 
+# 
+#   Copyright(c) 2007-2013 Intel Corporation. All rights reserved.
+#   All rights reserved.
+# 
+#   Redistribution and use in source and binary forms, with or without 
+#   modification, are permitted provided that the following conditions 
+#   are met:
+# 
+#     * Redistributions of source code must retain the above copyright 
+#       notice, this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above copyright 
+#       notice, this list of conditions and the following disclaimer in 
+#       the documentation and/or other materials provided with the 
+#       distribution.
+#     * Neither the name of Intel Corporation nor the names of its 
+#       contributors may be used to endorse or promote products derived 
+#       from this software without specific prior written permission.
+# 
+#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+#   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+# 
+# 
+#########################################################################
+########################################################
+#
+# This file is the configuration for a single dh895xcc_qa
+# device.
+#
+# Each device has 32 independent banks.
+# - The interrupt for each can be directed to a
+#   specific core.
+# Each bank can contain up to 2 crypto and/or up to 2 data
+# compression services.
+#
+########################################################
+
+##############################################
+# General Section
+##############################################
+
+[GENERAL]
+ServicesEnabled = dc
+
+# Use version 2 of the config file
+ConfigVersion = 2
+
+# Look Aside Cryptographic Configuration
+cyHmacAuthMode = 1
+
+# Wireless Enable/Disable, valid values: 1,0
+WirelessEnabled = 0
+
+# Firmware Location Configuration
+Firmware_MofPath = dh895xcc/mof_firmware.bin
+Firmware_MmpPath = dh895xcc/mmp_firmware.bin
+
+# Default selection of CY concurrent requests.
+CyNumConcurrentSymRequests = 512
+CyNumConcurrentAsymRequests = 64
+
+# Default number of DC concurrent requests.
+DcNumConcurrentRequests = 512
+
+#Statistics, valid values: 1,0
+statsGeneral = 1
+statsDc = 1
+statsDh = 1
+statsDrbg = 1
+statsDsa = 1
+statsEcc = 1
+statsKeyGen = 1
+statsLn = 1
+statsPrime = 1
+statsRsa = 1
+statsSym = 1
+
+# Debug feature, if set to 1 it enables additional entries in /proc filesystem
+ProcDebug = 1
+
+# Enables or disables Single Root Complex IO Virtualization.
+# If this is enabled (1) then SRIOV and VT-d need to be enabled in
+# BIOS and there can be no Cy or Dc instances created in PF (Dom0).
+# If this is disabled (0) then SRIOV and VT-d needs to be disabled
+# in the BIOS and Cy and/or Dc instances can be used in PF (Dom0)
+SRIOV_Enabled = 0
+
+#######################################################
+#
+# Logical Instances Section
+# A logical instance allows each address domain
+# (kernel space and individual user space processes)
+# to configure rings (i.e. hardware assisted queues)
+# to be used by that address domain and to define the
+# behavior of that ring.
+#
+# The address domains are in the following format
+# - For kernel address domains
+#       [KERNEL]
+# - For user process address domains
+#   [xxxxx]
+#   Where xxxxx may be any ascii value which uniquely identifies
+#   the user mode process.
+#   To allow the driver correctly configure the
+#   logical instances associated with this user process,
+#   the process must call the icp_sal_userStartMultiProcess(...)
+#   passing the xxxxx string during process initialisation.
+#   When the user space process is finished it must call
+#   icp_sal_userStop(...) to free resources.
+#   NumProcesses will indicate the maximum number of processes
+#   that can call icp_sal_userStartMultiProcess on this instance.
+#   Warning: the resources are preallocated: if NumProcesses
+#   is too high, the driver will fail to load
+#
+# Items configurable by a logical instance are:
+# - Name of the logical instance
+# - The response mode associated wth this logical instance (0
+#   for IRQ or 1 for polled).
+# - The core the instance is affinitized to (optional)
+#
+# The format of the logical instances are:
+# - For crypto:
+#               Cy<n>Name = "xxxx"
+#               Cy<n>IsPolled = 0|1
+#               Cy<n>CoreAffinity = 0-7
+#
+# - For Data Compression
+#               Dc<n>Name = "xxxx"
+#               Dc<n>IsPolled = 0|1
+#               Dc<n>CoreAffinity = 0-7
+#
+# Where:
+#       - n is the number of this logical instance starting at 0.
+#       - xxxx may be any ascii value which identifies the logical instance.
+#
+# Note: for user space processes, a list of values can be specified for
+# the core affinity: for example
+#              Cy0CoreAffinity = 0,2,4
+# These comma-separated lists will allow multiple processes to use
+# different accelerators and cores, and will wrap around the numbers
+# in the list. In the above example, process 0 will have affinity 0,
+# and process 1 will have affinity 2 etc.
+#
+########################################################
+
+##############################################
+# Kernel Instances Section
+##############################################
+[KERNEL]
+NumberCyInstances = 0
+NumberDcInstances = 0
+
+##############################################
+# User Process Instance Section
+##############################################
+[SHIM]
+NumberCyInstances = 0
+NumberDcInstances = 2
+NumProcesses = 1
+LimitDevAccess = 0
+
+# Data Compression - User space
+Dc0Name = "UserDC0"
+Dc0IsPolled = 1
+Dc0CoreAffinity = 0
+
+# Data Compression - User space
+Dc1Name = "UserDC1"
+Dc1IsPolled = 1
+Dc1CoreAffinity = 0
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/config/dh89xxcc/multi_process_optimized/dh89xxcc_qa_dev0.conf ./contrib/qat/config/dh89xxcc/multi_process_optimized/dh89xxcc_qa_dev0.conf
--- ../zlib-1.2.8/contrib/qat/config/dh89xxcc/multi_process_optimized/dh89xxcc_qa_dev0.conf	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/config/dh89xxcc/multi_process_optimized/dh89xxcc_qa_dev0.conf	2016-04-06 08:50:13.824271000 +0100
@@ -0,0 +1,188 @@
+#########################################################################
+#
+# @par
+# # This file is provided under a dual BSD/GPLv2 license.  When using or
+#   redistributing this file, you may do so under either license.
+#
+#   GPL LICENSE SUMMARY
+#
+#   Copyright(c) 2007-2012 Intel Corporation. All rights reserved.
+#
+#   This program is free software; you can redistribute it and/or modify
+#   it under the terms of version 2 of the GNU General Public License as
+#   published by the Free Software Foundation.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   General Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License
+#   along with this program; if not, write to the Free Software
+#   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#   The full GNU General Public License is included in this distribution
+#   in the file called LICENSE.GPL.
+#
+#   Contact Information:
+#   Intel Corporation
+#
+#   BSD LICENSE
+#
+#   Copyright(c) 2007,2008,2009,2010,2011,2012 Intel Corporation.
+#   All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or without
+#   modification, are permitted provided that the following conditions
+#   are met:
+#
+#     * Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above copyright
+#       notice, this list of conditions and the following disclaimer in
+#       the documentation and/or other materials provided with the
+#       distribution.
+#     * Neither the name of Intel Corporation nor the names of its
+#       contributors may be used to endorse or promote products derived
+#       from this software without specific prior written permission.
+#
+#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+#
+#########################################################################
+
+########################################################
+# General Section
+##############################################
+
+[GENERAL]
+ServicesEnabled = dc
+
+# Use version 2 of the config file
+ConfigVersion = 2
+# Look Aside Cryptographic Configuration
+cyHmacAuthMode = 1
+
+# Look Aside Compression Configuration
+dcTotalSRAMAvailable = 524288 
+
+# Firmware Location Configuration
+Firmware_MofPath = mof_firmware.bin
+Firmware_MmpPath = mmp_firmware.bin
+
+#Default values for number of concurrent requests*/
+CyNumConcurrentSymRequests = 512
+CyNumConcurrentAsymRequests = 64
+DcNumConcurrentRequests = 512
+
+#Statistics, valid values: 1,0
+statsGeneral = 1
+statsDc = 1
+statsDh = 1
+statsDrbg = 1
+statsDsa = 1
+statsEcc = 1
+statsKeyGen = 1
+statsLn = 1
+statsPrime = 1
+statsRsa = 1
+statsSym = 1
+
+#Debug feature, if set to 1 it enables additional entries in /proc filesystem
+ProcDebug = 1
+
+
+#######################################################
+# Wireless Section
+#######################################################
+[WIRELESS]
+NumProcesses = 0 
+
+#######################################################
+#
+# Logical Instances Section
+# A logical instance allows each address domain
+# (kernel space and individual user space processes)
+# to configure rings (i.e. hardware assisted queues)
+# to be used by that address domain and to define the
+# behavior of that ring.
+#
+# The address domains are in the following format
+# - For kernel address domains
+#       [KERNEL]
+# - For user process address domains
+#   [xxxxx]
+#   Where xxxxx may be any ascii value which uniquely identifies
+#   the user mode process.
+#   To allow the driver correctly configure the
+#   logical instances associated with this user process,
+#   the process must call the icp_sal_userStart(...)
+#   passing the xxxxx string during process initialisation.
+#   When the user space process is finish it must call
+#   icp_sal_userStop(...) to free resources.
+#   NumProcesses will indicate the maximum number of processes
+#   that can call icp_sal_userStart on this instance.
+#   Warning: the ressources are preallocated: if NumProcesses
+#   is too high, the driver will fail to load
+#
+# Items configurable by a logical instance are:
+# - Name of the logical instance
+# - The accelerator associated with this logical
+#   instance
+# - The core the instance is affinitized to (optional)
+#
+# Note: Logical instances may not share the same ring, but
+#           may share a ring bank.
+#
+# The format of the logical instances are:
+# - For crypto:
+#               Cy<n>Name = "xxxx"
+#               Cy<n>AcceleratorNumber = 0|1
+#               Cy<n>CoreAffinity = 0-15
+#
+# - For Data Compression
+#               Dc<n>Name = "xxxx"
+#               Dc<n>AcceleratorNumber = 0|1
+#               Dc<n>CoreAffinity = 0-15
+#
+# Note: for user space processes, a list of values can be specified for
+# the core affinity: for example
+#              Cy0CoreAffinity = 0,2,4
+#
+# Where:
+#       - n is the number of this logical instance starting at 0.
+#       - xxxx may be any ascii value which identifies the logical instance.
+#
+########################################################
+
+##############################################
+# Kernel Instances Section
+##############################################
+[KERNEL]
+NumberCyInstances = 0
+NumberDcInstances = 0
+
+##############################################
+# Compression multi thread/process section
+##############################################
+[SHIM]
+NumberCyInstances = 0 
+NumberDcInstances = 1 
+NumProcesses = 16 
+LimitDevAccess = 1
+
+# Data Compression - User space
+Dc0Name = "UserDC0"
+Dc0AcceleratorNumber = 0,1
+Dc0IsPolled = 1
+Dc0CoreAffinity = 0
+
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/config/dh89xxcc/multi_process_optimized/dh89xxcc_qa_dev1.conf ./contrib/qat/config/dh89xxcc/multi_process_optimized/dh89xxcc_qa_dev1.conf
--- ../zlib-1.2.8/contrib/qat/config/dh89xxcc/multi_process_optimized/dh89xxcc_qa_dev1.conf	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/config/dh89xxcc/multi_process_optimized/dh89xxcc_qa_dev1.conf	2016-04-06 08:50:13.825271000 +0100
@@ -0,0 +1,188 @@
+#########################################################################
+#
+# @par
+# # This file is provided under a dual BSD/GPLv2 license.  When using or
+#   redistributing this file, you may do so under either license.
+#
+#   GPL LICENSE SUMMARY
+#
+#   Copyright(c) 2007-2012 Intel Corporation. All rights reserved.
+#
+#   This program is free software; you can redistribute it and/or modify
+#   it under the terms of version 2 of the GNU General Public License as
+#   published by the Free Software Foundation.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   General Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License
+#   along with this program; if not, write to the Free Software
+#   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#   The full GNU General Public License is included in this distribution
+#   in the file called LICENSE.GPL.
+#
+#   Contact Information:
+#   Intel Corporation
+#
+#   BSD LICENSE
+#
+#   Copyright(c) 2007,2008,2009,2010,2011,2012 Intel Corporation.
+#   All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or without
+#   modification, are permitted provided that the following conditions
+#   are met:
+#
+#     * Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above copyright
+#       notice, this list of conditions and the following disclaimer in
+#       the documentation and/or other materials provided with the
+#       distribution.
+#     * Neither the name of Intel Corporation nor the names of its
+#       contributors may be used to endorse or promote products derived
+#       from this software without specific prior written permission.
+#
+#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+#
+#########################################################################
+
+########################################################
+# General Section
+##############################################
+
+[GENERAL]
+ServicesEnabled = dc
+
+# Use version 2 of the config file
+ConfigVersion = 2
+# Look Aside Cryptographic Configuration
+cyHmacAuthMode = 1
+
+# Look Aside Compression Configuration
+dcTotalSRAMAvailable = 524288 
+
+# Firmware Location Configuration
+Firmware_MofPath = mof_firmware.bin
+Firmware_MmpPath = mmp_firmware.bin
+
+#Default values for number of concurrent requests*/
+CyNumConcurrentSymRequests = 512
+CyNumConcurrentAsymRequests = 64
+DcNumConcurrentRequests = 512
+
+#Statistics, valid values: 1,0
+statsGeneral = 1
+statsDc = 1
+statsDh = 1
+statsDrbg = 1
+statsDsa = 1
+statsEcc = 1
+statsKeyGen = 1
+statsLn = 1
+statsPrime = 1
+statsRsa = 1
+statsSym = 1
+
+#Debug feature, if set to 1 it enables additional entries in /proc filesystem
+ProcDebug = 1
+
+
+#######################################################
+# Wireless Section
+#######################################################
+[WIRELESS]
+NumProcesses = 0 
+
+#######################################################
+#
+# Logical Instances Section
+# A logical instance allows each address domain
+# (kernel space and individual user space processes)
+# to configure rings (i.e. hardware assisted queues)
+# to be used by that address domain and to define the
+# behavior of that ring.
+#
+# The address domains are in the following format
+# - For kernel address domains
+#       [KERNEL]
+# - For user process address domains
+#   [xxxxx]
+#   Where xxxxx may be any ascii value which uniquely identifies
+#   the user mode process.
+#   To allow the driver correctly configure the
+#   logical instances associated with this user process,
+#   the process must call the icp_sal_userStart(...)
+#   passing the xxxxx string during process initialisation.
+#   When the user space process is finish it must call
+#   icp_sal_userStop(...) to free resources.
+#   NumProcesses will indicate the maximum number of processes
+#   that can call icp_sal_userStart on this instance.
+#   Warning: the ressources are preallocated: if NumProcesses
+#   is too high, the driver will fail to load
+#
+# Items configurable by a logical instance are:
+# - Name of the logical instance
+# - The accelerator associated with this logical
+#   instance
+# - The core the instance is affinitized to (optional)
+#
+# Note: Logical instances may not share the same ring, but
+#           may share a ring bank.
+#
+# The format of the logical instances are:
+# - For crypto:
+#               Cy<n>Name = "xxxx"
+#               Cy<n>AcceleratorNumber = 0|1
+#               Cy<n>CoreAffinity = 0-15
+#
+# - For Data Compression
+#               Dc<n>Name = "xxxx"
+#               Dc<n>AcceleratorNumber = 0|1
+#               Dc<n>CoreAffinity = 0-15
+#
+# Note: for user space processes, a list of values can be specified for
+# the core affinity: for example
+#              Cy0CoreAffinity = 0,2,4
+#
+# Where:
+#       - n is the number of this logical instance starting at 0.
+#       - xxxx may be any ascii value which identifies the logical instance.
+#
+########################################################
+
+##############################################
+# Kernel Instances Section
+##############################################
+[KERNEL]
+NumberCyInstances = 0
+NumberDcInstances = 0
+
+##############################################
+# Compression multi thread/process section
+##############################################
+[SHIM]
+NumberCyInstances = 0 
+NumberDcInstances = 1 
+NumProcesses = 16 
+LimitDevAccess = 1
+
+# Data Compression - User space
+Dc0Name = "UserDC0"
+Dc0AcceleratorNumber = 0,1
+Dc0IsPolled = 1
+Dc0CoreAffinity = 0
+
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/config/dh89xxcc/multi_thread_optimized/dh89xxcc_qa_dev0.conf ./contrib/qat/config/dh89xxcc/multi_thread_optimized/dh89xxcc_qa_dev0.conf
--- ../zlib-1.2.8/contrib/qat/config/dh89xxcc/multi_thread_optimized/dh89xxcc_qa_dev0.conf	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/config/dh89xxcc/multi_thread_optimized/dh89xxcc_qa_dev0.conf	2016-04-06 08:50:13.826273000 +0100
@@ -0,0 +1,194 @@
+#########################################################################
+#
+# @par
+# # This file is provided under a dual BSD/GPLv2 license.  When using or
+#   redistributing this file, you may do so under either license.
+#
+#   GPL LICENSE SUMMARY
+#
+#   Copyright(c) 2007-2012 Intel Corporation. All rights reserved.
+#
+#   This program is free software; you can redistribute it and/or modify
+#   it under the terms of version 2 of the GNU General Public License as
+#   published by the Free Software Foundation.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   General Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License
+#   along with this program; if not, write to the Free Software
+#   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#   The full GNU General Public License is included in this distribution
+#   in the file called LICENSE.GPL.
+#
+#   Contact Information:
+#   Intel Corporation
+#
+#   BSD LICENSE
+#
+#   Copyright(c) 2007,2008,2009,2010,2011,2012 Intel Corporation.
+#   All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or without
+#   modification, are permitted provided that the following conditions
+#   are met:
+#
+#     * Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above copyright
+#       notice, this list of conditions and the following disclaimer in
+#       the documentation and/or other materials provided with the
+#       distribution.
+#     * Neither the name of Intel Corporation nor the names of its
+#       contributors may be used to endorse or promote products derived
+#       from this software without specific prior written permission.
+#
+#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+#
+#########################################################################
+
+########################################################
+# General Section
+##############################################
+
+[GENERAL]
+ServicesEnabled = dc
+
+# Use version 2 of the config file
+ConfigVersion = 2
+# Look Aside Cryptographic Configuration
+cyHmacAuthMode = 1
+
+# Look Aside Compression Configuration
+dcTotalSRAMAvailable = 524288 
+
+# Firmware Location Configuration
+Firmware_MofPath = mof_firmware.bin
+Firmware_MmpPath = mmp_firmware.bin
+
+#Default values for number of concurrent requests*/
+CyNumConcurrentSymRequests = 512
+CyNumConcurrentAsymRequests = 64
+DcNumConcurrentRequests = 512
+
+#Statistics, valid values: 1,0
+statsGeneral = 1
+statsDc = 1
+statsDh = 1
+statsDrbg = 1
+statsDsa = 1
+statsEcc = 1
+statsKeyGen = 1
+statsLn = 1
+statsPrime = 1
+statsRsa = 1
+statsSym = 1
+
+#Debug feature, if set to 1 it enables additional entries in /proc filesystem
+ProcDebug = 1
+
+
+#######################################################
+# Wireless Section
+#######################################################
+[WIRELESS]
+NumProcesses = 0 
+
+#######################################################
+#
+# Logical Instances Section
+# A logical instance allows each address domain
+# (kernel space and individual user space processes)
+# to configure rings (i.e. hardware assisted queues)
+# to be used by that address domain and to define the
+# behavior of that ring.
+#
+# The address domains are in the following format
+# - For kernel address domains
+#       [KERNEL]
+# - For user process address domains
+#   [xxxxx]
+#   Where xxxxx may be any ascii value which uniquely identifies
+#   the user mode process.
+#   To allow the driver correctly configure the
+#   logical instances associated with this user process,
+#   the process must call the icp_sal_userStart(...)
+#   passing the xxxxx string during process initialisation.
+#   When the user space process is finish it must call
+#   icp_sal_userStop(...) to free resources.
+#   NumProcesses will indicate the maximum number of processes
+#   that can call icp_sal_userStart on this instance.
+#   Warning: the ressources are preallocated: if NumProcesses
+#   is too high, the driver will fail to load
+#
+# Items configurable by a logical instance are:
+# - Name of the logical instance
+# - The accelerator associated with this logical
+#   instance
+# - The core the instance is affinitized to (optional)
+#
+# Note: Logical instances may not share the same ring, but
+#           may share a ring bank.
+#
+# The format of the logical instances are:
+# - For crypto:
+#               Cy<n>Name = "xxxx"
+#               Cy<n>AcceleratorNumber = 0|1
+#               Cy<n>CoreAffinity = 0-15
+#
+# - For Data Compression
+#               Dc<n>Name = "xxxx"
+#               Dc<n>AcceleratorNumber = 0|1
+#               Dc<n>CoreAffinity = 0-15
+#
+# Note: for user space processes, a list of values can be specified for
+# the core affinity: for example
+#              Cy0CoreAffinity = 0,2,4
+#
+# Where:
+#       - n is the number of this logical instance starting at 0.
+#       - xxxx may be any ascii value which identifies the logical instance.
+#
+########################################################
+
+##############################################
+# Kernel Instances Section
+##############################################
+[KERNEL]
+NumberCyInstances = 0
+NumberDcInstances = 0
+
+##############################################
+# Compression multi thread/process section
+##############################################
+[SHIM]
+NumberCyInstances = 0 
+NumberDcInstances = 2
+NumProcesses = 1 
+LimitDevAccess = 0 
+
+# Data Compression - User space
+Dc0Name = "UserDC0"
+Dc0AcceleratorNumber = 0,1
+Dc0IsPolled = 1
+Dc0CoreAffinity = 0
+
+# Data Compression - User space
+Dc1Name = "UserDC1"
+Dc1AcceleratorNumber = 1,0
+Dc1IsPolled = 1
+Dc1CoreAffinity = 0 
+
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/config/dh89xxcc/multi_thread_optimized/dh89xxcc_qa_dev1.conf ./contrib/qat/config/dh89xxcc/multi_thread_optimized/dh89xxcc_qa_dev1.conf
--- ../zlib-1.2.8/contrib/qat/config/dh89xxcc/multi_thread_optimized/dh89xxcc_qa_dev1.conf	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/config/dh89xxcc/multi_thread_optimized/dh89xxcc_qa_dev1.conf	2016-04-06 08:50:13.828272000 +0100
@@ -0,0 +1,194 @@
+#########################################################################
+#
+# @par
+# # This file is provided under a dual BSD/GPLv2 license.  When using or
+#   redistributing this file, you may do so under either license.
+#
+#   GPL LICENSE SUMMARY
+#
+#   Copyright(c) 2007-2012 Intel Corporation. All rights reserved.
+#
+#   This program is free software; you can redistribute it and/or modify
+#   it under the terms of version 2 of the GNU General Public License as
+#   published by the Free Software Foundation.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   General Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License
+#   along with this program; if not, write to the Free Software
+#   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#   The full GNU General Public License is included in this distribution
+#   in the file called LICENSE.GPL.
+#
+#   Contact Information:
+#   Intel Corporation
+#
+#   BSD LICENSE
+#
+#   Copyright(c) 2007,2008,2009,2010,2011,2012 Intel Corporation.
+#   All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or without
+#   modification, are permitted provided that the following conditions
+#   are met:
+#
+#     * Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above copyright
+#       notice, this list of conditions and the following disclaimer in
+#       the documentation and/or other materials provided with the
+#       distribution.
+#     * Neither the name of Intel Corporation nor the names of its
+#       contributors may be used to endorse or promote products derived
+#       from this software without specific prior written permission.
+#
+#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+#
+#########################################################################
+
+########################################################
+# General Section
+##############################################
+
+[GENERAL]
+ServicesEnabled = dc
+
+# Use version 2 of the config file
+ConfigVersion = 2
+# Look Aside Cryptographic Configuration
+cyHmacAuthMode = 1
+
+# Look Aside Compression Configuration
+dcTotalSRAMAvailable = 524288 
+
+# Firmware Location Configuration
+Firmware_MofPath = mof_firmware.bin
+Firmware_MmpPath = mmp_firmware.bin
+
+#Default values for number of concurrent requests*/
+CyNumConcurrentSymRequests = 512
+CyNumConcurrentAsymRequests = 64
+DcNumConcurrentRequests = 512
+
+#Statistics, valid values: 1,0
+statsGeneral = 1
+statsDc = 1
+statsDh = 1
+statsDrbg = 1
+statsDsa = 1
+statsEcc = 1
+statsKeyGen = 1
+statsLn = 1
+statsPrime = 1
+statsRsa = 1
+statsSym = 1
+
+#Debug feature, if set to 1 it enables additional entries in /proc filesystem
+ProcDebug = 1
+
+
+#######################################################
+# Wireless Section
+#######################################################
+[WIRELESS]
+NumProcesses = 0 
+
+#######################################################
+#
+# Logical Instances Section
+# A logical instance allows each address domain
+# (kernel space and individual user space processes)
+# to configure rings (i.e. hardware assisted queues)
+# to be used by that address domain and to define the
+# behavior of that ring.
+#
+# The address domains are in the following format
+# - For kernel address domains
+#       [KERNEL]
+# - For user process address domains
+#   [xxxxx]
+#   Where xxxxx may be any ascii value which uniquely identifies
+#   the user mode process.
+#   To allow the driver correctly configure the
+#   logical instances associated with this user process,
+#   the process must call the icp_sal_userStart(...)
+#   passing the xxxxx string during process initialisation.
+#   When the user space process is finish it must call
+#   icp_sal_userStop(...) to free resources.
+#   NumProcesses will indicate the maximum number of processes
+#   that can call icp_sal_userStart on this instance.
+#   Warning: the ressources are preallocated: if NumProcesses
+#   is too high, the driver will fail to load
+#
+# Items configurable by a logical instance are:
+# - Name of the logical instance
+# - The accelerator associated with this logical
+#   instance
+# - The core the instance is affinitized to (optional)
+#
+# Note: Logical instances may not share the same ring, but
+#           may share a ring bank.
+#
+# The format of the logical instances are:
+# - For crypto:
+#               Cy<n>Name = "xxxx"
+#               Cy<n>AcceleratorNumber = 0|1
+#               Cy<n>CoreAffinity = 0-15
+#
+# - For Data Compression
+#               Dc<n>Name = "xxxx"
+#               Dc<n>AcceleratorNumber = 0|1
+#               Dc<n>CoreAffinity = 0-15
+#
+# Note: for user space processes, a list of values can be specified for
+# the core affinity: for example
+#              Cy0CoreAffinity = 0,2,4
+#
+# Where:
+#       - n is the number of this logical instance starting at 0.
+#       - xxxx may be any ascii value which identifies the logical instance.
+#
+########################################################
+
+##############################################
+# Kernel Instances Section
+##############################################
+[KERNEL]
+NumberCyInstances = 0
+NumberDcInstances = 0
+
+##############################################
+# Compression multi thread/process section
+##############################################
+[SHIM]
+NumberCyInstances = 0 
+NumberDcInstances = 2
+NumProcesses = 1 
+LimitDevAccess = 0 
+
+# Data Compression - User space
+Dc0Name = "UserDC0"
+Dc0AcceleratorNumber = 0,1
+Dc0IsPolled = 1
+Dc0CoreAffinity = 0
+
+# Data Compression - User space
+Dc1Name = "UserDC1"
+Dc1AcceleratorNumber = 1,0
+Dc1IsPolled = 1
+Dc1CoreAffinity = 0 
+
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/config/README ./contrib/qat/config/README
--- ../zlib-1.2.8/contrib/qat/config/README	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/config/README	2016-04-06 08:50:13.784271000 +0100
@@ -0,0 +1,93 @@
+#########################################################################
+#
+# @par
+# # This file is provided under a dual BSD/GPLv2 license.  When using or
+#   redistributing this file, you may do so under either license.
+#
+#   GPL LICENSE SUMMARY
+#
+#   Copyright(c) 2007-2013 Intel Corporation. All rights reserved.
+#
+#   This program is free software; you can redistribute it and/or modify
+#   it under the terms of version 2 of the GNU General Public License as
+#   published by the Free Software Foundation.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   General Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License
+#   along with this program; if not, write to the Free Software
+#   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#   The full GNU General Public License is included in this distribution
+#   in the file called LICENSE.GPL.
+#
+#   Contact Information:
+#   Intel Corporation
+#
+#   BSD LICENSE
+#
+#   Copyright(c) 2007,2008,2009,2010,2011,2012, 2013 Intel Corporation.
+#   All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or without
+#   modification, are permitted provided that the following conditions
+#   are met:
+#
+#     * Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above copyright
+#       notice, this list of conditions and the following disclaimer in
+#       the documentation and/or other materials provided with the
+#       distribution.
+#     * Neither the name of Intel Corporation nor the names of its
+#       contributors may be used to endorse or promote products derived
+#       from this software without specific prior written permission.
+#
+#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+#
+#########################################################################
+
+These are example config files for the DH89XXCC QAT Hardware Accelerator 
+Driver 0.9.0 onwards.
+They should be used instead of the default QAT Hardware Accelerator 
+Driver config files that are placed in /etc during installation. 
+To use them: 
+* Stop the QAT Hardware Accelerator Driver. 
+* Copy the files over the existing config files in /etc
+* Restart the QAT Hardware Accelerator Driver.
+They provide support for running up to 32 simultaneous processes that are 
+using the QAT Hardware Accelerator.
+There are two directories of config files:
+* The multi_process_optimized directory contains config files that are 
+  optimized for best performance when running multiple processes that make
+  use of QAT. A single process running against this configuration will not
+  be able to make full use of the hardware acceleration even if running 
+  multiple threads.
+* The multi_thread_optimized directory contains config files that are 
+  optimized for best performance when running one or more processes that 
+  are multithreaded in their use of QAT. If the process you run in this 
+  configuration is single threaded, then even if you use multiple processes 
+  you will not be able to make full use of the hardware acceleration. 
+Please see the QAT Driver documentation for further details of the structure 
+of config files.
+For the DH89XXCC QAT Hardware Accelerator the config files are located
+within a directory called dh89xxcc.
+Only two config files are supplied. If you are running a system with more 
+than two Hardware Accelerators then you will need to copy and rename one of 
+the config files for each other Hardware Accelerators in the system.
+For systems fitted with DH895XXC QAT Hardware Accelerators: specific 
+configuration files are supplied in the dh895xcc directory.
+Please use the config files appropriate  to the hardware being used.
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/qat_contig_mem/LICENSE.GPL ./contrib/qat/qat_contig_mem/LICENSE.GPL
--- ../zlib-1.2.8/contrib/qat/qat_contig_mem/LICENSE.GPL	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/qat_contig_mem/LICENSE.GPL	2016-09-06 13:13:26.529257000 +0100
@@ -0,0 +1,339 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/qat_contig_mem/Makefile ./contrib/qat/qat_contig_mem/Makefile
--- ../zlib-1.2.8/contrib/qat/qat_contig_mem/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/qat_contig_mem/Makefile	2016-09-06 13:13:26.530258000 +0100
@@ -0,0 +1,105 @@
+#########################################################################
+#
+# @par
+# # This file is provided under a dual BSD/GPLv2 license.  When using or
+#   redistributing this file, you may do so under either license.
+#
+#   GPL LICENSE SUMMARY
+#
+#   Copyright(c) 2007-2012 Intel Corporation. All rights reserved.
+#
+#   This program is free software; you can redistribute it and/or modify
+#   it under the terms of version 2 of the GNU General Public License as
+#   published by the Free Software Foundation.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   General Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License
+#   along with this program; if not, write to the Free Software
+#   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#   The full GNU General Public License is included in this distribution
+#   in the file called LICENSE.GPL.
+#
+#   Contact Information:
+#   Intel Corporation
+#
+#   BSD LICENSE
+#
+#   Copyright(c) 2007,2008,2009,2010,2011,2012 Intel Corporation.
+#   All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or without
+#   modification, are permitted provided that the following conditions
+#   are met:
+#
+#     * Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above copyright
+#       notice, this list of conditions and the following disclaimer in
+#       the documentation and/or other materials provided with the
+#       distribution.
+#     * Neither the name of Intel Corporation nor the names of its
+#       contributors may be used to endorse or promote products derived
+#       from this software without specific prior written permission.
+#
+#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+#
+#########################################################################
+
+MODULENAME 	:= qat_contig_mem
+
+KDIR		:= /lib/modules/$(shell uname -r)/build
+PWD		:= $(shell pwd)
+
+AUTO_CONF=$(KDIR)/include/generated/autoconf.h
+
+ifdef KERNEL_SOURCE_ROOT
+# Users who are cross compiling should export environment variable PATH_AUTOCNF
+# to the correct path to file 'autoconf.h' for their target build
+# prior to running this Makefile, to override, if necessary, the default given below,
+# e.g., for a CentOS_7 target build this will be 'include/generated'
+PATH_AUTOCNF?=include/linux
+AUTO_CONF=$(KERNEL_SOURCE_ROOT)/$(PATH_AUTOCNF)/autoconf.h
+KDIR=$(KERNEL_SOURCE_ROOT)
+endif
+
+CC		:= gcc -Wall -imacros $(AUTO_CONF)
+
+ifeq ($(KERNELRELEASE),)
+all:	$(MODULENAME)_test
+all:
+	$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules
+else
+  obj-m	:= $(MODULENAME).o
+endif
+
+$(MODULENAME)_test: $(MODULENAME)_test.c
+	$(CC) -g -o $(MODULENAME)_test $(MODULENAME)_test.c
+
+
+load:
+	insmod ./$(MODULENAME).ko
+
+unload:
+	rmmod $(MODULENAME)
+
+test: all
+	./$(MODULENAME)_test
+
+clean:
+	rm -f *.o *.ko Module.symvers modules.order *.mod.c .*.cmd $(MODULENAME)_test
+
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/qat_contig_mem/qae_mem_utils.c ./contrib/qat/qat_contig_mem/qae_mem_utils.c
--- ../zlib-1.2.8/contrib/qat/qat_contig_mem/qae_mem_utils.c	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/qat_contig_mem/qae_mem_utils.c	2016-09-06 13:13:26.533255000 +0100
@@ -0,0 +1,895 @@
+/* qae_mem_utils.c -- Support code for Intel QAT hardware acceleration of zlib.
+ * Copyright (C) 2012,2014 Intel Corporation. All rights reserved.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/*****************************************************************************
+ * @file qae_mem_utils.c
+ *
+ * This file provides an interface to the QAT Linux kernel memory
+ * allocation driver and manages the slabs in user space.
+ *
+ *****************************************************************************/
+
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE
+#endif
+#include "qae_mem_utils.h"
+#ifdef USE_QAT_CONTIG_MEM
+# include "qat_contig_mem.h"
+#endif
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <assert.h>
+#include <string.h>
+#include <limits.h>
+#include <pthread.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <errno.h>
+
+#ifdef QAT_MEM_DEBUG
+# define MEM_DEBUG(...) fprintf(stderr, __VA_ARGS__)
+#else
+# define MEM_DEBUG(...)
+#endif
+
+#define MEM_ERROR(...) fprintf(stderr, __VA_ARGS__)
+
+#ifdef QAT_MEM_WARN
+# define MEM_WARN(...) fprintf (stderr, __VA_ARGS__)
+#else
+# define MEM_WARN(...)
+#endif
+
+/*
+ * Error from file descriptor operation
+ */
+#define FD_ERROR           -1
+
+/* flag for mutex lock */
+static int zlib_inited = 0;
+
+#define PAGE_SHIFT         12
+#define PAGE_SIZE          (1UL << PAGE_SHIFT)
+#define PAGE_MASK          (~(PAGE_SIZE-1))
+#define MAX_PAGES_SHIFT    5
+#define MAX_PAGES          (1UL << MAX_PAGES_SHIFT)
+
+#ifdef USE_QAT_CONTIG_MEM
+/* qat_contig_mem ioctl open file descriptor */
+static int zlib_qat_contig_memfd = FD_ERROR;
+#endif
+
+/* Big Slab Allocator Lock */
+static pthread_mutex_t zlib_bsal = PTHREAD_MUTEX_INITIALIZER;
+
+/*
+ * We allocate memory in slabs consisting of a number of slots to avoid
+ * fragmentation and also to reduce cost of allocation There are six
+ * predefined slot sizes: 256 bytes, 1024 bytes, 4096 bytes, 8192 bytes,
+ * 16384 bytes and 32768 bytes.  Slabs are 128KB in size.  This implies
+ * the most slots that a slab can hold is 128KB/256 = 512.  The first slot
+ * is used for meta info, so actual is 511.
+ */
+#define SLAB_SIZE          0x20000
+
+/* Slot sizes */
+#define NUM_SLOT_SIZE      7
+#define SLOT_256_BYTES     0x0100
+#define SLOT_1_KILOBYTES   0x0400
+#define SLOT_4_KILOBYTES   0x1000
+#define SLOT_8_KILOBYTES   0x2000
+#define SLOT_16_KILOBYTES  0x4000
+#define SLOT_32_KILOBYTES  0x8000
+#define SLOT_DEFAULT_INIT  -1
+/* slot free signature */
+#define SIG_FREE           0xF1F2F3F4
+
+/* slot allocate signature */
+#define SIG_ALLOC          0xA1A2A3A4
+
+/* maxmium slot size */
+#define MAX_ALLOC (SLAB_SIZE - sizeof(qae_slab) - QAE_BYTE_ALIGNMENT)
+#define MAX_EMPTY_SLAB     256
+
+#define IN_EMPTY_LIST      0
+#define IN_AVAILABLE_LIST  1
+#define IN_FULL_LIST       2
+
+static int slot_sizes_available[] = {
+    SLOT_256_BYTES,
+    SLOT_1_KILOBYTES,
+    SLOT_4_KILOBYTES,
+    SLOT_8_KILOBYTES,
+    SLOT_16_KILOBYTES,
+    SLOT_32_KILOBYTES
+};
+
+typedef struct _qae_slot {
+    struct _qae_slot *next;
+    int sig;
+    int pool_index;
+    /* pointer to the slab which contains this slot */
+    struct _qae_slab *slab;
+    char *file;
+    int line;
+} qae_slot;
+
+typedef struct _qae_slab {
+    qat_contig_mem_config memCfg;
+    /* this field has two meanings:
+     *  in normal slab node, it means the size of the slot in current slab
+     *  as a head slab node, it means the number of slabs in current list */
+    int slot_size;
+    int sig;
+    struct _qae_slab *next;
+    struct _qae_slab *prev;
+    struct _qae_slot *next_slot;
+    /* used slots in slab */
+    int used_slots;
+    /* total slots in slab */
+    int total_slots;
+    /* indicate which slab list is current slab in */
+    int list_index;
+    /* indicate which process alloc this slab */
+    pid_t pid;
+} qae_slab;
+
+/* head of a cyclic doubly linked list, reused qae_slab data structure */
+typedef qae_slab qae_slab_pool;
+
+/* slab list containing full used slabs */
+static qae_slab_pool full_slab_list;
+/* array of slab lists containing empty slabs by slot size */
+static qae_slab_pool empty_slab_list[NUM_SLOT_SIZE];
+/* array of slab lists containing partially used slabs by slot size */
+static qae_slab_pool available_slab_list[NUM_SLOT_SIZE];
+
+/* init the head node of a linked list */
+static void init_pool(qae_slab_pool *list)
+{
+    memset(list,0,sizeof(qae_slab_pool));
+    list->next = (qae_slab *)list;
+    list->prev = (qae_slab *)list;
+    list->slot_size = 0;
+    list->pid = getpid();
+}
+
+/* fetch the head node from a list */
+static qae_slab * get_node_from_head(qae_slab_pool *list)
+{
+    qae_slab *ret = NULL;
+    if(list->slot_size <= 0)
+        return ret;
+    ret = list->next;
+    ret->next->prev = (qae_slab *)list;
+    list->next = ret->next;
+    ret->next = ret->prev = NULL;
+    list->slot_size--;
+    return ret;
+}
+
+/* remove the node from a list */
+static unsigned int remove_node_from_list(qae_slab_pool *list, qae_slab *node)
+{
+    if(!(node && list->slot_size > 0)) {
+        return 0;
+    }
+    node->prev->next = node->next;
+    node->next->prev = node->prev;
+    list->slot_size--;
+    node->next = node->prev = NULL;
+    return 1;
+}
+
+/* insert a node to the end of a list */
+static void insert_node_at_end(qae_slab_pool *list, qae_slab *node)
+{
+    qae_slab *tail = list->prev;
+    tail->next = node;
+    node->prev = tail;
+    node->next = (qae_slab *)list;
+    list->prev = node;
+    list->slot_size++;
+}
+
+/* insert a node at the head of a list */
+static void insert_node_at_head(qae_slab_pool *list, qae_slab *node)
+{
+    qae_slab *head = list->next;
+    head->prev = node;
+    node->next = head;
+    node->prev = (qae_slab *)list;
+    list->next = node;
+    list->slot_size++;
+}
+
+static void zlib_init(void);
+
+
+/*****************************************************************************
+ * function:
+ *         zlib_create_slab(int size, int pool_index)
+ *
+ * @param[in] size, the size of the slots within the slab. Note that this is
+ *                  not the size of the slab itself
+ * @param[in] pool_index, the index of the slot pool
+ * @retval qae_slab*, a pointer to the new slab.
+ *
+ * @description
+ *      create a new slab and add it to the global linked list
+ *      retval pointer to the new slab
+ *
+ *****************************************************************************/
+static qae_slab *zlib_create_slab(int size, int pool_index)
+{
+    int i = 0;
+    int nslot = 0;
+    qat_contig_mem_config qmcfg = { 0, (uintptr_t) NULL, 0, (uintptr_t) NULL };
+    qae_slab *result = NULL;
+    qae_slab *slb = NULL;
+    qae_slot *slt = NULL;
+    QAE_UINT alignment;
+
+    qmcfg.length = SLAB_SIZE;
+#ifdef USE_QAT_CONTIG_MEM
+    if (ioctl(zlib_qat_contig_memfd, QAT_CONTIG_MEM_MALLOC, &qmcfg) == -1) {
+        static char errmsg[LINE_MAX];
+
+        snprintf(errmsg, LINE_MAX, "ioctl QAT_CONTIG_MEM_MALLOC(%d)",
+                 qmcfg.length);
+        perror(errmsg);
+        goto exit;
+    }
+    if ((slb =
+         mmap(NULL, qmcfg.length*QAT_CONTIG_MEM_MMAP_ADJUSTMENT,
+              PROT_READ | PROT_WRITE,
+              MAP_SHARED | MAP_LOCKED, zlib_qat_contig_memfd,
+              qmcfg.virtualAddress)) == MAP_FAILED) {
+        static char errmsg[LINE_MAX];
+        snprintf(errmsg, LINE_MAX, "mmap: %d %s", errno, strerror(errno));
+        perror(errmsg);
+        goto exit;
+    }
+#endif
+    MEM_DEBUG("%s slot size %d\n", __func__, size);
+    slb->slot_size = size;
+    slb->next_slot = NULL;
+    slb->sig = SIG_ALLOC;
+    slb->used_slots = 0;
+    slb->pid = getpid();
+
+    for (i = sizeof(qae_slab); SLAB_SIZE - i >= size; i += size) {
+        slt = (qae_slot *) ((unsigned char *)slb + i);
+        alignment =
+            QAE_BYTE_ALIGNMENT -
+            (((QAE_UINT) slt + sizeof(qae_slot)) % QAE_BYTE_ALIGNMENT);
+        slt = (qae_slot *) (((QAE_UINT) slt) + alignment);
+        slt->next = slb->next_slot;
+        slt->pool_index = pool_index;
+        slt->sig = SIG_FREE;
+        slt->file = NULL;
+        slt->line = 0;
+        slb->next_slot = slt;
+        nslot++;
+        slt->slab = slb;
+    }
+    slb->total_slots = nslot;
+    /*
+     * Make sure the update of the slab list is the last thing to be done.
+     * This means it is not necessary to lock against anyone iterating the
+     * list from the head
+     */
+
+    result = slb;
+    MEM_DEBUG("%s slab %p last slot is %p, count is %d\n", __func__, slb, slt,
+          nslot);
+ exit:
+    return result;
+}
+
+
+/*****************************************************************************
+ * function:
+ *         zlib_get_empty_slab(int size, int pool_index)
+ *
+ * @param[in] size, the size of the slots within the slab. Note that this is
+ *                  not the size of the slab itself
+ * @param[in] pool_index, index of slot pools
+ * @retval qae_slab*, a pointer to the new slab.
+ *
+ * @description
+ *     request a slab from the empty slab list, if empty slab list has no slab
+ *     available, then create a new slab
+ *     retval pointer to the new slab
+ *
+ ******************************************************************************/
+static qae_slab *zlib_get_empty_slab(int size, int pool_index)
+{
+    qae_slab *result = NULL;
+    result = get_node_from_head(&empty_slab_list[pool_index]);
+    if(result == NULL) {
+        result = zlib_create_slab(size, pool_index);
+    }
+    return result;
+}
+
+/*****************************************************************************
+ * function:
+ *         zlib_alloc_from_slab(int size, const char *file, int line)
+ *
+ * @param[in] size, the size of the memory block required
+ * @param[in] file, the C source filename of the call site
+ * @param[in] line, the line number within the C source file of the call site
+ *
+ * @description
+ *      allocate a slot of memory from some slab
+ *      retval pointer to the allocated block
+ *
+ *****************************************************************************/
+static void *zlib_alloc_from_slab(int size, const char *file, int line)
+{
+    qae_slab *slb = NULL;
+    qae_slot *slt;
+    int slot_size;
+    void *result = NULL;
+    int rc;
+    int i;
+
+    if (!zlib_inited)
+        zlib_init();
+
+    size += sizeof(qae_slot);
+    size += QAE_BYTE_ALIGNMENT;
+
+    slot_size = SLOT_DEFAULT_INIT;
+
+    for (i = 0; i < sizeof(slot_sizes_available) / sizeof(int); i++) {
+        if (size < slot_sizes_available[i]) {
+            slot_size = slot_sizes_available[i];
+            break;
+        }
+    }
+
+    if (SLOT_DEFAULT_INIT == slot_size) {
+        if (size <= MAX_ALLOC) {
+            slot_size = MAX_ALLOC;
+        } else {
+            MEM_ERROR("%s Allocation of %d bytes is too big\n", __func__, size);
+            goto exit;
+        }
+    }
+
+    if (available_slab_list[i].pid != getpid())
+        zlib_init();
+
+    MEM_DEBUG("%s: pthread_mutex_lock\n", __func__);
+    if ((rc = pthread_mutex_lock(&zlib_bsal)) != 0) {
+        MEM_ERROR("pthread_mutex_lock: %s\n", strerror(rc));
+        return result;
+    }
+
+    if(available_slab_list[i].slot_size > 0) {
+        slt = available_slab_list[i].next->next_slot;
+    } else {
+        /* no free slots need to allocate new slab */
+        slb = zlib_get_empty_slab(slot_size, i);
+
+        if (NULL == slb) {
+            MEM_ERROR("%s error, create_slab failed - memory allocation error\n",
+                  __func__);
+            if ((rc = pthread_mutex_unlock(&zlib_bsal)) != 0)
+                MEM_ERROR("pthread_mutex_unlock: %s\n", strerror(rc));
+            MEM_DEBUG("%s: pthread_mutex_unlock\n", __func__);
+            goto exit;
+        }
+        /*allocate a new slab, add it into the available slab list*/
+        slt = slb->next_slot;
+        slb->list_index = IN_AVAILABLE_LIST;
+        insert_node_at_head(&available_slab_list[i],slb);
+    }
+
+    slb = slt->slab;
+    if (slt->sig != SIG_FREE) {
+        MEM_ERROR("%s error alloc slot that isn't free %p\n", __func__, slt);
+        exit(1);
+    }
+
+    slt->sig = SIG_ALLOC;
+    slt->file = strdup(file);
+    slt->line = line;
+
+   /* increase the reference couter */
+    slb->used_slots++;
+    /* get the available slot from the head of available slab list */
+    slb->next_slot = slt->next;
+    slt->next = NULL;
+    /* if current slab has no slot available, remove the slab from
+     * available slab list and add it to the full slab list */
+    if(slb->used_slots >= slb->total_slots) {
+        remove_node_from_list(&available_slab_list[i],slb);
+        insert_node_at_end(&full_slab_list,slb);
+        slb->list_index = IN_FULL_LIST;
+    }
+
+    result = (void *)((unsigned char *)slt + sizeof(qae_slot));
+
+    if ((rc = pthread_mutex_unlock(&zlib_bsal)) != 0)
+        MEM_ERROR("pthread_mutex_unlock: %s\n", strerror(rc));
+    MEM_DEBUG("%s: pthread_mutex_unlock\n", __func__);
+
+ exit:
+    return result;
+}
+
+/*****************************************************************************
+ * function:
+ *         zlib_free_slab(qae_slab *slb)
+ *
+ * @param[in] slb, pointer to the slab to be freed
+ *
+ * @description
+ *      free a slab to kernel
+ *
+ ******************************************************************************/
+static void zlib_free_slab(qae_slab *slb)
+{
+    qat_contig_mem_config qmcfg;
+
+#ifdef USE_QAT_CONTIG_MEM
+    MEM_DEBUG("%s do munmap  of %p\n", __func__, slb);
+    qmcfg = *((qat_contig_mem_config *) slb);
+
+    if (munmap(slb, SLAB_SIZE) == -1) {
+        perror("munmap");
+        exit(EXIT_FAILURE);
+    }
+    MEM_DEBUG("%s ioctl free of %p\n", __func__, slb);
+    if (ioctl(zlib_qat_contig_memfd, QAT_CONTIG_MEM_FREE, &qmcfg) == -1) {
+        perror("ioctl QAT_CONTIG_MEM_FREE");
+        exit(EXIT_FAILURE);
+    }
+#endif
+}
+
+/*****************************************************************************
+ * function:
+ *         zlib_free_to_slab(void *ptr)
+ *
+ * @param[in] ptr, pointer to the memory to be freed
+ *
+ * @description
+ *      free a slot of memory back to its slab
+ *
+ *****************************************************************************/
+static void zlib_free_to_slab(void *ptr)
+{
+    qae_slot *slt = (void *)((unsigned char *)ptr - sizeof(qae_slot));
+    if (!slt) {
+        MEM_ERROR("Error freeing memory - unknown address\n");
+        goto exit;
+    }
+
+    qae_slab *slb = slt->slab;
+    int i = slt->pool_index;
+    int rc;
+
+    if ((rc = pthread_mutex_lock(&zlib_bsal)) != 0) {
+        MEM_ERROR("pthread_mutex_lock: %s\n", strerror(rc));
+        return;
+    }
+
+    MEM_DEBUG("%s: pthread_mutex_lock\n", __func__);
+    if (slt->sig != SIG_ALLOC) {
+        MEM_ERROR("%s error trying to free slot that hasn't been alloc'd %p\n",
+              __func__, slt);
+        goto exit;
+    }
+
+    free(slt->file);
+    slt->sig = SIG_FREE;
+    slt->file = NULL;
+    slt->line = 0;
+
+    /* insert the slot into the slab */
+    slt->next = slb->next_slot;
+    slb->next_slot = slt;
+    /* decrease the reference count */
+    slb->used_slots--;
+    /* if the used_slots is 0, this slab is empty, it should be
+     * processed properly */
+    if(slb->used_slots == 0) {
+        /* remove this slab from the slab list */
+        switch(slb->list_index) {
+            case IN_AVAILABLE_LIST:
+                remove_node_from_list(&available_slab_list[i],slb);
+                break;
+            case IN_FULL_LIST:
+                remove_node_from_list(&full_slab_list,slb);
+                break;
+            default:
+                break;
+        }
+        /* free slab or assign it to the head of the empty slab list */
+        if(empty_slab_list[i].slot_size >= MAX_EMPTY_SLAB) {
+            zlib_free_slab(slb);
+            slb = NULL;
+        } else {
+            insert_node_at_head(&empty_slab_list[i],slb);
+            slb->list_index = IN_EMPTY_LIST;
+        }
+    } else {
+    /* if current slab is in full slab list,
+     *  remove it from the full_slab_list list and then
+     *  append it at the end of the available list */
+        switch(slb->list_index) {
+            case IN_FULL_LIST:
+                remove_node_from_list(&full_slab_list,slb);
+                insert_node_at_end(&available_slab_list[i],slb);
+                slt->slab->list_index = IN_AVAILABLE_LIST;
+                break;
+            default:
+                break;
+        }
+    }
+
+ exit:
+    if ((rc = pthread_mutex_unlock(&zlib_bsal)) != 0)
+        MEM_ERROR("pthread_mutex_unlock: %s\n", strerror(rc));
+    MEM_DEBUG("%s: pthread_mutex_unlock\n", __func__);
+}
+
+/*****************************************************************************
+ * function:
+ *         zlib_slot_get_size(void *ptr)
+ *
+ * @param[in] ptr, pointer to the slot memory
+ * @retval int, the size of the slot in bytes
+ *
+ * @description
+ *      get the slot memory size in bytes
+ *
+ *****************************************************************************/
+static int zlib_slot_get_size(void *ptr)
+{
+    if (NULL == ptr) {
+        MEM_ERROR("%s error can't find %p\n", __func__, ptr);
+        return 0;
+    }
+    qae_slot *slt = (void *)((unsigned char *)ptr - sizeof(qae_slot));
+    if (slt->pool_index == (NUM_SLOT_SIZE - 1)) {
+        return MAX_ALLOC;
+    } else if (slt->pool_index >= 0 && slt->pool_index <= NUM_SLOT_SIZE - 2) {
+        return slot_sizes_available[slt->pool_index] - sizeof(qae_slot) -
+            QAE_BYTE_ALIGNMENT;
+    } else {
+        MEM_ERROR("%s error invalid pool_index %d\n", __func__, slt->pool_index);
+        return 0;
+    }
+}
+
+/*****************************************************************************
+ * function:
+ *         fork_slab_list(qae_slab* list)
+ * @param[in] list, pointer to a slab list
+ *
+ * @description
+ *      allocate and remap memory following a fork
+ *
+ *****************************************************************************/
+static void fork_slab_list(qae_slab_pool * list)
+{
+    int rc = 0;
+    int count = 0;
+    if ((rc = pthread_mutex_lock(&zlib_bsal)) != 0) {
+        MEM_ERROR("pthread_mutex_lock: %s\n", strerror(rc));
+        return;
+    }
+    MEM_DEBUG("%s: pthread_mutex_lock\n", __func__);
+    qae_slab *old_slb = list->next;
+    qae_slab *new_slb = NULL;
+    qat_contig_mem_config qmcfg =
+        { 0, (uintptr_t) NULL, SLAB_SIZE, (uintptr_t) NULL };
+
+    while (count < list->slot_size) {
+#ifdef USE_QAT_CONTIG_MEM
+        if (ioctl(zlib_qat_contig_memfd, QAT_CONTIG_MEM_MALLOC, &qmcfg)
+            == -1) {
+            static char errmsg[LINE_MAX];
+
+            snprintf(errmsg, LINE_MAX, "ioctl QAT_CONTIG_MEM_MALLOC(%d)",
+                     qmcfg.length);
+            perror(errmsg);
+            exit(EXIT_FAILURE);
+        }
+
+        if ((new_slb =
+             mmap(NULL, qmcfg.length*QAT_CONTIG_MEM_MMAP_ADJUSTMENT,
+                  PROT_READ | PROT_WRITE,
+                  MAP_SHARED | MAP_LOCKED, zlib_qat_contig_memfd,
+                  qmcfg.virtualAddress)) == MAP_FAILED) {
+            static char errmsg[LINE_MAX];
+            snprintf(errmsg, LINE_MAX, "mmap: %d %s", errno, strerror(errno));
+            perror(errmsg);
+            exit(EXIT_FAILURE);
+        }
+        memcpy((void *)new_slb + sizeof(qat_contig_mem_config),
+               (void *)old_slb + sizeof(qat_contig_mem_config),
+               SLAB_SIZE - sizeof(qat_contig_mem_config));
+
+#endif
+        qae_slab *to_unmap = old_slb;
+        old_slb = old_slb->next;
+        if (munmap(to_unmap, SLAB_SIZE) == -1) {
+            perror("munmap");
+            exit(EXIT_FAILURE);
+        }
+        qae_slab *remap = mremap(new_slb, SLAB_SIZE, SLAB_SIZE,
+                                 MREMAP_FIXED | MREMAP_MAYMOVE, to_unmap);
+        if ((remap == MAP_FAILED) || (remap != to_unmap)) {
+            perror("mremap");
+            exit(EXIT_FAILURE);
+        }
+        count++;
+    }
+
+    if ((rc = pthread_mutex_unlock(&zlib_bsal)) != 0)
+        MEM_ERROR("pthread_mutex_unlock: %s\n", strerror(rc));
+    MEM_DEBUG("%s: pthread_mutex_unlock\n", __func__);
+}
+
+/*****************************************************************************
+ * function:
+ *        zlib_free_slab_list(qae_slab_pool *list)
+ * @param[in] list, pointer to a slab list
+ *
+ * @description
+ *      Free all slabs in the supplied slab list.
+ *
+ ******************************************************************************/
+static void zlib_free_slab_list(qae_slab_pool *list)
+{
+    qae_slab *slb, *s_next_slab;
+    int rc;
+#ifdef USE_QAT_CONTIG_MEM
+    qat_contig_mem_config qmcfg;
+#endif
+
+    if ((rc = pthread_mutex_lock(&zlib_bsal)) != 0) {
+        MEM_ERROR("pthread_mutex_lock: %s\n", strerror(rc));
+        return;
+    }
+
+    MEM_DEBUG("%s: pthread_mutex_lock\n", __func__);
+    /* cleanup all the empty slab */
+    for (slb = list->next; list->slot_size > 0 ; slb = s_next_slab) {
+        /* need to save this off before unmapping. This is why we can't have
+           slb = slb->next_slab in the for loop above. */
+        s_next_slab = slb->next;
+#ifdef USE_QAT_CONTIG_MEM
+        MEM_DEBUG("%s do munmap  of %p\n", __func__, slb);
+        qmcfg = *((qat_contig_mem_config *) slb);
+
+        if (munmap(slb, SLAB_SIZE) == -1) {
+            perror("munmap");
+            exit(EXIT_FAILURE);
+        }
+        MEM_DEBUG("%s ioctl free of %p\n", __func__, slb);
+        if (ioctl(zlib_qat_contig_memfd, QAT_CONTIG_MEM_FREE, &qmcfg)
+            == -1) {
+            perror("ioctl QAT_CONTIG_MEM_FREE");
+            exit(EXIT_FAILURE);
+        }
+#endif
+        list->slot_size--;
+    }
+
+    MEM_DEBUG("%s done\n", __func__);
+
+    if ((rc = pthread_mutex_unlock(&zlib_bsal)) != 0)
+        MEM_ERROR("pthread_mutex_unlock: %s\n", strerror(rc));
+    MEM_DEBUG("%s: pthread_mutex_unlock\n", __func__);
+}
+
+/*****************************************************************************
+ * function:
+ *        zlib_free_empty_slab_list(void)
+ *
+ * @description
+ *      Free all slabs in the empty slab list.
+ *
+ ******************************************************************************/
+static void zlib_free_empty_slab_list()
+{
+    int i;
+    for(i = 0; i < NUM_SLOT_SIZE; i++) {
+        zlib_free_slab_list(&empty_slab_list[i]);
+    }
+
+}
+
+/*****************************************************************************
+ * function:
+ *        slab_list_stat(qae_slab * list)
+ * @param[in] list, pointer to a slab list
+ * @description
+ *      print statistical information about a slab list.
+ *
+ ******************************************************************************/
+static void slab_list_stat(qae_slab_pool * list)
+{
+    qae_slab *slb;
+    int index;
+    if(0 == list->slot_size) {
+        fprintf(stderr,"The list is empty.\n");
+        return;
+    }
+    for (slb = list->next, index = 0; index < list->slot_size;
+         slb = slb->next) {
+        fprintf(stderr,"Slab index        : %d\n",index++);
+        fprintf(stderr,"Slab virtual addr : %p\n",
+                (void *)slb->memCfg.virtualAddress);
+        fprintf(stderr,"Slab physical addr: %p\n",
+                (void *)slb->memCfg.physicalAddress);
+        fprintf(stderr,"Slab slot size    : %d\n",slb->slot_size);
+        fprintf(stderr,"Slab used slots   : %d\n",slb->used_slots);
+        fprintf(stderr,"Slab total slots  : %d\n",slb->total_slots);
+    }
+    return;
+}
+
+/*****************************************************************************
+ * function:
+ *         zlib_cleanup_slabs(void)
+ *
+ * @description
+ *      Free all memory managed by the slab allocator. This function is
+ *      intended to be registered as an atexit() handler.
+ *
+ *****************************************************************************/
+void zlib_cleanup_slabs(void)
+{
+    zlib_free_empty_slab_list();
+#ifdef QAT_MEM_DEBUG
+    int i;
+    /* stat of available slab list*/
+    for(i = 0;  i < NUM_SLOT_SIZE; i++) {
+        fprintf(stderr,"available_slab_list[%d]:\n",i);
+        slab_list_stat(&available_slab_list[i]);
+    }
+    /*stat of full slab list*/
+    fprintf(stderr,"full_slab_list:\n");
+    slab_list_stat(&full_slab_list);
+#endif
+}
+
+/******************************************************************************
+* function:
+*         zlib_init(void)
+*
+* @description
+*   Initialise the user-space part of the QAT memory allocator.
+*
+******************************************************************************/
+static void zlib_init(void)
+{
+    int i = 0;
+    for(i = 0 ; i < NUM_SLOT_SIZE ; i++) {
+        init_pool(&available_slab_list[i]);
+        init_pool(&empty_slab_list[i]);
+    }
+    init_pool(&full_slab_list);
+#ifdef USE_QAT_CONTIG_MEM
+    if ((zlib_qat_contig_memfd = open("/dev/qat_contig_mem", O_RDWR)) == FD_ERROR) {
+        perror("open qat_contig_mem");
+        exit(EXIT_FAILURE);
+    }
+#endif
+    atexit(zlib_cleanup_slabs);
+    zlib_inited = 1;
+}
+
+/*****************************************************************************
+ * function:
+ *         qaeZlibAtFork()
+ *
+ * @description
+ *      allocate and remap memory following a fork
+ *
+ *****************************************************************************/
+void qaeZlibAtFork()
+{
+    int i;
+    fork_slab_list(&full_slab_list);
+    for(i = 0;i < NUM_SLOT_SIZE; i++) {
+        fork_slab_list(&empty_slab_list[i]);
+        fork_slab_list(&available_slab_list[i]);
+    }
+}
+
+/******************************************************************************
+* function:
+*         qaeZlibMemV2P(void *v)
+*
+* @param[in] v, virtual memory address pointer
+* @retval CpaPhysicalAddress, the physical memory address pointer, it
+*         returns 0 if not found.
+*
+* description:
+*       map virtual memory address to physical memory address
+*
+******************************************************************************/
+CpaPhysicalAddr qaeZlibMemV2P(void *v)
+{
+   qat_contig_mem_config *memCfg = NULL;
+   void *pVirtPageAddress = NULL;
+   ptrdiff_t offset = 0;
+   if(v == NULL) {
+       MEM_WARN("%s: NULL address passed to function\n", __func__);
+       return (CpaPhysicalAddr) 0;
+   }
+
+   /* Get the physical address contained in the slab
+      header using the fact the slabs are aligned in
+      virtual address space */
+   pVirtPageAddress = (void *)(((ptrdiff_t)v) &
+                      (~(MAX_PAGES*PAGE_SIZE-1)));
+
+   offset = (ptrdiff_t)v &
+            (ptrdiff_t)(MAX_PAGES*PAGE_SIZE-1);
+
+   memCfg = (qat_contig_mem_config *)pVirtPageAddress;
+   if(memCfg->signature == QAT_CONTIG_MEM_ALLOC_SIG)
+       return (CpaPhysicalAddr)(memCfg->physicalAddress + offset);
+   MEM_WARN("%s: Virtual to Physical memory lookup failure\n", __func__);
+   return (CpaPhysicalAddr) 0;
+}
+
+/**************************************
+ * Memory functions
+ *************************************/
+
+/******************************************************************************
+* function:
+*         qaeZlibPinnedMemAlloc(size_t memsize, Cpa32U nodeId , 
+*                               const char *file, int line)
+*
+* @param[in] memsize,  size of usable memory requested
+* @param[in] nodeId,   NUMA node to allocate on
+* @param[in] file,     the C source filename of the call site
+* @param[in] line,     the line number within the C source file of the call
+*                      site
+*
+* description:
+*   Allocate a block of pinned memory.
+*
+******************************************************************************/
+void *qaeZlibPinnedMemAlloc(size_t memsize, Cpa32U nodeId,
+                            const char *file, int line)
+{
+    void *pAddress = zlib_alloc_from_slab(memsize, file, line);
+    MEM_DEBUG("%s: Address: %p Size: %d File: %s:%d\n", __func__, pAddress,
+          memsize, file, line);
+    return pAddress;
+}
+
+/******************************************************************************
+* function:
+*         qaeZlibPinnedMemFree(void *ptr)
+*
+* @param[in] ptr, address of start of usable memory
+*
+* description:
+*   Free a block of memory previously allocated by this allocator.
+*
+******************************************************************************/
+void qaeZlibPinnedMemFree(void *ptr)
+{
+    MEM_DEBUG("%s: Address: %p\n", __func__, ptr);
+    if (NULL != ptr)
+        zlib_free_to_slab(ptr);
+}
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/qat_contig_mem/qae_mem_utils.h ./contrib/qat/qat_contig_mem/qae_mem_utils.h
--- ../zlib-1.2.8/contrib/qat/qat_contig_mem/qae_mem_utils.h	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/qat_contig_mem/qae_mem_utils.h	2016-09-06 13:13:26.534256000 +0100
@@ -0,0 +1,92 @@
+/* qae_mem_utils.h -- Support code for Intel QAT hardware acceleration of zlib.
+ * Copyright (C) 2012 Intel Corporation. All rights reserved.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/*****************************************************************************
+ * @file qae_mem_utils.h
+ *
+ * This file provides linux kernel memory allocation for quick assist API
+ *
+ *****************************************************************************/
+
+#ifndef __QAE_MEM_UTILS_H
+#define __QAE_MEM_UTILS_H
+
+#include "cpa.h"
+
+/*define types which need to vary between 32 and 64 bit*/
+#ifdef __x86_64__
+#define QAE_UINT  Cpa64U
+#define QAE_INT   Cpa64S
+#else
+#define QAE_UINT  Cpa32U
+#define QAE_INT  Cpa32S
+#endif
+
+#define QAE_BYTE_ALIGNMENT 0x0040 /* 64 bytes */
+
+/*****************************************************************************
+ * function:
+ *         qaeZlibPinnedMemAlloc(size_t memsize, Cpa32U nodeId,
+                                 const char *file, int line);
+ *
+ * @description
+ *      allocates memsize bytes of memory aligned to a 64 byte address.
+ *      The returned pointer will always be 64 byte aligned to ensure
+ *      best performance from the accelerator.
+ *
+ * @param[in] memsize, the amount of memory in bytes to be allocated
+ * @param[in] nodeId, the NUMA node to allocate memory on
+ *
+ * @retval pointer to the allocated memory
+ *
+ *****************************************************************************/
+void *qaeZlibPinnedMemAlloc(size_t memsize, Cpa32U nodeId,
+                            const char *file, int line);
+
+
+/*****************************************************************************
+ * function:
+ *         qaeZlibPinnedMemFree(void *ptr)
+ *
+ * @description
+ *      frees memory allocated by the qaeMemAlloc function
+ *
+ *
+ * @param[in] pointer to the memory to be freed
+ *
+ * @retval none
+ *
+ *****************************************************************************/
+void qaeZlibPinnedMemFree(void *ptr);
+
+
+/*****************************************************************************
+ * function:
+ *         qaeZlibMemV2P(void *v)
+ *
+ * @description
+ * 	find the physical address of a block of memory referred to by virtual
+ * 	address v in the current process's address map
+ *
+ *
+ * @param[in] ptr, virtual pointer to the memory
+ *
+ * @retval the physical address of the memory referred to by ptr
+ *
+ *****************************************************************************/
+CpaPhysicalAddr qaeZlibMemV2P(void *v);
+
+
+/*****************************************************************************
+ * function:
+ *         qaeZlibAtFork()
+ *
+ * @description
+ * 	allocate and remap memory following a fork
+ *
+ *****************************************************************************/
+void qaeZlibAtFork();
+
+#endif
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/qat_contig_mem/qat_contig_mem.c ./contrib/qat/qat_contig_mem/qat_contig_mem.c
--- ../zlib-1.2.8/contrib/qat/qat_contig_mem/qat_contig_mem.c	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/qat_contig_mem/qat_contig_mem.c	2016-09-06 13:13:26.535255000 +0100
@@ -0,0 +1,546 @@
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007-2014 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012,2013,2014 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+/* This example contiguous memory allocator is written as a slab allocator.
+   The expectation is that allocations passed to it are for
+   multiples of PAGE_SIZE up to 2^5 pages. If you use a non-multiple
+   of PAGE_SIZE you need to be careful how you use mmap and how you
+   locate the slab header. */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/mm.h>
+#include <asm/io.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+
+#include "qat_contig_mem.h"
+
+#define PAGE_ORDER 5
+#define MAX_MEM_ALLOC (PAGE_SIZE * (2 << PAGE_ORDER) - sizeof(qat_contig_mem_config))
+
+static int major;
+static unsigned long bytesToPageOrder(long int memSize);
+
+module_param(major, int, S_IRUGO);
+
+/**
+ *****************************************************************************
+ * @description
+ *      This structure contains data relating to the device driver that this
+ *      file implements
+ *
+ ****************************************************************************/
+typedef struct chr_drv_info_s {
+    struct module *owner;
+    unsigned major;
+    unsigned min_minor;
+    unsigned max_minor;
+    char *name;
+    struct file_operations *file_ops;
+    struct cdev drv_cdev;
+    struct class *drv_class;
+    struct device *drv_class_dev;
+} chr_drv_info_t;
+
+#define DEV_MEM_NAME            "qat_contig_mem"
+#define DEV_MEM_MAJOR           0
+#define DEV_MEM_MAX_MINOR       4
+#define DEV_MEM_BASE_MINOR      0
+#define FAIL                    1
+#define SUCCESS                 0
+#define FREE(ptr) kfree(ptr)
+
+/******************************************************************************
+* function:
+*         qat_contig_mem_read(struct file *filp, char __user *buffer, size_t length,
+*                             loff_t *offset)
+*
+* @param filp   [IN] - unused
+* @param buffer [IN] - unused
+* @param length [IN] - unused
+* @param offset [IN] - unused
+*
+* description:
+*   Callback for read operations on the device node. We don't support them.
+*
+******************************************************************************/
+static ssize_t qat_contig_mem_read(struct file *filp, char __user * buffer,
+                                   size_t length, loff_t * offset)
+{
+    return -EIO;
+}
+
+/******************************************************************************
+* function:
+*         qat_contig_mem_write(struct file *filp, char __user *buffer, size_t length,
+*                              loff_t *offset)
+*
+* @param filp [IN] - unused
+* @param buff [IN] - unused
+* @param leng [IN] - unused
+* @param off  [IN] - unused
+*
+* description:
+*   Callback for write operations on the device node. We don't support them.
+*
+******************************************************************************/
+static ssize_t qat_contig_mem_write(struct file *filp, const char __user * buff,
+                                    size_t len, loff_t * off)
+{
+    return -EIO;
+}
+
+/*
+ * driver open function
+ */
+static int qat_contig_mem_open(struct inode *inp, struct file *fp)
+{
+    return 0;
+}
+
+/*
+ * driver close/release function
+ */
+static int qat_contig_mem_release(struct inode *inp, struct file *fp)
+{
+    return 0;
+}
+
+/******************************************************************************
+* function:
+*         do_ioctl(qat_contig_mem_config *mem, unsigned int cmd, unsigned long arg)
+*
+* @param mem [IN] - pointer to mem structure
+* @param cmd [IN] - ioctl number requested
+* @param arg [IN] - any arg needed by ioctl implementaion
+*
+* description:
+*   Callback for ioctl operations on the device node. This is our control path.
+*   We support two ioctls, QAT_MEM_MALLOC and QAT_MEM_FREE.
+*
+******************************************************************************/
+static int do_ioctl(qat_contig_mem_config * mem, unsigned int cmd, unsigned long arg)
+{
+
+    switch (cmd) {
+    case QAT_CONTIG_MEM_MALLOC:
+        if (mem->length <= 0) {
+            printk
+                ("%s: invalid inputs in qat_contig_mem_config structure!\n",
+                 __func__);
+            return -EINVAL;
+        }
+
+        if (mem->length > MAX_MEM_ALLOC) {
+            printk
+                ("%s: memory requested (%d) greater than max allocation (%ld)\n",
+                 __func__, mem->length, MAX_MEM_ALLOC);
+            return -EINVAL;
+        }
+        mem->virtualAddress =
+            (uintptr_t) __get_free_pages(GFP_KERNEL,
+                                         bytesToPageOrder(mem->length));
+        if (mem->virtualAddress == (uintptr_t) 0) {
+            printk("%s: __get_free_pages() failed\n", __func__);
+            return -EINVAL;
+        }
+
+        mem->physicalAddress =
+            (uintptr_t) virt_to_phys((void *)(mem->virtualAddress));
+        mem->signature = QAT_CONTIG_MEM_ALLOC_SIG;
+        memcpy((unsigned char *)mem->virtualAddress, mem, sizeof(*mem));
+
+        if (copy_to_user((void *)arg, mem, sizeof(*mem))) {
+            printk("%s: copy_to_user failed\n", __func__);
+            return -EFAULT;
+        }
+        break;
+
+    case QAT_CONTIG_MEM_FREE:
+        if ((void *)mem->virtualAddress == NULL) {
+            printk
+                ("%s: invalid inputs in qat_contig_mem_config structure !\n",
+                 __func__);
+            return -EINVAL;
+        }
+
+        free_pages((unsigned long)mem->virtualAddress,
+                   bytesToPageOrder(mem->length));
+        break;
+
+    default:
+        printk("%s: unknown request\n", __func__);
+        return -ENOTTY;
+    }
+
+    return 0;
+
+}
+
+/******************************************************************************
+* function:
+*         qat_contig_mem_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+*
+* @param file [IN] - unused
+* @param cmd  [IN] - ioctl number requested
+* @param arg  [IN] - any arg needed by the ioctl implementation
+*
+* description:
+*   Parameter-check the ioctl call before calling do_ioctl() to do the actual
+*   work.
+*
+* @see do_ioctl()
+*
+******************************************************************************/
+static long
+qat_contig_mem_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+    qat_contig_mem_config mem;
+
+    if (_IOC_SIZE(cmd) != sizeof(mem)) {
+        printk("%s: invalid parameter length\n", __func__);
+        return -EINVAL;
+    }
+    if (copy_from_user(&mem, (unsigned char *)arg, sizeof(mem))) {
+        printk("%s: copy_from_user failed\n", __func__);
+        return -EFAULT;
+    }
+
+    return do_ioctl(&mem, cmd, arg);
+}
+
+/******************************************************************************
+* function:
+*         qat_contig_mem_mmap(struct file *filp, struct vm_area_struct *vma)
+*
+* @param filp [IN]    - unused
+* @param vma  [INOUT] - struct containing details of the requested mmap, and
+*                       also the resulting offset
+*
+* description:
+*   Callback for mmap operations on the device node. This is identical to the
+*   /dev/kmem device on some Linux distros, but others have removed this for
+*   security reasons so we have to re-implement it.
+*
+******************************************************************************/
+static int qat_contig_mem_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+    int ret = 0;
+    unsigned long pfn;
+    unsigned long offset = 0;
+    unsigned long mmap_size = 0;
+    /*
+     * Convert the vm_pgoff page frame number to an address, then a physical
+     * address, then convert it back to a page frame number. The final result
+     * of this is to ensure that pfn is a _physical_ page frame number
+     */
+    pfn = __pa((u64)vma->vm_pgoff << PAGE_SHIFT) >> PAGE_SHIFT;
+    if (!pfn_valid(pfn)) {
+        printk("%s: invalid pfn\n", __func__);
+        return -EIO;
+    }
+    vma->vm_pgoff = pfn;
+    mmap_size = vma->vm_end - vma->vm_start;
+    if (mmap_size > PAGE_SIZE) {
+       /* The amount of memory that is passed in to mmap should be
+          twice the amount that has been actually allocated. This
+          gives us a virtual address space twice the size of the
+          allocation. That then allows us to adjust the address
+          we are going to map at so that we can align the slabs
+          start address to be on a multiple of the slab size.
+          Later when doing V2P lookups this allows us to find
+          the slab header from any address by just doing simple
+          maths (based on the fact we know the slab size we are
+          using). For allocations that result in only 1 page of 
+          virtual address space there is no need to adjust the
+          mapping as it will already be aligned on a page
+          boundary. */
+       offset = vma->vm_end % (mmap_size/2);
+       vma->vm_end = vma->vm_end - offset;
+       vma->vm_start = vma->vm_start + (mmap_size/2) - offset;
+    }
+    ret = remap_pfn_range(vma,
+                          vma->vm_start,
+                          vma->vm_pgoff,
+                          vma->vm_end-vma->vm_start, 
+                          vma->vm_page_prot);
+    if (ret != 0) {
+        printk("%s: remap_pfn_range failed, returned %d\n", __func__, ret);
+    }
+    return ret;
+}
+
+/*
+ * structure describing device function mappings
+ */
+static struct file_operations mem_ops = {
+ owner:THIS_MODULE,
+ mmap:qat_contig_mem_mmap,
+ read:qat_contig_mem_read,
+ write:qat_contig_mem_write,
+ unlocked_ioctl:qat_contig_mem_ioctl,
+ open:qat_contig_mem_open,
+ release:qat_contig_mem_release,
+};
+
+/*
+ * instantiation of the driver
+ */
+static chr_drv_info_t mem_drv_info = {
+ owner:THIS_MODULE,
+ major:DEV_MEM_MAJOR,
+ min_minor:DEV_MEM_BASE_MINOR,
+ max_minor:DEV_MEM_MAX_MINOR,
+ name:DEV_MEM_NAME,
+ file_ops:&mem_ops,
+};
+
+/*
+ * create the device driver class
+ */
+static int chr_drv_create_class(chr_drv_info_t * drv_info)
+{
+    if (NULL == drv_info) {
+        printk("chr_drv_create_class(): parameter is NULL\n");
+        return FAIL;
+    }
+
+    drv_info->drv_class = class_create(THIS_MODULE, drv_info->name);
+    if (IS_ERR(drv_info->drv_class)) {
+        printk("class_create failed\n");
+        return FAIL;
+    }
+    return SUCCESS;
+}
+
+/*
+ * destroy the device driver class
+ */
+static void chr_drv_destroy_class(chr_drv_info_t * drv_info)
+{
+    if (NULL == drv_info) {
+        printk("chr_drv_destroy_class(): parameter is NULL\n");
+        return;
+    }
+    class_destroy(drv_info->drv_class);
+}
+
+/*
+ * destroy the device driver
+ */
+static void chr_drv_destroy_device(chr_drv_info_t * drv_info)
+{
+    if (NULL == drv_info) {
+        printk("chr_drv_destroy(): parameter is NULL\n");
+        return;
+    }
+
+    if (NULL != drv_info->drv_class_dev) {
+        device_destroy(drv_info->drv_class, MKDEV(drv_info->major,
+                                                  drv_info->min_minor));
+    }
+    cdev_del(&(drv_info->drv_cdev));
+    unregister_chrdev_region(MKDEV(drv_info->major, drv_info->min_minor),
+                             drv_info->max_minor);
+}
+
+/*
+ * create the device driver
+ */
+static int chr_drv_create_device(chr_drv_info_t * drv_info)
+{
+    int ret = 0;
+    dev_t devid = 0;
+
+    if (NULL == drv_info) {
+        printk("chr_drv_create_device(): parameter is NULL\n");
+        return FAIL;
+    }
+
+    ret = alloc_chrdev_region(&devid,
+                              drv_info->min_minor,
+                              drv_info->max_minor, drv_info->name);
+
+    if (ret < 0) {
+        printk("%s:%d unable to allocate chrdev region\n", __func__,
+               __LINE__);
+        return FAIL;
+    }
+
+    drv_info->major = MAJOR(devid);
+    cdev_init(&(drv_info->drv_cdev), drv_info->file_ops);
+    drv_info->drv_cdev.owner = drv_info->owner;
+
+    ret = cdev_add(&(drv_info->drv_cdev), devid, drv_info->max_minor);
+    if (ret < 0) {
+        printk("%s:%d cdev add failed\n", __func__, __LINE__);
+        chr_drv_destroy_device(drv_info);
+        return FAIL;
+    }
+
+    drv_info->drv_class_dev = device_create(drv_info->drv_class,
+                                            NULL, MKDEV(drv_info->major,
+                                                        drv_info->min_minor),
+                                            NULL, drv_info->name);
+
+    if (NULL == drv_info->drv_class_dev) {
+        printk("%s:%d chr_drv_create_device: device_create failed\n",
+               __func__, __LINE__);
+        chr_drv_destroy_device(drv_info);
+        return FAIL;
+    }
+    return SUCCESS;
+}
+
+/*
+ * register the device driver
+ */
+int register_mem_device_driver(void)
+{
+    int ret = 0;
+
+    ret = chr_drv_create_class(&mem_drv_info);
+    if (SUCCESS != ret) {
+        printk("%s:%d failed to create device driver class\n",
+               __func__, __LINE__);
+        return FAIL;
+    }
+    ret = chr_drv_create_device(&mem_drv_info);
+    if (SUCCESS != ret) {
+        printk("%s:%d failed to create mem numa device driver\n",
+               __func__, __LINE__);
+        chr_drv_destroy_class(&mem_drv_info);
+        return FAIL;
+    }
+    return SUCCESS;
+}
+
+/*
+ * unregister the device driver
+ */
+
+void unregister_mem_device_driver(void)
+{
+    chr_drv_destroy_device(&mem_drv_info);
+    chr_drv_destroy_class(&mem_drv_info);
+}
+
+/******************************************************************************
+* function:
+*         bytesToPageOrder(long int memSize)
+*
+* @param memSize [IN] - number of bytes requested
+*
+* description:
+*   Return the ln2 of the number of pages needed to store memSize bytes.
+*
+******************************************************************************/
+static unsigned long bytesToPageOrder(long int memSize)
+{
+    if (memSize <= PAGE_SIZE)
+        return 0;
+    else if (memSize <= PAGE_SIZE * 1 << 1)
+        return 1;
+    else if (memSize <= PAGE_SIZE * 1 << 2)
+        return 2;
+    else if (memSize <= PAGE_SIZE * 1 << 3)
+        return 3;
+    else if (memSize <= PAGE_SIZE * 1 << 4)
+        return 4;
+    else if (memSize <= PAGE_SIZE * 1 << 5)
+        return 5;
+    else
+        return -1;
+}
+
+/*
+ * Initialization function to insmod device driver
+ */
+int qat_contig_mem_init(void)
+{
+
+    printk("Loading QAT CONTIG MEM Module ...\n");
+    if (SUCCESS != register_mem_device_driver()) {
+        printk("Error loading QAT CONTIG MEM Module\n");
+        return FAIL;
+    }
+    return SUCCESS;
+}
+
+/*
+ * tear down function to rmmod device driver
+ */
+void qat_contig_mem_exit(void)
+{
+    printk("Unloading QAT CONTIG MEM Module ...\n");
+    unregister_mem_device_driver();
+}
+
+module_init(qat_contig_mem_init);
+module_exit(qat_contig_mem_exit);
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("QAT Contig Mem");
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/qat_contig_mem/qat_contig_mem.h ./contrib/qat/qat_contig_mem/qat_contig_mem.h
--- ../zlib-1.2.8/contrib/qat/qat_contig_mem/qat_contig_mem.h	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/qat_contig_mem/qat_contig_mem.h	2016-09-06 13:13:26.536254000 +0100
@@ -0,0 +1,84 @@
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007-2012 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+#ifndef __QAT_CONTIG_MEM_H
+# define __QAT_CONTIG_MEM_H
+
+# include <asm/ioctl.h>
+
+# ifndef __KERNEL__
+#  include <stdint.h>
+# endif
+
+typedef struct _qat_contig_mem_config {
+    uint32_t signature;
+    uintptr_t virtualAddress;
+    int length;
+    uintptr_t physicalAddress;
+} qat_contig_mem_config;
+
+# define QAT_CONTIG_MEM_MAGIC    0x95
+# define QAT_CONTIG_MEM_ALLOC_SIG 0xDEADBEEF
+# define QAT_CONTIG_MEM_MMAP_ADJUSTMENT 2
+# define QAT_CONTIG_MEM_MALLOC  _IOWR(QAT_CONTIG_MEM_MAGIC, 0, qat_contig_mem_config)
+# define QAT_CONTIG_MEM_FREE    _IOW(QAT_CONTIG_MEM_MAGIC, 2, qat_contig_mem_config)
+
+#endif
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/qat_contig_mem/qat_contig_mem_test.c ./contrib/qat/qat_contig_mem/qat_contig_mem_test.c
--- ../zlib-1.2.8/contrib/qat/qat_contig_mem/qat_contig_mem_test.c	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/qat_contig_mem/qat_contig_mem_test.c	2016-09-06 13:13:26.537254000 +0100
@@ -0,0 +1,123 @@
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012,2013,2014 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012,2013,2014 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+#define _XOPEN_SOURCE 600
+
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <string.h>
+#include "qat_contig_mem.h"
+
+#define SEG_LEN 64
+
+/******************************************************************************
+* function:
+*         main(void)
+*
+* description:
+*   Entry point.
+*
+******************************************************************************/
+int main(void)
+{
+    int qat_contig_memfd = -1;
+    qat_contig_mem_config qmcfg;
+    void *addr = MAP_FAILED;
+    qat_contig_mem_config *mem_to_free = NULL;
+
+    if ((qat_contig_memfd = open("/dev/qat_contig_mem", O_RDWR)) == -1) {
+        perror("open qat_contig_mem");
+        goto cleanup;
+    }
+    qmcfg.length = SEG_LEN;
+    if (ioctl(qat_contig_memfd, QAT_CONTIG_MEM_MALLOC, &qmcfg) == -1) {
+        perror("ioctl QAT_CONTIG_MEM_MALLOC");
+        goto cleanup;
+    }
+
+    if ((addr =
+         mmap(NULL, SEG_LEN*QAT_CONTIG_MEM_MMAP_ADJUSTMENT, 
+              PROT_READ | PROT_WRITE, MAP_PRIVATE, qat_contig_memfd,
+              qmcfg.virtualAddress)) == MAP_FAILED) {
+        perror("mmap");
+        goto cleanup;
+    }
+    mem_to_free = addr;
+    printf("seg mapped to %p, virtualAddress in seg %p, length %d\n", addr,
+           (void *)mem_to_free->virtualAddress, mem_to_free->length);
+    strcpy(addr + sizeof(qat_contig_mem_config), "Hello World!");
+    puts(addr + sizeof(qat_contig_mem_config));
+ cleanup:
+    if (qat_contig_memfd != -1 && mem_to_free != NULL
+        && ioctl(qat_contig_memfd, QAT_CONTIG_MEM_FREE, mem_to_free) == -1)
+        perror("ioctl QAT_CONTIG_MEM_FREE");
+    if (addr != MAP_FAILED && munmap(addr, SEG_LEN) == -1)
+        perror("munmap");
+    if (qat_contig_memfd != -1 && close(qat_contig_memfd) == -1)
+        perror("close qat_contig_mem");
+    exit(EXIT_SUCCESS);
+}
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/qat_zlib_test/LICENSE.GPL ./contrib/qat/qat_zlib_test/LICENSE.GPL
--- ../zlib-1.2.8/contrib/qat/qat_zlib_test/LICENSE.GPL	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/qat_zlib_test/LICENSE.GPL	2016-09-06 13:13:26.538257000 +0100
@@ -0,0 +1,339 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/qat_zlib_test/main.c ./contrib/qat/qat_zlib_test/main.c
--- ../zlib-1.2.8/contrib/qat/qat_zlib_test/main.c	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/qat_zlib_test/main.c	2016-09-12 08:22:02.949601000 +0100
@@ -0,0 +1,1165 @@
+
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012,2013 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012,2013 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+
+/* macros defined to allow use of the cpu get and set affinity functions */
+#define _GNU_SOURCE
+#define __USE_GNU
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <string.h>
+#include <sched.h>
+#include <sys/time.h>
+#include <unistd.h>
+
+
+#include "cpa.h"
+#include "test_parameters.h"
+#include "tests.h"
+#include "zlib.h"
+
+#define DEFAULT_CHUNK_SIZE 8096
+#define DEFAULT_COMPRESSION_LEVEL -1
+#define DEFAULT_THREAD_COUNT 1
+#define DEFAULT_CORE_COUNT 1
+#define DEFAULT_TEST_COUNT 1
+#define CPU_STATUS_LINE_LENGTH 1024
+#define TAG_LENGTH 10
+#define CPU_TIME_MULTIPLIER 10000
+#define CPU_PERCENTAGE_MULTIPLIER 100
+
+static pthread_cond_t ready_cond;
+static pthread_cond_t startupfinished_cond;
+static pthread_cond_t start_cond;
+static pthread_cond_t stop_cond;
+static pthread_cond_t end_cond;
+static pthread_mutex_t mutex;
+static int cleared_to_start;
+static int active_thread_count;
+static int stop_thread_count;
+static int ready_thread_count;
+static int startupfinished_thread_count;
+
+/* thread_count - number of threads to create */
+static int thread_count = DEFAULT_THREAD_COUNT;
+
+/* define the initial test values */
+static int core_count = DEFAULT_CORE_COUNT;
+static int enable_compression_engine = 1;
+static int enable_decompression_engine = 1;
+static int test_count = DEFAULT_TEST_COUNT;
+static int actual_test_count = 0;
+static int test_size = 0;
+static int cpu_affinity = 0;
+static int test_type = 0;
+static int cpu_core_info = 0;
+extern int qatPerformOpRetries;
+static char *FileNameOrPath;
+static int filenamePathSet = 0;
+static int compression_level = DEFAULT_COMPRESSION_LEVEL;
+static int chunk_size = DEFAULT_CHUNK_SIZE;
+static int corpus = CALGARY_CORPUS;
+static int enable_deflate_buffering = 1;
+static int enable_inflate_buffering = 1;
+static int stream_type = GZIP_DEFLATE_STREAM;
+static int window_size = WINDOW_SIZE_32K;
+static int allow_partial_chunks = 0;
+static int verify = 0;
+static float ratio = 0;
+static int failure_occured = 0;
+static long polling_interval = Z_QAT_DEFAULT_POLLING_INTERVAL;
+
+/* Thread_info structure declaration */
+typedef struct
+{
+    pthread_t th;
+    int id;
+    int count;
+}
+THREAD_INFO;
+
+#define MAX_STAT 10
+#define MAX_CORE 32
+typedef union
+{
+    struct
+    {
+        int user;
+        int nice;
+        int sys;
+        int idle;
+        int io;
+        int irq;
+        int softirq;
+        int context;
+    };
+    int d[MAX_STAT];
+}
+cpu_time_t;
+
+static cpu_time_t cpu_time[MAX_CORE];
+static cpu_time_t cpu_time_total;
+static cpu_time_t cpu_context;
+
+#define MAX_THREAD 1024
+
+THREAD_INFO tinfo[MAX_THREAD];
+
+/******************************************************************************
+* function:
+*	 cpu_time_add (cpu_time_t *t1, cpu_time_t *t2, int subtract)
+*
+* @param t1 [IN] - cpu time
+* @param t2 [IN] - cpu time
+* @param substract [IN] - subtract flag
+*
+* description:
+*   CPU timing calculation functions.
+******************************************************************************/
+static void cpu_time_add (cpu_time_t *t1, cpu_time_t *t2, int subtract)
+{
+    int i;
+
+    for (i = 0; i < MAX_STAT; i++)
+    {
+        if (subtract)
+            t1->d[i] -= t2->d[i];
+        else
+            t1->d[i] += t2->d[i];
+    }
+}
+
+
+/******************************************************************************
+* function:
+*	read_stat (int init)
+*
+* @param init [IN] - op flag
+*
+* description:
+*  read in CPU status from proc/stat file
+******************************************************************************/
+static void read_stat (int init)
+{
+    char line[CPU_STATUS_LINE_LENGTH];
+    char tag[TAG_LENGTH];
+    FILE *fp;
+    int index = 0;
+    int i;
+    cpu_time_t tmp;
+
+    fp = fopen ("/proc/stat", "r");
+    if (NULL == fp)
+    {
+        fprintf (stderr, "Can't open proc stat\n");
+        exit (1);
+    }
+
+    while (!feof (fp))
+    {
+        if (fgets (line, sizeof line - 1, fp) == NULL)
+            break;
+
+        if (!strncmp (line, "ctxt", 4))
+        {
+            if (sscanf (line, "%*s %d", &tmp.context) < 1)
+                goto parse_fail;
+
+            cpu_time_add (&cpu_context, &tmp, init);
+            continue;
+        }
+
+        if (strncmp (line, "cpu", 3))
+            continue;
+
+        if (sscanf (line, "%s %d %d %d %d %d %d %d",
+                tag,
+                &tmp.user,
+                &tmp.nice,
+                &tmp.sys,
+                &tmp.idle,
+                &tmp.io,
+                &tmp.irq,
+                &tmp.softirq) < 8)
+        {
+            goto parse_fail;
+        }
+
+        if (!strcmp (tag, "cpu"))
+            cpu_time_add (&cpu_time_total, &tmp, init);
+        else if (!strncmp (tag, "cpu", 3))
+        {
+            index = atoi (&tag[3]);
+            if ((0 <= index) && (MAX_CORE >= index)) 
+                cpu_time_add (&cpu_time[index], &tmp, init);
+        }
+    }
+
+    if (!init && cpu_core_info)
+    {
+        printf ("      %10s %10s %10s %10s %10s %10s %10s\n",
+                "user", "nice", "sys", "idle", "io", "irq", "sirq");
+        for (i = 0; i < MAX_CORE + 1; i++)
+        {
+            cpu_time_t *t;
+
+            if (i == MAX_CORE)
+            {
+                printf ("total ");
+                t = &cpu_time_total;
+            }
+            else
+            {
+                printf ("cpu%d  ", i);
+                t = &cpu_time[i];
+            }
+
+            printf (" %10d %10d %10d %10d %10d %10d %10d\n",
+                    t->user,
+                    t->nice,
+                    t->sys,
+                    t->idle,
+                    t->io,
+                    t->irq,
+                    t->softirq);
+        }
+
+        printf ("Context switches: %d\n", cpu_context.context);
+    }
+
+    fclose (fp);
+    return;
+
+parse_fail:
+    fprintf (stderr, "Failed to parse %s\n", line);
+    exit (1);
+}
+
+/******************************************************************************
+* function:
+*           *test_name(int test)
+*
+* @param test [IN] - test case
+*
+* description:
+*   test_name selection list
+******************************************************************************/
+static char *test_name(int test)
+{
+    switch (test)
+    {
+        case TEST_CORPUS_COMPRESSION:
+            return "Corpus Compression";
+            break;
+        case TEST_CORPUS_DECOMPRESSION:
+            return "Corpus Decompression";
+            break;
+        case 0:
+            return "invalid";
+            break;
+    }
+    return "*unknown*";
+}
+
+/******************************************************************************
+* function:
+*           *corpus_name(int selectedcorpus)
+*
+* @param selectedcorpus [IN] - corpus number
+*
+* description:
+*   corpus_name maps enum to textual name
+******************************************************************************/
+static char *corpus_name(int selectedcorpus)
+{
+    switch (selectedcorpus)
+    {
+        case CANTERBURY_CORPUS:
+            return "Canterbury Corpus";
+            break;
+        case CALGARY_CORPUS:
+            return "Calgary Corpus";
+            break;
+        case SILESIA_CORPUS:
+            return "Silesia Corpus";
+            break;
+        case CUSTOM_FILE:
+            return "Custom (customfile.bin)";
+            break;
+    }
+    return "*unknown*";
+}
+
+/******************************************************************************
+* function:
+*           *streamtype_name(int selectedstreamtype)
+*
+* @param selectedstreamtype [IN] - number representing the type of stream.
+*
+* description:
+*   streamtype_name maps enum to textual name
+******************************************************************************/
+static char *streamtype_name(int selectedstreamtype)
+{
+    switch (selectedstreamtype)
+    {
+        case RAW_DEFLATE_STREAM:
+            return "Raw Deflate Stream";
+            break;
+        case ZLIB_DEFLATE_STREAM:
+            return "Zlib Format Deflate Stream";
+            break;
+        case GZIP_DEFLATE_STREAM:
+            return "Gzip Format Deflate Stream";
+            break;
+    }
+    return "*unknown*";
+}
+
+/******************************************************************************
+* function:
+*           *windowsize_name(int selectedwindowsize)
+*
+* @param selectedwindowsize [IN] - number representing the size of deflate
+*                                  window.
+*
+* description:
+*   windowsize_name maps enum to textual name
+******************************************************************************/
+static char *windowsize_name(int selectedwindowsize)
+{
+    switch (selectedwindowsize)
+    {
+        case WINDOW_SIZE_8K:
+            return "8KB Deflate Window Size (DH89XXCC and DH895XCC only)";
+            break;
+        case WINDOW_SIZE_16K:
+            return "16K Deflate Window Size(c6xx and c3xxx only)";
+            break;
+        case WINDOW_SIZE_32K:
+            return "32KB Deflate Window Size";
+            break;
+    }
+    return "*unknown*";
+}
+
+/******************************************************************************
+* function:
+*           usage(char *program)
+*
+*
+* @param program [IN] - input argument
+*
+* description:
+*   test application usage help
+******************************************************************************/
+static void usage(char *program)
+{
+    int i;
+
+    printf("\nUsage:\n");
+    printf("\t%s [-t <type>] [-c <count>] [-n <count>] [-nc <count>]"
+           " [-k <size>] [-o <corpus>] [-u]"
+           " [-af] [-dc] [-dd] [-f <filepath>] [-l <compressionlevel>]"
+           " [-ddb] [-dib] [-s <streamtype>]"
+           " [-w <windowsize>] [-pc] [-pi <interval>] [-v] [-h]\n", program);
+    printf("Where:\n");
+    printf("\t-t   specifies the test type to run (see below)\n");
+    printf("\t-c   specifies the test iteration count\n");
+    printf("\t-n   specifies the number of threads to run\n");
+    printf("\t-nc  specifies the number of CPU cores\n");
+    printf("\t-k   specifies the chunk size in bytes\n");
+    printf("\t-o   specifies the corpus to use for the tests (see below)\n");
+    printf("\t-u   display cpu usage per core\n");
+    printf("\t-af  enables core affinity\n");
+    printf("\t-dc  disables the QAT Engine for Compression\n");
+    printf("\t-dd  disables the QAT Engine for Decompression\n");
+    printf("\t-f   specifies the filepath for a corpus test\n");
+    printf("\t-l   specifies the compression level\n");
+    printf("\t-ddb disables internal buffering for shim deflate\n");
+    printf("\t-dib disables internal buffering for shim inflate\n");
+    printf("\t-s   specifies the type of deflate stream (see below)\n");
+    printf("\t-w   specifies the deflate window size (see below)\n");
+    printf("\t-pc  allow partial chunks\n");
+    printf("\t-pi  specifies the polling interval in nanoseconds\n");
+    printf("\t-v   enable verification of data (use with -c 1)\n");
+    printf("\t-h   print this usage\n");
+    printf("\nand where the -t test type is:\n\n");
+
+    for (i = 1; i <= TEST_TYPE_MAX; i++)
+        printf("\t%-2d = %s\n", i, test_name(i));
+
+    printf("\nand where the -o corpus is:\n\n");
+    for (i = 0; i <= CORPUS_MAX; i++)
+        printf("\t%-2d = %s\n", i, corpus_name(i));
+
+    printf("\nand where the -s streamtype is:\n\n");
+    for (i = 0; i <= STREAMTYPE_MAX; i++)
+        printf("\t%-2d = %s\n", i, streamtype_name(i));
+
+    printf("\nand where the -w windowsize is:\n\n");
+    printf("\t%-2d = %s\n", WINDOW_SIZE_8K, windowsize_name(WINDOW_SIZE_8K));
+    printf("\t%-2d = %s\n", WINDOW_SIZE_16K, windowsize_name(WINDOW_SIZE_16K));
+    printf("\t%-2d = %s\n", WINDOW_SIZE_32K, windowsize_name(WINDOW_SIZE_32K));
+    exit(EXIT_SUCCESS);
+}
+
+/******************************************************************************
+* function:
+*           parse_option(int *index,
+*                        int argc,
+*                       char *argv[],
+*                        int *value)
+*
+* @param index [IN] - index pointer
+* @param argc [IN] - input argument count
+* @param argv [IN] - argument buffer
+* @param value [IN] - input value pointer
+*
+* description:
+*   user input arguments check
+******************************************************************************/
+static void parse_option(int *index, int argc, char *argv[], int *value)
+{
+    if (*index + 1 >= argc)
+    {
+        fprintf(stderr, "\nParameter expected\n");
+        usage(argv[0]);
+        exit(EXIT_FAILURE);
+    }
+
+    (*index)++;
+
+    *value = atoi(argv[*index]);
+}
+
+/******************************************************************************
+* function:
+*           parse_option_long(int *index,
+*                        int argc,
+*                       char *argv[],
+*                        long *value)
+*
+* @param index [IN] - index pointer
+* @param argc [IN] - input argument count
+* @param argv [IN] - argument buffer
+* @param value [IN] - input value pointer
+*
+* description:
+*   user input arguments check
+******************************************************************************/
+static void parse_option_long(int *index, int argc, char *argv[], long *value)
+{
+    if (*index + 1 >= argc)
+    {
+        fprintf(stderr, "\nParameter expected\n");
+        usage(argv[0]);
+        exit(EXIT_FAILURE);
+    }
+
+    (*index)++;
+
+    *value = atol(argv[*index]);
+}
+
+/******************************************************************************
+* function:
+*           handle_option(int argc,
+*                         char *argv[],
+*                         int *index)
+*
+* @param argc [IN] - input argument count
+* @param argv [IN] - argument buffer
+* @param index [IN] - index pointer
+*
+* description:
+*   input operation handler
+******************************************************************************/
+static void handle_option(int argc, char *argv[], int *index)
+{
+    char *option = argv[*index];
+
+    if (!strcmp(option, "-n")) {
+        parse_option(index, argc, argv, &thread_count);
+        if (thread_count > MAX_THREAD) {
+            fprintf(stderr, "Error: Exceeded maximum number of threads\n");
+            exit(EXIT_FAILURE);
+        }
+    }
+    else if (!strcmp(option, "-t"))
+        parse_option(index, argc, argv, &test_type);
+    else if (!strcmp(option, "-c"))
+        parse_option(index, argc, argv, &test_count);
+    else if (!strcmp(option, "-af"))
+        cpu_affinity = 1;
+    else if (!strcmp(option, "-nc"))
+        parse_option(index, argc, argv, &core_count);
+    else if (!strcmp(option, "-f"))
+    {
+        if (*index + 1 >= argc)
+        {
+            fprintf(stderr, "\nParameter expected\n");
+            usage(argv[0]);
+            exit(EXIT_FAILURE);
+        }
+
+        (*index)++;
+
+        FileNameOrPath = argv[*index];
+		filenamePathSet = 1;
+    }
+    else if (!strcmp(option, "-dc"))
+    {
+		enable_compression_engine = 0;
+		printf("QAT Compression Engine disabled ! \n");
+    }
+    else if (!strcmp(option, "-dd"))
+    {
+		enable_decompression_engine = 0;
+		printf("QAT Decompression Engine disabled ! \n");
+    }
+    else if (!strcmp(option, "-ddb"))
+    {
+		enable_deflate_buffering = 0;
+		printf("Buffering within shim on deflate side disabled !\n");
+    }
+    else if (!strcmp(option, "-dib"))
+    {
+		enable_inflate_buffering = 0;
+		printf("Buffering within shim on inflate side disabled !\n");
+    }
+	else if (!strcmp(option, "-l"))
+        parse_option(index, argc, argv, &compression_level);
+    else if (!strcmp(option, "-k"))
+        parse_option(index, argc, argv, &chunk_size);
+    else if (!strcmp(option, "-o"))
+        parse_option(index, argc, argv, &corpus);
+    else if (!strcmp(option, "-s"))
+        parse_option(index, argc, argv, &stream_type);
+    else if (!strcmp(option, "-w")) {
+        parse_option(index, argc, argv, &window_size);
+        if ((WINDOW_SIZE_8K != window_size) && 
+            (WINDOW_SIZE_16K != window_size) && 
+            (WINDOW_SIZE_32K != window_size)) {
+            fprintf(stderr, "Error: Invalid Window Size\n");
+            exit(EXIT_FAILURE);
+        }
+    }
+    else if (!strcmp(option, "-pc"))
+    {
+                allow_partial_chunks = 1;
+    }
+    else if (!strcmp(option, "-pi"))
+        parse_option_long(index, argc, argv, &polling_interval);
+    else if (!strcmp(option, "-u"))
+        cpu_core_info = 1;
+    else if (!strcmp(option, "-v"))
+        verify = 1;
+    else if (!strcmp(option, "-h"))
+        usage(argv[0]);
+    else
+    {
+        fprintf(stderr, "\nInvalid option '%s'\n", option);
+        usage(argv[0]);
+        exit(EXIT_FAILURE);
+    }
+}
+
+/******************************************************************************
+* function:
+*           *thread_worker(void *arg)
+*
+* @param arg [IN] - thread structure info
+*
+* description:
+*   thread worker setups. the threads will launch at the same time after
+*   all of them in ready condition.
+******************************************************************************/
+static void *thread_worker(void *arg)
+{
+    THREAD_INFO *info = (THREAD_INFO *) arg;
+    int rc1, rc2, rc3, rc4;
+    int abort=0;
+    test_parameters_t test_parameters;
+    test_parameters.count = info->count;
+    test_parameters.type = test_type;
+    test_parameters.id = info->id;
+    test_parameters.level = compression_level;
+    test_parameters.enable_deflate_buffering = enable_deflate_buffering;
+    test_parameters.enable_inflate_buffering = enable_inflate_buffering;
+    test_parameters.streamtype = stream_type;
+    test_parameters.windowsize = window_size;
+    test_parameters.verify = verify;
+    test_parameters.chunksize = chunk_size;
+    test_parameters.corpus = corpus;
+    test_parameters.allow_partial_chunks = allow_partial_chunks;
+    test_parameters.verify_checksum = 0;
+	
+    if (filenamePathSet)
+    {
+        test_parameters.file_path = FileNameOrPath;
+    }
+    else
+    {
+        test_parameters.file_path = "\0";
+    }
+
+    /* mutex lock for thread count */
+    rc1 = pthread_mutex_lock(&mutex);
+    ready_thread_count++;
+    rc2 = pthread_cond_broadcast(&ready_cond);
+    rc3 = pthread_mutex_unlock(&mutex);
+
+    rc4 = tests_startup(&test_parameters);
+    if ((rc1 != 0) || (rc2 != 0) || (rc3 != 0) || (rc4 != TEST_PASSED))
+    {
+        failure_occured=1;
+        abort=1;
+    }
+
+    /* mutex lock for thread count */
+    rc1 = pthread_mutex_lock(&mutex);
+    startupfinished_thread_count++;
+    rc2 = pthread_cond_broadcast(&startupfinished_cond);
+    rc3 = pthread_mutex_unlock(&mutex);
+    if ((rc1 != 0) || (rc2 != 0) || (rc3 != 0))
+    {
+        failure_occured=1;
+        abort=1;
+    }
+
+    /* waiting for thread clearance */
+    rc1 = pthread_mutex_lock(&mutex);
+    if (rc1 != 0) {
+        failure_occured=1;
+        abort=1;
+    }
+	
+
+    while (!cleared_to_start) {
+        rc2 = pthread_cond_wait(&start_cond, &mutex);
+        if (rc2 != 0) {
+            failure_occured=1;
+            abort=1;
+        }
+    }
+
+    rc3 = pthread_mutex_unlock(&mutex);
+    if (rc3 != 0) {
+        failure_occured=1;
+        abort=1;
+    }
+
+    if (!abort)
+    {
+        rc1 = tests_run(&test_parameters);
+        if (rc1 != TEST_PASSED)
+            failure_occured=1;
+        test_size=test_parameters.single_call_bytes;
+        ratio=test_parameters.ratio;
+    }
+    /* update active threads */
+    rc1 = pthread_mutex_lock(&mutex);
+    active_thread_count--;
+    rc2 = pthread_cond_broadcast(&stop_cond);
+    rc3 = pthread_mutex_unlock(&mutex);
+	
+    rc4 = tests_shutdown(&test_parameters);
+    if ((rc1 != 0) || (rc2 != 0) || (rc3 != 0) || (rc4 != TEST_PASSED))
+        failure_occured=1;
+    
+    rc1 = pthread_mutex_lock(&mutex);
+    stop_thread_count--;
+    rc2 = pthread_cond_broadcast(&end_cond);
+    rc3 = pthread_mutex_unlock(&mutex);
+    /* set a failure but maybe too late by now */
+    if ((rc1 != 0) || (rc2 != 0) || (rc3 != 0)) 
+        failure_occured=1;
+ 
+
+
+    return NULL;
+}
+
+/******************************************************************************
+* function:
+*           performance_test(void)
+*
+* description:
+*   performers test application running on user definition .
+******************************************************************************/
+static void performance_test(void)
+{
+    int i;
+    int coreID = 0;
+    int rc = 0;
+    int sts = 1;
+    cpu_set_t cpuset;
+    struct timeval start_time;
+    struct timeval stop_time;
+    unsigned long elapsed = 0;
+    unsigned long long rdtsc_start = 0;
+    unsigned long long rdtsc_end = 0;
+    int bytes_to_bits = 8;
+    float throughput = 0.0;
+
+    rc = pthread_mutex_init(&mutex, NULL);
+    if (rc != 0) { 
+        fprintf(stderr, "Failure to init Mutex, status = %d\n", rc);
+        exit(EXIT_FAILURE);
+    }
+    rc = pthread_cond_init(&ready_cond, NULL);
+    if (rc != 0) { 
+        fprintf(stderr, "Failed call to pthread_cond_init, status = %d\n", rc);
+        exit(EXIT_FAILURE);
+    }
+    rc = pthread_cond_init(&startupfinished_cond, NULL);
+    if (rc != 0) { 
+        fprintf(stderr, "Failed call to pthread_cond_init, status = %d\n", rc);
+        exit(EXIT_FAILURE);
+    }
+    rc = pthread_cond_init(&start_cond, NULL);
+    if (rc != 0) { 
+        fprintf(stderr, "Failed call to pthread_cond_init, status = %d\n", rc);
+        exit(EXIT_FAILURE);
+    }
+    rc = pthread_cond_init(&stop_cond, NULL);
+    if (rc != 0) { 
+        fprintf(stderr, "Failed call to pthread_cond_init, status = %d\n", rc);
+        exit(EXIT_FAILURE);
+    }
+    rc = pthread_cond_init(&end_cond, NULL);
+    if (rc != 0) { 
+        fprintf(stderr, "Failed call to pthread_cond_init, status = %d\n", rc);
+        exit(EXIT_FAILURE);
+    }
+    actual_test_count = test_count / thread_count;
+    actual_test_count = actual_test_count * thread_count; 
+
+    for (i = 0; i < thread_count; i++)
+    {
+        THREAD_INFO *info = &tinfo[i];
+
+        info->id = i;
+        info->count = test_count / thread_count;
+        if (info->count == 0)
+        {
+            fprintf(stderr, "Error: count set incorrectly resulting in 0 iterations per thread\n");
+            exit(EXIT_FAILURE);
+        }
+
+        rc = pthread_create(&info->th, NULL, thread_worker, (void *)info);
+        if (rc != 0) { 
+            fprintf(stderr, "Failure to create thread, status = %d\n", rc);
+            exit(EXIT_FAILURE);
+        }
+
+        /* cpu affinity setup */
+        if (cpu_affinity == 1)
+        {
+            CPU_ZERO(&cpuset);
+
+            /* assigning thread to different cores */
+            coreID = (i % core_count);
+            CPU_SET(coreID, &cpuset);
+
+            sts = pthread_setaffinity_np(info->th, sizeof(cpu_set_t), &cpuset);
+            if (sts != 0)
+            {
+                fprintf(stderr, "pthread_setaffinity_np error, status = %d \n", sts);
+                exit(EXIT_FAILURE);
+            }
+            sts = pthread_getaffinity_np(info->th, sizeof(cpu_set_t), &cpuset);
+            if (sts != 0)
+            {
+                fprintf(stderr, "pthread_getaffinity_np error, status = %d \n", sts);
+                exit(EXIT_FAILURE);
+            }
+
+            if (CPU_ISSET(coreID, &cpuset))
+                printf("Thread %d assigned on CPU core %d\n", i, coreID);
+        }
+    }
+
+    /* set all threads to ready condition */
+    rc = pthread_mutex_lock(&mutex);
+    if (rc != 0) { 
+        fprintf(stderr, "Failure to get Mutex Lock, status = %d\n", rc);
+        exit(EXIT_FAILURE);
+    }
+
+    while (ready_thread_count < thread_count)
+    {
+        rc = pthread_cond_wait(&ready_cond, &mutex);
+        if (rc != 0) {
+            fprintf(stderr, "Failure calling pthread_cond_wait, status = %d\n", rc);
+            exit(EXIT_FAILURE);
+        }
+    }
+
+    rc = pthread_mutex_unlock(&mutex);
+    if (rc != 0) { 
+        fprintf(stderr, "Failure to release Mutex Lock, status = %d\n", rc);
+        exit(EXIT_FAILURE);
+    }
+
+    /* set all threads to startup finished condition */
+    rc = pthread_mutex_lock(&mutex);
+    if (rc != 0) { 
+        fprintf(stderr, "Failure to get Mutex Lock, status = %d\n", rc);
+        exit(EXIT_FAILURE);
+    }
+
+    while (startupfinished_thread_count < thread_count)
+    {
+        rc = pthread_cond_wait(&startupfinished_cond, &mutex);
+        if (rc != 0) {
+            fprintf(stderr, "Failure calling pthread_cond_wait, status = %d\n", rc);
+            exit(EXIT_FAILURE);
+        }
+    }
+
+    rc = pthread_mutex_unlock(&mutex);
+    if (rc != 0) { 
+        fprintf(stderr, "Failure to release Mutex Lock, status = %d\n", rc);
+        exit(EXIT_FAILURE);
+    }
+    printf("Beginning test ....\n");
+    /* all threads start at the same time */
+    read_stat (1);
+    gettimeofday(&start_time, NULL);
+    rdtsc_start = rdtsc();
+    rc = pthread_mutex_lock(&mutex);
+    if (rc != 0) { 
+        fprintf(stderr, "Failure to get Mutex Lock, status = %d\n", rc);
+        exit(EXIT_FAILURE);
+    }
+    cleared_to_start = 1;
+    rc = pthread_cond_broadcast(&start_cond);
+    if (rc != 0) { 
+        fprintf(stderr, "Failure calling pthread_cond_broadcast, status = %d\n", rc);
+        exit(EXIT_FAILURE);
+    }
+    rc = pthread_mutex_unlock(&mutex);
+    if (rc != 0) { 
+        fprintf(stderr, "Failure to release Mutex Lock, status = %d\n", rc);
+        exit(EXIT_FAILURE);
+    }
+
+    /* wait for other threads stop */
+    rc = pthread_mutex_lock(&mutex);
+    if (rc != 0) { 
+        fprintf(stderr, "Failure to get Mutex Lock, status = %d\n", rc);
+        exit(EXIT_FAILURE);
+    }
+
+    while (active_thread_count > 0) {
+        rc = pthread_cond_wait(&stop_cond, &mutex);
+        if (rc != 0) {
+            fprintf(stderr, "Failure calling pthread_cond_wait, status = %d\n", rc);
+            exit(EXIT_FAILURE);
+        }
+    }
+
+    rc = pthread_mutex_unlock(&mutex);
+    if (rc != 0) { 
+        fprintf(stderr, "Failure to release Mutex Lock, status = %d\n", rc);
+        exit(EXIT_FAILURE);
+    }
+
+    rdtsc_end = rdtsc();
+    gettimeofday(&stop_time, NULL);
+    read_stat (0);
+   
+    rc = pthread_mutex_lock(&mutex);
+    if (rc != 0) { 
+        fprintf(stderr, "Failure to get Mutex Lock, status = %d\n", rc);
+        exit(EXIT_FAILURE);
+    }
+
+    while (stop_thread_count > 0) {
+        rc = pthread_cond_wait(&end_cond, &mutex);
+        if (rc != 0) {
+            fprintf(stderr, "Failure calling pthread_cond_wait, status = %d\n", rc);
+            exit(EXIT_FAILURE);
+        }
+    }
+
+    rc = pthread_mutex_unlock(&mutex);
+    if (rc != 0) { 
+        fprintf(stderr, "Failure to release Mutex Lock, status = %d\n", rc);
+        exit(EXIT_FAILURE);
+    }
+   
+    for (i = 0; i < thread_count; i++)
+    {
+        if (pthread_join(tinfo[i].th, NULL))
+            printf("Could not join thread id - %d !\n", i);
+    }
+
+   
+    printf("All threads complete\n\n");
+
+    if (failure_occured)
+    {
+        printf("AT LEAST ONE FAILURE OCCURED DURING THE TESTS - DO NOT TRUST THE FIGURES PRODUCED\n");
+    }
+    else
+    {
+       printf("# PASS verify for ZLIB\n");
+    }
+    
+    /* generate report */
+    elapsed = (stop_time.tv_sec - start_time.tv_sec) * 1000000 +
+        (stop_time.tv_usec - start_time.tv_usec);
+
+   
+    /* Cast test_size * test_count to avoid int overflow */
+    throughput = ((float)test_size * (float)actual_test_count *
+                  bytes_to_bits / (float)elapsed);
+
+    printf("Elapsed time   = %.3f msec\n", (float)elapsed / 1000);
+    printf("Operations     = %d\n", actual_test_count);
+
+    printf("Time per op    = %.3f usec (%d ops/sec)\n",
+           (float)elapsed / actual_test_count,
+           (int)((float)test_count * 1000000.0 / (float)elapsed));
+
+    printf("Elapsed cycles = %llu\n", rdtsc_end - rdtsc_start);
+
+    printf("Throughput     = %.2f (Mbps)\n", throughput);
+
+    //printf("Retries        = %d\n", qatPerformOpRetries);
+
+    printf("\nCSV summary:\n");
+
+    printf("Algorithm,"
+           "Test_type,"
+           "Using_engine_compression,"
+           "Using_engine_decompression,"
+           "Deflate_buffering_enabled,"
+           "Inflate_buffering_enabled,"
+           "Compression_Level,"
+           "Chunk_Size,"
+           "Polling_Interval,"
+           "Stream_type,"
+           "Window_size,"
+           "Core_affinity,"
+           "Elapsed_usec,"
+           "Cores,"
+           "Threads,"
+           "Count,"
+           "Data_per_test,"
+           "Mbps,"
+           "CPU_%%,"
+           "User_%%,"
+           "Kernel_%%,"
+           "Ratio,"
+           "Context_switches,"
+           "Cycles\n");
+
+    unsigned long cpu_time = 0;
+    unsigned long cpu_user = 0;
+    unsigned long cpu_kernel = 0;
+
+    cpu_time = (cpu_time_total.user +
+                cpu_time_total.nice +
+                cpu_time_total.sys +
+                cpu_time_total.io +
+                cpu_time_total.irq +
+                cpu_time_total.softirq) * CPU_TIME_MULTIPLIER / core_count;
+    cpu_user = cpu_time_total.user * CPU_TIME_MULTIPLIER / core_count;
+    cpu_kernel = cpu_time_total.sys * CPU_TIME_MULTIPLIER / core_count;
+
+    printf("csv,%s,%d,%s,%s,%s,%s,%d,%d,%ld,%d,%d,%s,%lu,%d,%d,%d,%d,%.2f,%lu,%lu,%lu,%.3f,%d,%llu\n",
+           test_name(test_type),
+           test_type,
+           enable_compression_engine ? "Yes" : "No",
+           enable_decompression_engine ? "Yes" : "No",
+           enable_deflate_buffering ? "Yes" : "No",
+           enable_inflate_buffering ? "Yes" : "No",
+           compression_level,
+           chunk_size,
+           polling_interval,
+           stream_type,
+           window_size,
+           cpu_affinity ? "Yes" : "No",
+           elapsed,
+           core_count, thread_count, actual_test_count, test_size, throughput,
+           cpu_time * CPU_PERCENTAGE_MULTIPLIER / elapsed,
+           cpu_user * CPU_PERCENTAGE_MULTIPLIER / elapsed,
+           cpu_kernel * CPU_PERCENTAGE_MULTIPLIER / elapsed,
+           ratio,
+           cpu_context.context,
+           rdtsc_end-rdtsc_start);
+}
+
+/******************************************************************************
+* function:
+*           functional_test(void)
+*
+* description:
+*    Default testing application, a single thread test running through all the
+*    test cases with testing function definition values
+******************************************************************************/
+static void functional_test(void)
+{
+    printf("\nFunctional tests not currently supported.\n");
+}
+
+
+/******************************************************************************
+* function:
+*           main(int argc,
+*                char *argv[])
+*
+* @param argc [IN] - input argument count
+* @param argv [IN] - argument buffer
+*
+* description:
+*    main function is used to setups QAT engine setups and define the testing type.
+******************************************************************************/
+int main(int argc, char *argv[])
+{
+    int i = 0;
+
+    for (i = 1; i < argc; i++)
+    {
+        if (argv[i][0] != '-')
+            break;
+
+        handle_option(argc, argv, &i);
+    }
+
+    if (i < argc)
+    {
+        fprintf(stderr,
+                "This program does not take arguments, please use -h for usage.\n");
+        exit(EXIT_FAILURE);
+    }
+
+    active_thread_count = thread_count;
+    stop_thread_count = thread_count;
+    ready_thread_count = 0;
+    startupfinished_thread_count = 0;
+
+    if (enable_compression_engine && enable_decompression_engine)
+    {
+        zlibSetupEngine(polling_interval, Z_QAT_DEFAULT_MAX_NUM_RETRIES);
+        zlibStartupEngine(Z_HW_COMP_HW_DECOMP);
+    }
+    
+    if (enable_compression_engine && !enable_decompression_engine)
+    {
+        zlibSetupEngine(polling_interval, Z_QAT_DEFAULT_MAX_NUM_RETRIES);
+        zlibStartupEngine(Z_HW_COMP_SW_DECOMP);
+    }
+
+    if (!enable_compression_engine && enable_decompression_engine)
+    {
+        zlibSetupEngine(polling_interval, Z_QAT_DEFAULT_MAX_NUM_RETRIES);
+        zlibStartupEngine(Z_SW_COMP_HW_DECOMP);
+    }
+
+    if (!enable_compression_engine && !enable_decompression_engine)
+    {
+        zlibStartupEngine(Z_SW_COMP_SW_DECOMP);
+    }
+
+    printf("\nQAT zlib test application\n");
+    printf("\n\tCopyright (C) 2012, 2013 Intel Corporation\n");
+    printf("\nTest parameters:\n\n");
+    printf("\tTest type:                        %d (%s)\n", test_type, test_name(test_type));
+    printf("\tCompression level:                %d\n", compression_level);
+    printf("\tStream type:                      %d (%s)\n", stream_type, streamtype_name(stream_type));
+    printf("\tWindow size:                      %d (%s)\n", window_size, windowsize_name(window_size));
+    printf("\tTest count:                       %d\n", test_count);
+    printf("\tThread count:                     %d\n", thread_count);
+    printf("\tChunk size:                       %d\n", chunk_size);
+    printf("\tCorpus used:                      %d (%s)\n", corpus, corpus_name(corpus));
+    printf("\tQAT Engine Compression enabled:   %s\n", enable_compression_engine ? "Yes" : "No");
+    printf("\tQAT Engine Decompression enabled: %s\n", enable_decompression_engine ? "Yes" : "No");
+    printf("\tBuffering in deflate enabled:     %s\n", enable_deflate_buffering ? "Yes" : "No");
+    printf("\tBuffering in inflate enabled:     %s\n", enable_inflate_buffering ? "Yes" : "No");
+    printf("\tAllow Partial Chunks:             %s\n", allow_partial_chunks ? "Yes" : "No");
+    printf("\tCPU core affinity:                %s\n", cpu_affinity ? "Yes" : "No");
+    printf("\tVerification:                     %s\n", verify ? "Yes" : "No");
+    printf("\tNumber of cores:                  %d\n", core_count);
+    printf("\tPolling Interval:                 %ld\n", polling_interval);
+
+    printf("\n");
+
+    if (test_type == 0)
+    {
+        functional_test();
+    }
+    else
+        performance_test();
+
+    zlibShutdownEngine();
+
+    return 0;
+}
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/qat_zlib_test/Makefile ./contrib/qat/qat_zlib_test/Makefile
--- ../zlib-1.2.8/contrib/qat/qat_zlib_test/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/qat_zlib_test/Makefile	2016-09-12 08:22:03.543608000 +0100
@@ -0,0 +1,136 @@
+#########################################################################
+#
+# @par
+# # This file is provided under a dual BSD/GPLv2 license.  When using or
+#   redistributing this file, you may do so under either license.
+#
+#   GPL LICENSE SUMMARY
+#
+#   Copyright(c) 2007-2013 Intel Corporation. All rights reserved.
+#
+#   This program is free software; you can redistribute it and/or modify
+#   it under the terms of version 2 of the GNU General Public License as
+#   published by the Free Software Foundation.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   General Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License
+#   along with this program; if not, write to the Free Software
+#   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#   The full GNU General Public License is included in this distribution
+#   in the file called LICENSE.GPL.
+#
+#   Contact Information:
+#   Intel Corporation
+#
+#   BSD LICENSE
+#
+#   Copyright(c) 2007,2008,2009,2010,2011,2012,2013 Intel Corporation.
+#   All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or without
+#   modification, are permitted provided that the following conditions
+#   are met:
+#
+#     * Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above copyright
+#       notice, this list of conditions and the following disclaimer in
+#       the documentation and/or other materials provided with the
+#       distribution.
+#     * Neither the name of Intel Corporation nor the names of its
+#       contributors may be used to endorse or promote products derived
+#       from this software without specific prior written permission.
+#
+#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+#
+#########################################################################
+
+ifndef CMN_ROOT
+ZLIB_MEMORY_DRIVER=qat_mem
+else
+ZLIB_MEMORY_DRIVER=usdm_drv
+endif
+
+CFLAGS+= -I${ZLIB_ROOT} \
+-I$(ICP_ROOT)/quickassist/lookaside/access_layer/include \
+-I$(ICP_ROOT)/quickassist/include
+
+CC=gcc
+#COVERAGE=-ggdb3 -pg
+CFLAGS+= $(COVERAGE) -Wall
+
+SRCS=\
+main.c \
+tests.c \
+tests_compression.c \
+tests_decompression.c
+
+OBJS = $(SRCS:%.c=%.o)
+COVERAGE_OBJS =
+EXE=
+LIBQAT=
+UDEV=
+ifdef ICP_BUILD_OUTPUT
+    LIBQAT+= -Wl,-rpath,$(ICP_BUILD_OUTPUT) -L$(ICP_BUILD_OUTPUT)
+endif
+
+ifdef UPSTREAM_DRIVER_CMN_ROOT
+    DRIVER=qat
+    ADFPROXY=adf
+    UDEV=-ludev
+else
+    DRIVER=icp_qa_al
+    ADFPROXY=adf_proxy
+endif
+ 
+ifdef WITH_CPA_MUX
+    DRIVER=qat_mux
+    LIBQAT+= -L/$(ICP_ROOT)/../cpa_mux/src/build/linux_2.6/user_space
+endif
+
+SHAREDLIBQAT= -Wl,-rpath,$(ZLIB_ROOT) -L$(ZLIB_ROOT) -lz -ldl -lrt -lpthread
+STATICLIBQAT= $(ZLIB_ROOT)/libz.a $(LIBQAT) $(UDEV) -l$(DRIVER) -l$(ADFPROXY) -losal -lcrypto -ldl -lrt -lpthread 
+
+ifeq ($(ZLIB_MEMORY_DRIVER),usdm_drv)
+    STATICLIBQAT+= $(CMN_ROOT)/libusdm_drv.a  
+else
+    ifdef UPSTREAM_DRIVER_CMN_ROOT
+        STATICLIBQAT+= $(UPSTREAM_DRIVER_CMN_ROOT)/libusdm_drv.a  
+    endif
+endif
+
+ifeq ($(ZLIB_MEMORY_DRIVER),usdm_drv)
+STATICLIBQAT+= $(CMN_ROOT)/libusdm_drv.a  
+endif
+
+all: static shared
+
+static: comptestapp$(EXE)
+
+shared: comptestappsh$(EXE)
+
+comptestapp$(EXE): $(OBJS) Makefile
+	$(CC) -o comptestapp $(OBJS) $(COVERAGE) \
+	$(STATICLIBQAT)
+
+comptestappsh$(EXE): $(OBJS) Makefile
+	$(CC) -o comptestappsh $(OBJS) $(COVERAGE) \
+	$(SHAREDLIBQAT)
+
+clean:
+	rm -f $(OBJS) $(COVERAGE_OBJS) comptestapp comptestappsh
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/qat_zlib_test/test_parameters.h ./contrib/qat/qat_zlib_test/test_parameters.h
--- ../zlib-1.2.8/contrib/qat/qat_zlib_test/test_parameters.h	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/qat_zlib_test/test_parameters.h	2016-09-12 08:22:02.983601000 +0100
@@ -0,0 +1,96 @@
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012,2013 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#ifndef __TEST_PARAMETERS_H
+#define __TEST_PARAMETERS_H
+
+#include "zlib.h"
+
+
+typedef struct
+{
+    int count;
+    int type;
+    int id;
+    char *file_path;
+    unsigned char* input_buf;
+    unsigned char* output_buf;
+    unsigned long input_buflen;
+    unsigned long output_buflen;
+    unsigned long single_call_bytes;
+    unsigned long  verify_checksum;
+    int level;
+    int chunksize;
+    int corpus;
+    int enable_deflate_buffering;
+    int enable_inflate_buffering;
+    int allow_partial_chunks;
+    int windowsize;
+    int streamtype;
+    int verify;
+    float ratio;
+    z_stream strm;
+}
+test_parameters_t;
+
+#endif
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/qat_zlib_test/tests.c ./contrib/qat/qat_zlib_test/tests.c
--- ../zlib-1.2.8/contrib/qat/qat_zlib_test/tests.c	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/qat_zlib_test/tests.c	2016-09-12 08:22:03.002601000 +0100
@@ -0,0 +1,161 @@
+
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012,2013 Intel Corporation. 
+ *   All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012,2013 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define _GNU_SOURCE
+#define __USE_GNU
+
+#include <pthread.h>
+
+#include "tests.h"
+
+
+int tests_startup(test_parameters_t* test_parameters)
+{
+    switch (test_parameters->type)
+    {
+        case TEST_CORPUS_COMPRESSION:
+            return tests_startup_corpus_compression(test_parameters);
+            break;
+        case TEST_CORPUS_DECOMPRESSION:
+            return tests_startup_corpus_decompression(test_parameters);
+            break;
+        default:
+            fprintf(stderr, "Unknown test type %d\n", test_parameters->type);
+            return TEST_FAILED;
+            break;
+    }
+}
+
+
+/******************************************************************************
+* function:
+*   tests_run (int count,
+*              int type
+*              ENGINE *e
+*              int id
+*              int print_output
+*              int verify
+*              int performance)
+*
+* @param count        [IN] - Number of iteration count
+* @param type         [IN] - Testing type
+* @param size         [IN] - testing data size
+* @param e            [IN] - OpenSSL engine pointer
+* @param id           [IN] - Thread ID
+* @param print_output [IN] - Print hex out flag
+* @param verfiy       [IN] - Verify output flag
+* @param performance  [IN] - performance output flag
+*
+* description:
+*   select which application to run based on user input
+******************************************************************************/
+
+int tests_run(test_parameters_t* test_parameters)
+{
+    int rc=1;
+    printf("\n|-----------------------------------------------------|\n");
+    printf("|----------Thread ID %d, running in progress-----------|\n",test_parameters->id);
+    printf("|-----------------------------------------------------|\n");
+
+    switch (test_parameters->type)
+    {
+        case TEST_CORPUS_COMPRESSION:
+            rc=tests_run_corpus_compression(test_parameters);
+            break;
+        case TEST_CORPUS_DECOMPRESSION:
+            rc=tests_run_corpus_decompression(test_parameters);
+            break;
+        default:
+            fprintf(stderr, "Unknown test type %d\n", test_parameters->type);
+            rc=TEST_FAILED;
+            break;
+    }
+
+    printf("\n|-----------------------------------------------------|\n");
+    printf("|----------Thread ID %3d finished---------------------|\n",
+           test_parameters->id);
+    printf("|-----------------------------------------------------|\n");
+    return rc;
+}
+
+int tests_shutdown(test_parameters_t* test_parameters)
+{
+    switch (test_parameters->type)
+    {
+        case TEST_CORPUS_COMPRESSION:
+            return tests_shutdown_corpus_compression(test_parameters);
+            break;
+        case TEST_CORPUS_DECOMPRESSION:
+            return tests_shutdown_corpus_decompression(test_parameters);
+            break;
+        default:
+            fprintf(stderr, "Unknown test type %d\n", test_parameters->type);
+            return TEST_FAILED;
+            break;
+    }
+}
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/qat_zlib_test/tests_compression.c ./contrib/qat/qat_zlib_test/tests_compression.c
--- ../zlib-1.2.8/contrib/qat/qat_zlib_test/tests_compression.c	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/qat_zlib_test/tests_compression.c	2016-09-12 08:22:03.186605000 +0100
@@ -0,0 +1,510 @@
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012,2013 Intel Corporation. 
+ *   All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012,2013 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include "zlib.h"
+
+#include "tests.h"
+
+int 
+startup_corpus_compression(test_parameters_t* test_parameters)
+{
+    int numFiles = 0, i = 0;
+    int attemptCalgary2 = 0;
+    char **pCorpusFileNamesArray = NULL;
+    char* fullPathAndFilename;
+    unsigned long totalFilesize = 0, individualFilesize = 0, numBytesRead = 0;    
+    unsigned long spaceRemaining = 0;
+
+    char *customFileNames [] =
+    {
+            "customfile.bin"
+    };
+
+    char *canterburyFileNames [] =
+    {
+            "alice29.txt", "asyoulik.txt", "cp.html",
+            "fields.c","grammar.lsp", "kennedy.xls", "lcet10.txt" ,
+            "plrabn12.txt", "ptt5"
+    };
+
+    /* Large Calgary Corpus */	
+    char *calgaryFileNames [] =
+    {
+            "bib", "book1", "book2", "geo" , "news", "obj1",
+            "obj2", "paper1", "paper2", "paper3", "paper4",
+            "paper5", "paper6", "pic", "progc",
+            "progl" , "progp" ,"trans"
+    };
+    /* QA performance sample code uses "calgary" file.
+     * "calgary" is the concatenation of all the above files
+     * in the large calgary corpus.
+     * This code accepts "calgary" as an alternative to all
+     * the individual files above.
+     * Note calgaryFileNames and calgaryFileNames2 are the same
+     * input data */
+    char *calgaryFileNames2 [] =
+    {
+            "calgary"
+    };
+
+    char *silesiaFileNames [] =
+    {
+            "dickens", "mozilla", "mr", "nci" , "ooffice", "osdb",
+            "reymont", "samba", "sao", "webster", "xml",
+            "x-ray"
+    };
+	
+    switch(test_parameters->corpus)
+    {
+        case CUSTOM_FILE:
+            pCorpusFileNamesArray = customFileNames;
+            numFiles = sizeof(customFileNames)/sizeof(char *);
+            break;
+        case CANTERBURY_CORPUS:
+            pCorpusFileNamesArray = canterburyFileNames;
+            numFiles = sizeof(canterburyFileNames)/sizeof(char *);
+            break;
+        case CALGARY_CORPUS:
+            pCorpusFileNamesArray = calgaryFileNames;
+            numFiles = sizeof(calgaryFileNames)/sizeof(char *);
+            break;
+        case SILESIA_CORPUS:
+            pCorpusFileNamesArray = silesiaFileNames;
+            numFiles = sizeof(silesiaFileNames)/sizeof(char *);
+            break;
+        default:
+            pCorpusFileNamesArray = calgaryFileNames;
+            numFiles = sizeof(calgaryFileNames)/sizeof(char *);
+            break;
+    }
+	
+    const char* path = "/lib/firmware/";
+    FILE *testfile = NULL;
+    if (test_parameters->file_path[0] != '\0') {
+        path=test_parameters->file_path;  
+    }
+    
+    /* Workout total size of corpus files */
+    for(i=0; i<numFiles; i++) {
+        fullPathAndFilename = malloc(strlen(path) + strlen(pCorpusFileNamesArray[i]) + 1); 
+        if (NULL == fullPathAndFilename) {
+            fprintf(stderr, "# FAIL: Could not allocate space for Filename.\n");
+            return TEST_FAILED;
+        }
+
+        strcpy(fullPathAndFilename, path);
+        strcat(fullPathAndFilename, pCorpusFileNamesArray[i]); 
+        testfile = fopen(fullPathAndFilename, "rb");
+        if (testfile) {
+            fseek(testfile, 0, SEEK_END);
+            totalFilesize+=ftell(testfile);
+            fclose(testfile);
+        }
+        else {
+            /* In the Calgary Case try calgaryFileNames2 */
+            if((test_parameters->corpus != CALGARY_CORPUS) || (attemptCalgary2 == 1))
+            {
+               fprintf(stderr, "# FAIL: Could not open file: %s\n", fullPathAndFilename);
+               free(fullPathAndFilename);
+               fullPathAndFilename = NULL;
+               return TEST_FAILED;
+            }
+            else
+            {
+               attemptCalgary2 = 1;
+               pCorpusFileNamesArray = calgaryFileNames2;
+               numFiles = sizeof(calgaryFileNames2)/sizeof(char *);
+               free(fullPathAndFilename);
+               fullPathAndFilename = NULL;
+               totalFilesize=0;
+               i=-1;
+               continue;
+            }
+        }
+        free(fullPathAndFilename);
+        fullPathAndFilename = NULL;
+    }
+        
+    if (totalFilesize < test_parameters->chunksize) {
+        fprintf(stderr, "# FAIL: Chunksize: %d is greater then the total filesize: %ld, this is not allowed\n", test_parameters->chunksize, totalFilesize);
+        return TEST_FAILED;
+    }
+    
+    /* Allocate buffers and set size */
+    if (test_parameters->allow_partial_chunks) {
+        test_parameters->input_buflen=totalFilesize;
+    }
+    else {
+        test_parameters->input_buflen=(totalFilesize - (totalFilesize % test_parameters->chunksize));
+    }
+    /* Allow a hundred bytes extra in case we do verification and need some extra room in
+       case the file decompresses incorrectly and because we don't empty the buffer we need
+       at least a byte of additional space. */ 
+    test_parameters->input_buf=(unsigned char *)malloc(test_parameters->input_buflen+100);
+    /* Create the output buffer slightly bigger as if you try and compress data 
+       that won't compress it will slightly expand. The magic numbers to ensure
+       enough space are to multiply by 9 then dividing by 8 and then add 5. */
+    test_parameters->output_buflen=((test_parameters->input_buflen*9)/8) + 5;
+    test_parameters->output_buf=(unsigned char*)malloc(test_parameters->output_buflen);
+    spaceRemaining = test_parameters->input_buflen;  
+	
+    /* Read all corpus files into input buffer */
+    for(i=0; i<numFiles; i++)
+    {
+        individualFilesize=0;
+        fullPathAndFilename = malloc(strlen(path) + strlen(pCorpusFileNamesArray[i]) + 1); 
+        if (NULL == fullPathAndFilename) {
+            fprintf(stderr, "# FAIL: Could not allocate space for Filename.\n");
+            return TEST_FAILED;
+        }
+        strcpy(fullPathAndFilename, path);
+        strcat(fullPathAndFilename, pCorpusFileNamesArray[i]); 
+        testfile = fopen(fullPathAndFilename, "rb");
+        if (testfile) {
+            fseek(testfile, 0, SEEK_END);
+            individualFilesize=ftell(testfile);
+            if (individualFilesize > spaceRemaining)
+                individualFilesize = spaceRemaining;
+            fseek(testfile, 0, SEEK_SET);
+            fread(test_parameters->input_buf+numBytesRead, 
+                individualFilesize, 1, testfile);
+            if (ferror(testfile)) {
+                fprintf(stderr, "# FAIL: Error: reading from file\n");
+                free(fullPathAndFilename);
+                fullPathAndFilename = NULL;
+                fclose(testfile);
+                return TEST_FAILED;
+            }
+            numBytesRead+=individualFilesize;
+            spaceRemaining-=individualFilesize;
+            fclose(testfile);
+        }
+        else {
+            fprintf(stderr, "# FAIL: Could not open file: %s\n", fullPathAndFilename);
+            free(fullPathAndFilename);
+            fullPathAndFilename = NULL;
+            return TEST_FAILED;
+        }
+        free(fullPathAndFilename);
+        fullPathAndFilename = NULL;
+    }
+	
+	if (test_parameters->verify) {
+        test_parameters->verify_checksum=0;
+        test_parameters->verify_checksum = crc32(0, test_parameters->input_buf,(uInt)test_parameters->input_buflen);
+    }
+	
+    return TEST_PASSED;
+}
+
+
+
+int 
+run_corpus_compression(test_parameters_t* test_parameters)
+{
+   int ret = 0;
+   int i = 0;
+   int flush;
+   int failed=TEST_PASSED;
+   int windowbits;
+   unsigned long totalout = 0;
+
+   windowbits = test_parameters->windowsize + 8; 
+   
+   switch(test_parameters->streamtype)
+   {
+       case RAW_DEFLATE_STREAM:
+           windowbits = -windowbits;
+           break;
+       case ZLIB_DEFLATE_STREAM:
+           /* Do nothing windowbits is correct */
+           break;
+       case GZIP_DEFLATE_STREAM:
+           windowbits += 16;
+           break;
+       default:
+           /* Default to gzip encoding */
+           windowbits += 16;
+           break;
+   }
+	  
+   for (i = 0; i < test_parameters->count; i++) {
+        z_stream strm;
+        strm.zalloc = Z_NULL;
+        strm.zfree = Z_NULL;
+        strm.opaque = Z_NULL;	
+        strm.next_out = (void *)test_parameters->output_buf;
+        strm.avail_out = test_parameters->output_buflen;
+        strm.total_out = 0;
+        
+        /* Set the flush flag according to command line parameter..  
+         * default value is to buffer within zlib shim */
+        if (test_parameters->enable_deflate_buffering)  
+            flush=Z_NO_FLUSH;
+        else
+            flush=Z_SYNC_FLUSH;
+
+        ret = deflateInit2(&strm, test_parameters->level, 8, windowbits, 8, 0);	
+        if (ret == Z_STREAM_ERROR || ret == Z_DATA_ERROR) {
+            failed=TEST_FAILED;
+        }
+       
+        if (TEST_PASSED == failed) { 
+	    do {
+                strm.next_in = (void *)test_parameters->input_buf+strm.total_in;
+                if (strm.total_in+test_parameters->chunksize >= test_parameters->input_buflen) {
+                    strm.avail_in = test_parameters->input_buflen - strm.total_in;
+                    flush = Z_FINISH;
+                }
+                else {
+                    strm.avail_in = test_parameters->chunksize;
+                }
+                ret = deflate(&strm, flush);
+                strm.avail_out = test_parameters->output_buflen - strm.total_out;
+            } while (ret == Z_OK);
+    
+            if (ret == Z_STREAM_ERROR || ret == Z_DATA_ERROR) {
+                printf("# FAIL: deflate stream corrupt");
+                failed=TEST_FAILED;
+            }
+        }
+		
+        test_parameters->single_call_bytes = strm.total_in;
+        test_parameters->ratio = (float)strm.total_out / strm.total_in; 		
+		
+		totalout = strm.total_out;
+		
+        deflateEnd(&strm);
+    }
+	
+	// Update the compressed length, so it can be properly decompressed...
+    test_parameters->output_buflen = totalout;
+    return failed;
+}
+
+
+
+int
+shutdown_corpus_compression(test_parameters_t* test_parameters)
+{
+    z_stream strm;
+    int ret = 0;
+    int failed=TEST_PASSED;
+    int flush;
+    int windowbits;
+    unsigned long verify_checksum = 0;
+	
+    if (test_parameters->input_buf) {
+        if (test_parameters->verify) {
+            windowbits = test_parameters->windowsize + 8; 
+   
+            switch(test_parameters->streamtype)
+            {
+                case RAW_DEFLATE_STREAM:
+                    windowbits = -windowbits;
+                break;
+                case ZLIB_DEFLATE_STREAM:
+                    /* Do nothing windowbits is correct */
+                break;
+                case GZIP_DEFLATE_STREAM:
+                    windowbits += 16;
+                break;
+                default:
+                    /* Default to gzip encoding */
+                    windowbits += 16;
+                break;
+            }
+
+            ret = Z_OK;
+            strm.zalloc = Z_NULL;
+            strm.zfree = Z_NULL;
+            strm.opaque = Z_NULL;
+            /* Note: Input buffer and Output Buffer are swapped over for the decompression. */
+            strm.next_out = (void *)test_parameters->input_buf;
+            /* Add one hundred to strm.avail_out to work around the fact that for performance timings
+               we are not emptying the buffer we decompress to (input buffer in this
+               case) */
+            strm.avail_out = test_parameters->input_buflen+100;
+            strm.total_out = 0;
+      
+            /* Set the flush flag according to command line parameter.. 
+             * default value is to buffer within zlib shim */
+            if (test_parameters->enable_inflate_buffering) 
+                flush=Z_NO_FLUSH;
+            else
+                flush=Z_SYNC_FLUSH;
+        
+            ret = inflateInit2(&strm, windowbits);
+            if (ret == Z_STREAM_ERROR || ret == Z_DATA_ERROR) {
+                fprintf(stderr,"# FAIL: deflate stream corrupt on Inflate init\n");
+                failed = TEST_FAILED;
+            }
+            strm.next_in = (void *)test_parameters->output_buf;
+            strm.avail_in = test_parameters->output_buflen;
+            if (TEST_PASSED == failed) { 
+                do {
+                    strm.next_in = (void *)test_parameters->output_buf+strm.total_in;
+                    if (strm.total_in+test_parameters->chunksize >= test_parameters->output_buflen) {
+                        strm.avail_in = test_parameters->output_buflen - strm.total_in;
+                        flush = Z_FINISH;
+                    }
+                    else {
+                        strm.avail_in = test_parameters->chunksize;
+                    }
+                    ret = inflate(&strm, flush);
+                } while (ret == Z_OK);
+
+                if (ret == Z_STREAM_ERROR || ret == Z_DATA_ERROR) {
+                   fprintf(stderr,"# FAIL: deflate stream corrupt on Inflate\n");
+                   failed = TEST_FAILED;
+                }
+            }
+            inflateEnd(&strm);
+			
+            verify_checksum = crc32(0, test_parameters->input_buf, (uInt)test_parameters->input_buflen);
+            if (test_parameters->verify_checksum == verify_checksum && TEST_PASSED == failed) {
+                fprintf(stderr, "\nVerification: PASS\n\n");
+            }
+            else {
+                fprintf(stderr, "\nVerification: FAIL\n\n");
+                failed = TEST_FAILED;
+            }
+        }
+		
+        free(test_parameters->input_buf);
+        test_parameters->input_buf = NULL;
+        test_parameters->input_buflen = 0;
+    }
+    if (test_parameters->output_buf) {
+        free(test_parameters->output_buf);
+        test_parameters->output_buf = NULL;
+        test_parameters->output_buflen = 0;
+    }   
+    return failed;
+}
+
+
+
+/******************************************************************************
+* function:
+*     tests_startup_corpus_compression  (test_parameters_t* test_parameters)
+*
+* @param test_parameters [IN] - struct containing all the parameters/buffers used.
+*                               it is passed in as a pointer as some of the values will get updated
+*                               within the function. Specifically the input/output buffers and lengths
+*                               will get created/set within this function.
+*
+* description:
+*	setup a corpus compression job where we run compression across a buffer of concatinated corpus files
+*
+******************************************************************************/
+int
+tests_startup_corpus_compression(test_parameters_t* test_parameters)
+{
+   return startup_corpus_compression(test_parameters);
+} 
+
+/******************************************************************************
+* function:
+*     tests_run_corpus_compression  (test_parameters_t* test_parameters)
+*
+* @param test_parameters [IN] - struct containing all the parameters/buffers used.
+*                               it is passed in as a pointer as some of the values will get updated
+*                               within the function.
+*
+* description:
+*	run a corpus compression job where we run compression across a buffer of concatinated corpus files
+*
+******************************************************************************/
+int
+tests_run_corpus_compression(test_parameters_t* test_parameters)
+{
+    return run_corpus_compression(test_parameters);
+} 
+
+/******************************************************************************
+* function:
+*     tests_shutdown_corpus_compression  (test_parameters_t* test_parameters)
+*
+* @param test_parameters [IN] - struct containing all the parameters/buffers used.
+*                               it is passed in as a pointer as some of the values will get updated
+*                               within the function. Specifically the input/output buffers and lengths
+*                               will get freed/set to zero within this function.
+*
+* description:
+*	shutdown a corpus compression job where we run compression across a buffer of concatinated corpus files
+*
+******************************************************************************/
+int
+tests_shutdown_corpus_compression(test_parameters_t* test_parameters)
+{
+    return shutdown_corpus_compression(test_parameters);
+} 
+
+
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/qat_zlib_test/tests_decompression.c ./contrib/qat/qat_zlib_test/tests_decompression.c
--- ../zlib-1.2.8/contrib/qat/qat_zlib_test/tests_decompression.c	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/qat_zlib_test/tests_decompression.c	2016-09-12 08:22:03.344606000 +0100
@@ -0,0 +1,514 @@
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012,2013 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012,2013 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+
+#include "zlib.h"
+
+#include "tests.h"
+
+int
+startup_corpus_decompression(test_parameters_t* test_parameters)
+{
+    int numFiles = 0, i = 0;
+    int attemptCalgary2 = 0;
+    char **pCorpusFileNamesArray = NULL;
+    char* fullPathAndFilename;
+    unsigned long totalFilesize = 0, individualFilesize = 0, numBytesRead = 0;
+    unsigned long spaceRemaining = 0;
+    z_stream strm;
+    int ret = 0;
+    int failed=TEST_PASSED;
+    int flush;
+    int windowbits;
+
+    char *customFileNames [] =
+    {
+            "customfile.bin"
+    };
+
+    char *canterburyFileNames [] =
+    {
+            "alice29.txt", "asyoulik.txt", "cp.html",
+            "fields.c","grammar.lsp", "kennedy.xls", "lcet10.txt" ,
+            "plrabn12.txt", "ptt5"
+    };
+
+    /* Large Calgary Corpus */
+    char *calgaryFileNames [] =
+    {
+            "bib", "book1", "book2", "geo" , "news", "obj1",
+            "obj2", "paper1", "paper2", "paper3", "paper4",
+            "paper5", "paper6", "pic", "progc",
+            "progl" , "progp" ,"trans"
+    };
+    /* QA performance sample code uses "calgary" file.
+     * "calgary" is the concatenation of all the above files
+     * in the large calgary corpus.
+     * This code accepts "calgary" as an alternative to all
+     * the individual files above.
+     * Note calgaryFileNames and calgaryFileNames2 are the same
+     * input data */
+    char *calgaryFileNames2 [] =
+    {
+            "calgary"
+    };
+
+    char *silesiaFileNames [] =
+    {
+            "dickens", "mozilla", "mr", "nci" , "ooffice", "osdb",
+            "reymont", "samba", "sao", "webster", "xml",
+            "x-ray"
+    };
+
+    switch(test_parameters->corpus)
+    {
+        case CUSTOM_FILE:
+            pCorpusFileNamesArray = customFileNames;
+            numFiles = sizeof(customFileNames)/sizeof(char *);
+            break;
+        case CANTERBURY_CORPUS:
+            pCorpusFileNamesArray = canterburyFileNames;
+            numFiles = sizeof(canterburyFileNames)/sizeof(char *);
+            break;
+        case CALGARY_CORPUS:
+            pCorpusFileNamesArray = calgaryFileNames;
+            numFiles = sizeof(calgaryFileNames)/sizeof(char *);
+            break;
+	case SILESIA_CORPUS:
+            pCorpusFileNamesArray = silesiaFileNames;
+            numFiles = sizeof(silesiaFileNames)/sizeof(char *);
+            break;
+	default:
+            fprintf(stderr, "Corpus not valid - Defaulting to use Calgary Corpus\n");
+            pCorpusFileNamesArray = calgaryFileNames;
+            numFiles = sizeof(calgaryFileNames)/sizeof(char *);
+            break;
+    }
+
+    windowbits = test_parameters->windowsize + 8; 
+   
+    switch(test_parameters->streamtype)
+    {
+        case RAW_DEFLATE_STREAM:
+            windowbits = -windowbits;
+            break;
+        case ZLIB_DEFLATE_STREAM:
+            /* Do nothing windowbits is correct */
+            break;
+        case GZIP_DEFLATE_STREAM:
+            windowbits += 16;
+            break;
+        default:
+            /* Default to gzip encoding */
+            windowbits += 16;
+            break;
+    }
+
+    const char* path = "/lib/firmware/";
+    FILE *testfile = NULL;
+    if (test_parameters->file_path[0] != '\0') {
+        path=test_parameters->file_path;
+    }
+
+     /* Workout total size of corpus files */
+    for(i=0; i<numFiles; i++) {
+        fullPathAndFilename = malloc(strlen(path) + strlen(pCorpusFileNamesArray[i]) + 1);
+        if (NULL == fullPathAndFilename) {
+            fprintf(stderr, "# FAIL: Could not allocate space for filename.\n");
+            return TEST_FAILED;
+        }
+        strcpy(fullPathAndFilename, path);
+        strcat(fullPathAndFilename, pCorpusFileNamesArray[i]);
+        testfile = fopen(fullPathAndFilename, "rb");
+        if (testfile) {
+            fseek(testfile, 0, SEEK_END);
+            totalFilesize+=ftell(testfile);
+            fclose(testfile);
+        }
+        else {
+            /* In the Calgary Case try calgaryFileNames2 */
+            if((test_parameters->corpus != CALGARY_CORPUS) || (attemptCalgary2 == 1))
+            {
+               fprintf(stderr, "# FAIL: Could not open file: %s\n", fullPathAndFilename);
+               free(fullPathAndFilename);
+               fullPathAndFilename = NULL;
+               return TEST_FAILED;
+            }
+            else
+            {
+               attemptCalgary2 = 1;
+               pCorpusFileNamesArray = calgaryFileNames2;
+               numFiles = sizeof(calgaryFileNames2)/sizeof(char *);
+               free(fullPathAndFilename);
+               fullPathAndFilename = NULL;
+               totalFilesize=0;
+               i=-1;
+               continue;
+            }
+        }
+        free(fullPathAndFilename);
+        fullPathAndFilename = NULL;
+    }
+
+    if (totalFilesize < test_parameters->chunksize) {
+        fprintf(stderr, "# FAIL: Chunksize: %d is greater than the total filesize: %ld, this is not allowed\n", test_parameters->chunksize, totalFilesize);
+        return TEST_FAILED;
+    }
+
+    /* In order to prepare for the decompression we need to generate
+       a compressed file to work with. We are going to do this in the
+       setup so it does not affect the timing of the decompression. */
+
+    /* Allocate buffers and set size */
+    if (test_parameters->allow_partial_chunks) {
+        test_parameters->input_buflen=totalFilesize;
+    }
+    else {
+        test_parameters->input_buflen=(totalFilesize - (totalFilesize % test_parameters->chunksize));
+    }
+    /* Allow an extra hundred bytes on the input_buf. We won't actually use them for data.
+       We need it because during the decompression we are not emptying the
+       output buffer so we will need to specify an output buffer bigger than 
+       the output otherwise the shim will correctly detect there is no room left in
+       the output buffer and stop progressing until it is emptied which it never 
+       will be. */
+    test_parameters->input_buf=(unsigned char *)malloc(test_parameters->input_buflen+100);
+    /* Create the output buffer slightly bigger as if you try and compress data
+       that won't compress it will slightly expand. The magic numbers to ensure
+       enough space are to multiply by 9 then dividing by 8 and then add 5. */
+    test_parameters->output_buflen=((test_parameters->input_buflen*9)/8) + 5;
+    test_parameters->output_buf=(unsigned char*)malloc(test_parameters->output_buflen);
+    spaceRemaining = test_parameters->input_buflen;
+
+    /* Read all corpus files into input buffer */
+    for(i=0; i<numFiles; i++) {
+        individualFilesize=0;
+        fullPathAndFilename = malloc(strlen(path) + strlen(pCorpusFileNamesArray[i]) + 1);
+        if (NULL == fullPathAndFilename) {
+            fprintf(stderr, "# FAIL: Could not allocate space for filename.\n");
+            return TEST_FAILED;
+        }
+        strcpy(fullPathAndFilename, path);
+        strcat(fullPathAndFilename, pCorpusFileNamesArray[i]);
+        testfile = fopen(fullPathAndFilename, "rb");
+        if (testfile) {
+            fseek(testfile, 0, SEEK_END);
+            individualFilesize=ftell(testfile);
+            if (individualFilesize > spaceRemaining)
+                individualFilesize = spaceRemaining;
+            fseek(testfile, 0, SEEK_SET);
+            fread(test_parameters->input_buf+numBytesRead,
+                individualFilesize, 1, testfile);
+            if (ferror(testfile)) {
+                fprintf(stderr, "# FAIL: Error: reading from file\n");
+                free(fullPathAndFilename);
+                fullPathAndFilename = NULL;
+                fclose(testfile);
+                return TEST_FAILED;
+            }
+            numBytesRead+=individualFilesize;
+            spaceRemaining-=individualFilesize;
+            fclose(testfile);
+        }
+        else {
+           fprintf(stderr, "# FAIL: Could not open file: %s\n", fullPathAndFilename);
+           free(fullPathAndFilename);
+           fullPathAndFilename = NULL;
+           return TEST_FAILED;
+        }
+        free(fullPathAndFilename);
+        fullPathAndFilename = NULL;
+    }
+
+    if (test_parameters->verify) {
+        test_parameters->verify_checksum=0;
+        test_parameters->verify_checksum = crc32(0, test_parameters->input_buf, (uInt)test_parameters->input_buflen);
+    }
+
+    strm.zalloc = Z_NULL;
+    strm.zfree = Z_NULL;
+    strm.opaque = Z_NULL;
+
+    strm.next_out = (void *)test_parameters->output_buf;
+    strm.avail_out = test_parameters->output_buflen;
+    strm.total_out = 0;
+
+    /* Set the flush flag according to command line parameter.. 
+     * default value is to buffer within zlib shim */
+    if (test_parameters->enable_deflate_buffering)
+        flush=Z_NO_FLUSH;
+    else {
+        flush=Z_SYNC_FLUSH;
+    }
+
+    ret = deflateInit2(&strm, test_parameters->level, 8, windowbits, 8, 0);
+    if (ret == Z_STREAM_ERROR || ret == Z_DATA_ERROR) {
+        fprintf(stderr, "# FAIL: deflate stream corrupt\n");
+        failed=TEST_FAILED;
+    }
+
+    if (TEST_PASSED == failed) { 
+        do {
+            strm.next_in = (void *)test_parameters->input_buf+strm.total_in;
+            if (strm.total_in+test_parameters->chunksize >= test_parameters->input_buflen) {
+                strm.avail_in = test_parameters->input_buflen - strm.total_in;
+                flush = Z_FINISH;
+            }
+            else {
+                strm.avail_in = test_parameters->chunksize;
+            }
+            ret = deflate(&strm, flush);
+            strm.avail_out = test_parameters->output_buflen - strm.total_out;
+        } while (ret == Z_OK);
+
+        if (ret == Z_STREAM_ERROR || ret == Z_DATA_ERROR) {
+            fprintf(stderr, "# FAIL: deflate stream corrupt\n");
+            failed=TEST_FAILED;
+        }
+    }
+    // Update the compressed length, so it can be properly decompressed...
+    test_parameters->output_buflen = strm.total_out;
+    deflateEnd(&strm);
+
+    return failed;
+}
+
+
+
+int
+run_corpus_decompression(test_parameters_t* test_parameters)
+{
+    z_stream strm;
+    int ret = 0;
+    int i = 0;
+    int failed=TEST_PASSED;
+    int flush;
+    int windowbits;
+
+    windowbits = test_parameters->windowsize + 8; 
+   
+    switch(test_parameters->streamtype)
+    {
+        case RAW_DEFLATE_STREAM:
+            windowbits = -windowbits;
+            break;
+        case ZLIB_DEFLATE_STREAM:
+            /* Do nothing windowbits is correct */
+            break;
+        case GZIP_DEFLATE_STREAM:
+            windowbits += 16;
+            break;
+        default:
+            /* Default to gzip encoding */
+            windowbits += 16;
+            break;
+    }
+
+    for (i = 0; i < test_parameters->count; i++) {
+        ret = Z_OK;
+        strm.zalloc = Z_NULL;
+        strm.zfree = Z_NULL;
+        strm.opaque = Z_NULL;
+        /* Note: Input buffer and Output Buffer are swapped over for the decompression. */
+        strm.next_out = (void *)test_parameters->input_buf;
+        /* Add one hundred to strm.avail_out to work around the fact that for performance timings
+           we are not emptying the buffer we decompress to (input buffer in this
+           case) */
+        strm.avail_out = test_parameters->input_buflen+100;
+        strm.total_out = 0;
+      
+        /* Set the flush flag according to command line parameter.. 
+         * default value is to buffer within zlib shim */
+        if (test_parameters->enable_inflate_buffering) 
+	    flush=Z_NO_FLUSH;
+	else
+	    flush=Z_SYNC_FLUSH;
+        
+        ret = inflateInit2(&strm, windowbits);
+        if (ret == Z_STREAM_ERROR || ret == Z_DATA_ERROR) {
+            fprintf(stderr,"# FAIL: deflate stream corrupt on Inflate init\n");
+            failed = TEST_FAILED;
+        }
+        strm.next_in = (void *)test_parameters->output_buf;
+        strm.avail_in = test_parameters->output_buflen;
+        if (TEST_PASSED == failed) { 
+            do {
+                strm.next_in = (void *)test_parameters->output_buf+strm.total_in;
+                if (strm.total_in+test_parameters->chunksize >= test_parameters->output_buflen) {
+                    strm.avail_in = test_parameters->output_buflen - strm.total_in;
+                    flush = Z_FINISH;
+                }
+                else {
+                    strm.avail_in = test_parameters->chunksize;
+                }
+                ret = inflate(&strm, flush);
+            } while (ret == Z_OK);
+
+            if (ret == Z_STREAM_ERROR || ret == Z_DATA_ERROR) {
+                fprintf(stderr,"# FAIL: deflate stream corrupt on Inflate\n");
+                failed = TEST_FAILED;
+            }
+        }
+
+        test_parameters->single_call_bytes = strm.total_out;
+        test_parameters->ratio = (float)strm.total_out / strm.total_in;
+        inflateEnd(&strm);
+    }
+    return failed;
+}
+
+
+
+int
+shutdown_corpus_decompression(test_parameters_t* test_parameters)
+{
+    unsigned long verify_checksum = 0;
+    int failed=TEST_PASSED;
+
+    if (test_parameters->input_buf) {
+        if (test_parameters->verify) {
+            verify_checksum = crc32(0, test_parameters->input_buf, (uInt)test_parameters->input_buflen);
+            if (test_parameters->verify_checksum == verify_checksum) {
+                fprintf(stderr, "\nVerification: PASS\n\n");
+            }
+            else {
+                fprintf(stderr, "\nVerification: FAIL\n\n");
+                failed = TEST_FAILED;
+            }
+        }
+        free(test_parameters->input_buf);
+        test_parameters->input_buf = NULL;
+        test_parameters->input_buflen = 0;
+    }
+    if (test_parameters->output_buf) {
+        free(test_parameters->output_buf);
+        test_parameters->output_buf = NULL;
+        test_parameters->output_buflen = 0;
+    }
+    return failed;
+}
+
+
+
+/******************************************************************************
+* function:
+*     tests_startup_corpus_decompression  (test_parameters_t* test_parameters)
+*
+* @param test_parameters [IN] - struct containing all the parameters/buffers used.
+*                               it is passed in as a pointer as some of the value will get updated
+*                               within the function. Specifically the input/output buffers and lengths
+*                               will get created/set within this function.
+*
+* description:
+*	setup a corpus decompression job
+*
+******************************************************************************/
+int
+tests_startup_corpus_decompression(test_parameters_t* test_parameters)
+{
+   return startup_corpus_decompression(test_parameters);
+}
+
+/******************************************************************************
+* function:
+*     tests_run_corpus_decompression  (test_parameters_t* test_parameters)
+*
+* @param test_parameters [IN] - struct containing all the parameters/buffers used.
+*                               it is passed in as a pointer as some of the values will get updated
+*                               within the function.
+*
+* description:
+*	run a corpus decompression job
+*
+******************************************************************************/
+int
+tests_run_corpus_decompression(test_parameters_t* test_parameters)
+{
+    return run_corpus_decompression(test_parameters);
+}
+
+/******************************************************************************
+* function:
+*     tests_shutdown_corpus_decompression  (test_parameters_t* test_parameters)
+*
+* @param test_parameters [IN] - struct containing all the parameters/buffers used.
+*                               it is passed in as a pointer as some of the values will get updated
+*                               within the function. Specifically the input/output buffers and lengths
+*                               will get freed/set to zero within this function.
+*
+* description:
+*	shutdown a corpus decompression job
+*
+******************************************************************************/
+int
+tests_shutdown_corpus_decompression(test_parameters_t* test_parameters)
+{
+    return shutdown_corpus_decompression(test_parameters);
+}
+
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/qat_zlib_test/tests.h ./contrib/qat/qat_zlib_test/tests.h
--- ../zlib-1.2.8/contrib/qat/qat_zlib_test/tests.h	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/qat_zlib_test/tests.h	2016-09-12 08:22:03.019601000 +0100
@@ -0,0 +1,139 @@
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012,2013 Intel Corporation. 
+ *   All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012,2013 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#ifndef __TESTS_H
+#define __TESTS_H
+
+#include "test_parameters.h"
+
+static __inline__ unsigned long long rdtsc(void)
+{
+    unsigned long a, d;
+
+    asm volatile ("rdtsc":"=a" (a), "=d"(d));
+
+    return (((unsigned long long)a) | (((unsigned long long)d) << 32));
+}
+
+int tests_startup (test_parameters_t* test_parameters);
+int tests_run (test_parameters_t* test_parameters);
+int tests_shutdown (test_parameters_t* test_parameters);
+
+/* This function will read in the files to a memory buffer ready for
+   the corpus compression test */
+int tests_startup_corpus_compression (test_parameters_t* test_parameters);
+
+/* This function runs the actual corpus compression test. It will submit
+   the buffer created in the startup function above in chunks until the
+   zlib API has finished compressing. It uses the Z_NO_FLUSH flag. It will
+   do this as many times as specified in the test_parameters */
+int tests_run_corpus_compression (test_parameters_t* test_parameters);
+
+/* This function will cleanup up the memory allocation of buffers after 
+   the corpus compression. */ 
+int tests_shutdown_corpus_compression (test_parameters_t* test_parameters);
+
+
+/* This function will read in the files to a memory buffer ready. It will
+   then compress the files so they are in a form ready to be submitted to
+   the corpus decompression test */
+int tests_startup_corpus_decompression (test_parameters_t* test_parameters);
+
+/* This function runs the actual corpus decompression test. It will submit
+   the buffer created in the startup function above as one large buffer to
+   the zlib API and read output into one big output buffer big enough to
+   hold the whole decompressed file. It will run the decompression as many 
+   times as specified in the test parameters */ 
+int tests_run_corpus_decompression (test_parameters_t* test_parameters);
+
+/* This function will cleanup up the memory allocation of buffers after 
+   the corpus decompression. */ 
+int tests_shutdown_corpus_decompression (test_parameters_t* test_parameters);
+
+
+/* Defines for zlib corner tests maximum length for stateless operation */
+#define DEFLATE_LENGTH          108544
+
+#define TEST_CORPUS_COMPRESSION               1 
+#define TEST_CORPUS_DECOMPRESSION             2
+#define TEST_TYPE_MAX           TEST_CORPUS_DECOMPRESSION
+#define CUSTOM_FILE                           0       
+#define CANTERBURY_CORPUS                     1
+#define CALGARY_CORPUS                        2
+#define SILESIA_CORPUS                        3
+#define CORPUS_MAX              SILESIA_CORPUS
+#define RAW_DEFLATE_STREAM                    0
+#define ZLIB_DEFLATE_STREAM                   1
+#define GZIP_DEFLATE_STREAM                   2
+#define STREAMTYPE_MAX          GZIP_DEFLATE_STREAM
+#define WINDOW_SIZE_8K                        5
+#define WINDOW_SIZE_16K                       6
+#define WINDOW_SIZE_32K                       7
+#define TEST_PASSED                           0
+#define TEST_FAILED                           1
+#define DEBUG(...) 
+
+#define QAT_DEV "/dev/qat_mem"
+
+#endif
+
diff -uBbw -Nr ../zlib-1.2.8/contrib/qat/qat_zlib_test/tests_zcorner.c ./contrib/qat/qat_zlib_test/tests_zcorner.c
--- ../zlib-1.2.8/contrib/qat/qat_zlib_test/tests_zcorner.c	1970-01-01 01:00:00.000000000 +0100
+++ ./contrib/qat/qat_zlib_test/tests_zcorner.c	2016-09-06 13:13:26.554255000 +0100
@@ -0,0 +1,372 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "tests.h"
+#include "zlib.h"
+
+#define NO_TEST 1
+#define NO_INIT 2
+#define MULTI_INIT 3
+#define DEFLATE_AFTER_END 4
+#define MULTI_END 5
+#define BAD_INIT 6
+#define RECOMPRESSION 7
+#define COMPRESS_ZERO 8
+#define NON_SUPPORTED 9
+#define MAX_CASE_NUMBER NON_SUPPORTED
+#define DICTIONARY_SIZE 3
+
+
+
+/******************************************************************************
+* function:
+*/
+int no_init()
+
+/*
+* description:
+*   The function makes a deflate call without previous deflateInit call.
+*   
+******************************************************************************/
+{    
+    int ret = 0;
+    unsigned char deflated[DEFLATE_LENGTH];
+    unsigned char inData[DEFLATE_LENGTH];
+    z_stream deflate_stream;
+
+    deflate_stream.next_in = inData;
+    deflate_stream.avail_in = DEFLATE_LENGTH;
+    deflate_stream.avail_out = DEFLATE_LENGTH;
+    deflate_stream.next_out = deflated;
+
+    ret = deflate(&deflate_stream, Z_FINISH);
+                
+    (void)deflateEnd(&deflate_stream);
+   
+    printf("Return value: %d\n", ret);
+    return ret;
+}
+
+/******************************************************************************
+* function:
+*/
+int multi_init(test_parameters_t* test_parameters)
+
+/*
+* description:
+*   The function makes 5 deflateInit calls by deflateEnd call.
+*   
+******************************************************************************/
+{    
+    int i;
+    int ret = 0;
+    z_stream deflate_stream;
+        
+    deflate_stream.zalloc = Z_NULL;
+    deflate_stream.zfree = Z_NULL;
+    deflate_stream.opaque = Z_NULL;
+
+    for(i=0; i<5; i++)
+    {
+        ret = deflateInit(&deflate_stream, Z_DEFAULT_COMPRESSION);        
+
+        test_parameters->single_call_bytes = deflate_stream.total_in;
+        test_parameters->ratio = (float)deflate_stream.total_out / deflate_stream.total_in; 		
+		
+    }
+    
+    (void)deflateEnd(&deflate_stream);
+    
+    printf("Return value: %d\n", ret);
+    return ret;
+}
+
+/******************************************************************************
+* function:
+*/
+int deflate_after_end()
+
+/*
+* description:
+*   Call init , deflate, finish, and then deflate again.
+*   
+******************************************************************************/
+{    
+    int ret = 0;
+    unsigned char deflated[DEFLATE_LENGTH];
+    unsigned char inData[DEFLATE_LENGTH];
+    z_stream deflate_stream;
+    
+    deflate_stream.zalloc = Z_NULL;
+    deflate_stream.zfree = Z_NULL;
+    deflate_stream.opaque = Z_NULL;
+
+    ret = deflateInit(&deflate_stream, Z_DEFAULT_COMPRESSION);
+
+    deflate_stream.next_in = inData;
+    deflate_stream.avail_in = DEFLATE_LENGTH;
+    deflate_stream.avail_out = DEFLATE_LENGTH;
+    deflate_stream.next_out = deflated;
+
+    ret = deflate(&deflate_stream, Z_FINISH);
+                
+    (void)deflateEnd(&deflate_stream);
+    
+    /* Call deflate after end */
+    ret = deflate(&deflate_stream, Z_FINISH);
+    
+    printf("Return value: %d\n", ret);
+    return ret;
+}
+
+/******************************************************************************
+* function:
+*/
+void multi_end()
+
+/*
+* description:
+*   Calls deflateEnd without deflateInit.
+*   
+******************************************************************************/
+{    
+    z_stream deflate_stream;
+    
+    (void)deflateEnd(&deflate_stream);
+}
+
+/******************************************************************************
+* function:
+*/
+int bad_init()
+
+
+/*
+* description:
+*   Calls deflateInit without assign zalloc, zfree not opaque.
+*   
+******************************************************************************/
+{    
+    int ret;
+    z_stream deflate_stream;
+    
+    ret = deflateInit(&deflate_stream, Z_DEFAULT_COMPRESSION);
+    
+    /* Segmentation fault */
+    
+    printf("Return value: %d\n", ret);
+    return ret;
+}
+
+/******************************************************************************
+* function:
+*/
+void recompression()
+
+/*
+* description:
+*   The function compress twice times a buffer.
+*   
+******************************************************************************/
+{    
+    printf("Not implemented");
+}
+
+/******************************************************************************
+* function:
+*/
+void compress_zero()
+
+/*
+* description:
+*   The function compress a 0 length buffer.
+*   
+******************************************************************************/
+{   
+    /* It is not implemented as corner case. It can be performed 
+    * using -s 0 argument. */
+    printf("Not implemented");
+}
+
+/******************************************************************************
+ * * function:
+ * */
+int non_supported()
+
+/*
+ * * description:
+ * *   The function test the non-supported function looking for wrong return value.
+ * *
+ * ******************************************************************************/
+{
+
+    int ret;
+    printf("executing non_supported");
+    
+    z_stream stream;
+    const Bytef dictionary[DICTIONARY_SIZE];
+    
+    ret = deflateSetDictionary(&stream, dictionary, DICTIONARY_SIZE);
+    if (ret != Z_OK)
+    {
+      printf("Wrong value return by deflateSetDictionary (%d)", ret);
+    }
+
+    ret = deflateCopy(&stream, &stream);
+    if (ret != Z_STREAM_ERROR)
+    {
+      printf("Wrong value return by deflateCopy (%d)", ret);
+    }
+
+    ret = deflateParams(&stream, 1, 1);
+    if (ret != Z_OK)
+    {
+      printf("Wrong value return by deflateParams (%d)", ret);
+    }
+    
+    ret = deflateTune(&stream, 1, 1, 1, 1);
+    if (ret != Z_OK)
+    {
+      printf("Wrong value return by deflateTune (%d)", ret);
+    }
+    
+    unsigned u_int;
+    int i;
+    ret = deflatePending(&stream, &u_int, &i);
+    if (ret != Z_OK)
+    {
+      printf("Wrong value return by deflatePending (%d)", ret);
+    }
+    
+    ret = deflatePrime(&stream, 1, 1);
+    if (ret != Z_OK)
+    {
+      printf("Wrong value return by deflatePrime (%d)", ret);
+    }
+    
+    gz_header head;
+    ret = deflateSetHeader(&stream, &head);
+    if (ret != Z_OK)
+    {
+      printf("Wrong value return by deflateSetHeader (%d)", ret);
+    }
+    
+    ret = inflateSetDictionary(&stream, dictionary, DICTIONARY_SIZE);
+    if (ret != Z_STREAM_ERROR)
+    {
+      printf("Wrong value return by inflateSetDictionary (%d)", ret);
+    }
+    
+    ret = inflateSync(&stream);
+    if (ret != Z_STREAM_ERROR)
+    {
+      printf("Wrong value return by inflateSync (%d)", ret);
+    }
+    
+    ret = inflateCopy(&stream, &stream);
+    if (ret != Z_STREAM_ERROR)
+    {
+      printf("Wrong value return by inflteCopy (%d)", ret);
+    }
+    return ret;
+}
+
+/******************************************************************************
+* function:
+*/
+int run_zcorner(test_parameters_t* test_parameters   // [IN] - Number of the corner case to run
+    )
+
+/*
+* description:
+*   The function is design to test zlib corner cases.
+*   It performs a lot of extrange calls to the API and then checks that it keeps 
+*   running fine.
+*   
+******************************************************************************/
+{    
+    
+    int retval = TEST_PASSED;
+    switch (test_parameters->count)
+    {        
+        case NO_TEST:
+            break;
+        case NO_INIT:
+               retval = no_init();
+            break;
+        case MULTI_INIT:            
+               retval = multi_init(test_parameters);
+            break;
+        case DEFLATE_AFTER_END:
+               retval = deflate_after_end();
+            break;
+        case MULTI_END:
+               multi_end();
+            break;
+        case BAD_INIT:
+               retval = bad_init();
+            break;
+        case RECOMPRESSION:
+               recompression();
+            break;
+        case COMPRESS_ZERO:
+               compress_zero();
+            break;
+        case NON_SUPPORTED:
+              retval = non_supported();
+            break;
+        default:
+            printf("Wrong corner case number\n");
+            return -1;
+    }
+    
+    if (test_parameters->count != NO_TEST)
+    {
+        printf("# ZLIB corner case %d executed.\n",
+               test_parameters->count);
+    }          
+    else
+    {
+        printf("For corner case testing use -t 10 -c <number> to select case.\n");
+        printf("Use <number> between 2 and %d.\n", MAX_CASE_NUMBER);
+    }
+    return retval;
+}
+
+/******************************************************************************/
+int
+tests_run_zcorner(test_parameters_t* test_parameters)
+{
+    return run_zcorner(test_parameters);
+}
+/******************************************************************************
+* function:
+*/
+int tests_startup_zcorner(test_parameters_t* test_parameters
+    )
+
+/*
+* description:
+*	setup zcorner 
+*
+******************************************************************************/
+{
+    /* functionality not implemented performs dummy return */
+    return TEST_PASSED;
+}
+/******************************************************************************
+* function:
+*/
+int tests_shutdown_zcorner(test_parameters_t* test_parameters
+    )
+
+/*
+* description:
+*	shutdown zcorner 
+*
+******************************************************************************/
+{
+    /* functionality not implemented performs dummy return */
+    return TEST_PASSED;
+}
diff -uBbw -Nr ../zlib-1.2.8/deflate.c ./deflate.c
--- ../zlib-1.2.8/deflate.c	2013-04-28 23:57:10.000000000 +0100
+++ ./deflate.c	2016-09-08 14:54:39.969358000 +0100
@@ -51,6 +51,50 @@
 
 #include "deflate.h"
 
+
+/* QAT Hardware support */
+#include "qat_zlib.h"
+
+#define CHECK_VALID_WINDOW_BIT(num,pos) (((num) & (1<<(pos)))>>pos)
+/* Add -DQAT_TESTS_LOG to CFLAGS before ./configure to enable additional
+   debug logging to the ZLIB_QAT_LOG_FILE */
+#ifdef QAT_TESTS_LOG
+
+#define ZLIB_QAT_LOG_FILE "/opt/qat-zlib-deflate.log"
+
+#define ZLIB_INIT_QAT_LOG()                                             \
+do {                                                                    \
+  s->zlibQatLogger = fopen(ZLIB_QAT_LOG_FILE, "w");                     \
+  if (NULL == s->zlibQatLogger) {                                       \
+    sprintf(stderr, "ERROR, unable to open %s \n", ZLIB_QAT_LOG_FILE);  \
+    exit(1);                                                            \
+  }                                                                     \
+} while(0)
+
+#define ZLIB_CLOSE_QAT_LOG()        \
+do {                                \
+    if (s->zlibQatLogger != NULL) { \
+        fclose(s->zlibQatLogger);   \
+	}                               \
+} while(0)
+	
+#define ZLIB_QAT_LOG(...)                        \
+do {                                             \
+    if (s->zlibQatLogger != NULL) {              \
+        fprintf (s->zlibQatLogger, __VA_ARGS__); \
+        fflush(s->zlibQatLogger);                \
+    }                                            \
+} while(0)
+
+#else
+
+#define ZLIB_QAT_LOG(...)
+#define ZLIB_CLOSE_QAT_LOG()
+#define ZLIB_INIT_QAT_LOG()
+
+#endif
+
+
 const char deflate_copyright[] =
    " deflate 1.2.8 Copyright 1995-2013 Jean-loup Gailly and Mark Adler ";
 /*
@@ -96,7 +140,33 @@
 local  void check_match OF((deflate_state *s, IPos start, IPos match,
                             int length));
 #endif
-
+local int  qatAdjustOutputBufferList OF((z_streamp strm));   
+local int  qatAddInputToBufferList OF((z_streamp strm, int flush));
+local int  qatResetInputBufferList OF((z_streamp strm));
+local int  qatResetOutputBufferList OF((z_streamp strm));
+local int  qatCopyOutputFromBufferList OF((z_streamp strm, int flush));
+local int  qatCopyOutputFromFooterBuffer OF((z_streamp strm));
+local int  qatGenerateHeader OF((z_streamp strm));
+local int  qatGenerateFooter OF((z_streamp strm));
+local int  qatGenerateZeroByteFile OF((z_streamp strm));
+local int  qatSendCompressionRequest OF((z_streamp strm, int flush));
+local int  qatDeflateCleanup OF((z_streamp strm));
+local int  qatDeflateInit2 OF((z_streamp strm, int level, int method, int windowBits, 
+                               int memLevel, int strategy, const char* version, 
+						       int stream_size));
+local int  qatDeflateSetDictionary OF((z_streamp strm, const Bytef *dictionary, 
+                                       uInt dictLength));
+local int  qatDeflateResetKeep OF((z_streamp strm));
+local int  qatDeflateReset OF((z_streamp strm));
+local int  qatDeflateSetHeader OF((z_streamp strm, gz_headerp head));
+local int  qatDeflatePending OF((z_streamp strm, unsigned* pending, int* bits));
+local int  qatDeflatePrime OF((z_streamp strm, int bits, int value));
+local int  qatDeflateParams OF((z_streamp strm, int level, int strategy));
+local int  qatDeflateTune OF((z_streamp strm, int good_length, int max_lazy, 
+                              int nice_length, int max_chain));
+local int  qatDeflate OF((z_streamp strm, int flush));
+local int  qatDeflateEnd OF((z_streamp strm));
+local int  qatDeflateCopy OF((z_streamp dest, z_streamp source));
 /* ===========================================================================
  * Local data
  */
@@ -221,6 +291,11 @@
     const char *version;
     int stream_size;
 {
+    if ((qatIsHardwareCompressionEnabled()) && (0 != level)) {
+        return qatDeflateInit2(strm, level, method, windowBits, memLevel, strategy,
+                               version, stream_size);
+    }
+	
     deflate_state *s;
     int wrap = 1;
     static const char my_version[] = ZLIB_VERSION;
@@ -316,10 +391,304 @@
     s->strategy = strategy;
     s->method = (Byte)method;
 
+    /* extra QAT setting to force use Software compression 
+       currently important if compression level 0
+       (no compression) is selected */
+    s->useSoftCompForThisStream = 1;
+
     return deflateReset(strm);
 }
 
 /* ========================================================================= */
+int qatDeflateInit2(strm, level, method, windowBits, memLevel, strategy,
+                  version, stream_size)
+    z_streamp strm;
+    int  level;
+    int  method;
+    int  windowBits;
+    int  memLevel;
+    int  strategy;
+    const char *version;
+    int stream_size;
+{
+    deflate_state *s = NULL;
+    static const char my_version[] = ZLIB_VERSION;
+
+    /* QAT specific variables and code. */
+    Cpa32U sessSize            = 0;
+    CpaStatus rc               = CPA_STATUS_SUCCESS;
+    int numOfFlatBuffers       = 0;
+    Cpa32U metaSize            = 1;
+    CpaDcInstanceCapabilities cap = {0};
+
+    if (version == Z_NULL || version[0] != my_version[0] ||
+       stream_size != sizeof(z_stream)) {
+       return Z_VERSION_ERROR;
+    }
+    if (strm == Z_NULL) return Z_STREAM_ERROR;
+
+    strm->msg = Z_NULL;
+    if (strm->zalloc == (alloc_func)0) {
+#ifdef Z_SOLO
+        return Z_STREAM_ERROR;
+#else
+        strm->zalloc = zcalloc;
+        strm->opaque = (voidpf)0;
+#endif
+    }
+    if (strm->zfree == (free_func)0)
+#ifdef Z_SOLO
+        return Z_STREAM_ERROR;
+#else
+        strm->zfree = zcfree;
+#endif
+
+    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
+    if (s == Z_NULL) return Z_MEM_ERROR;
+
+    ZLIB_INIT_QAT_LOG();
+    
+    strm->state = s;
+    s->strm     = strm;
+    s->instHandle = NULL;
+    s->useSoftCompForThisStream = 0;
+    s->sessionStarted = 0;
+    s->contextSize = 0;
+    s->footerFlatBuffer.pData = (Cpa8U *) ZALLOC(strm, 1, QAT_DC_GZIP_FOOTER_SIZE);
+    if (NULL == s->footerFlatBuffer.pData) {
+        fprintf(stderr, "ZALLOC() failed for s->footerFlatBuffer.pData\n");
+        goto qat_err;
+    }
+    s->footerFlatBuffer.dataLenInBytes = QAT_DC_GZIP_FOOTER_SIZE;
+    s->footerBufferPosition = s->footerFlatBuffer.pData;
+    s->footerBufferBytesRemaining = 0;
+
+    if ( level >= CPA_DC_L1 && level <= CPA_DC_L9 ) {
+        s->sd.compLevel         = (CpaDcCompLvl)level;
+    }
+    else {
+        s->sd.compLevel         = CPA_DC_L7;
+    }
+#ifdef FASTEST
+    s->sd.compLevel                 = CPA_DC_L1;
+#endif
+    s->instHandle = qatIncrementCurrentInstance();
+    if (NULL == s->instHandle) {
+        fprintf(stderr, "Error: No instances available\n");
+        goto qat_err;
+    }
+    rc=cpaDcQueryCapabilities(s->instHandle, &cap);
+    if(CPA_STATUS_SUCCESS != rc){
+        fprintf(stderr, "cpaDcQueryCapabilities failed. rc = %d\n", rc);
+        goto qat_err;
+    }
+    /*Bits set to '1' for each valid window size supported by the decompression
+      implementation. For example for DH895XCC, the returned value of
+      validWindowSizeMaskCompression is 160 i.e. 10100000. Hence window
+      size 5 and 7 are supported */
+    if(CHECK_VALID_WINDOW_BIT(cap.validWindowSizeMaskCompression,QAT_8K_WIN_SIZE) !=0){
+        QATDEBUG(" Driver support Window size 5\n");
+    }
+    if(CHECK_VALID_WINDOW_BIT(cap.validWindowSizeMaskCompression,QAT_16K_WIN_SIZE) !=0){
+        QATDEBUG(" Driver support Window size 6\n");
+    }
+    if(CHECK_VALID_WINDOW_BIT(cap.validWindowSizeMaskCompression,QAT_32K_WIN_SIZE) !=0){
+        QATDEBUG(" Driver support Window size 7\n");
+    }
+
+    /* Set up the DC SessionSetupData */
+    s->sd.compType                  = CPA_DC_DEFLATE;
+    s->sd.huffType                  = CPA_DC_HT_FULL_DYNAMIC;
+    s->sd.fileType                  = CPA_DC_FT_OTHER;
+    s->sd.sessDirection             = CPA_DC_DIR_COMPRESS;
+    s->sd.autoSelectBestHuffmanTree = CPA_DC_ASB_UNCOMP_STATIC_DYNAMIC_WITH_STORED_HDRS;
+    s->sd.sessState                 = CPA_DC_STATEFUL;
+    s->sd.deflateWindowSize         = QAT_32K_WIN_SIZE;
+    s->sd.checksum                  = CPA_DC_ADLER32;
+
+    s->wrap             = 1;
+    s->res.checksum     = 1;
+
+    if (windowBits < 0) { /* suppress zlib wrapper */
+        s->sd.checksum = CPA_DC_CRC32;
+        s->res.checksum = 0;
+        s->wrap = 0;
+        windowBits = -windowBits;
+    }
+#ifdef GZIP
+    else if (windowBits > 15) {
+        s->sd.checksum = CPA_DC_CRC32;
+        s->res.checksum = 0;
+        s->wrap = 2;       /* write gzip wrapper instead */
+        windowBits -= 16;
+    }
+#endif
+    s->sd.deflateWindowSize         = windowBits - 8;
+    /*If not Valid Window size, then throw error */
+    if (!(CHECK_VALID_WINDOW_BIT(cap.validWindowSizeMaskCompression, QAT_8K_WIN_SIZE)
+        && (s->sd.deflateWindowSize == QAT_8K_WIN_SIZE)) 
+        && !(CHECK_VALID_WINDOW_BIT(cap.validWindowSizeMaskCompression, QAT_16K_WIN_SIZE)
+        && (s->sd.deflateWindowSize == QAT_16K_WIN_SIZE)) 
+        && !(CHECK_VALID_WINDOW_BIT(cap.validWindowSizeMaskCompression, QAT_32K_WIN_SIZE)
+        && (s->sd.deflateWindowSize == QAT_32K_WIN_SIZE))) {
+            fprintf(stderr, "Error: zlib window size: %d is not supported by hardware acceleration\n", windowBits); 
+            goto qat_err;
+    }
+    s->nodeId = qatGetNodeId(s->instHandle);
+    s->qatDriverType=qatGetInstanceDriverType(s->instHandle);
+    s->numBytesLeftToCopy = 0;
+    s->positionInOutputBuffer = 0;
+    s->totalBytesPlacedInInputBuffer = 0;
+
+    /* Set s->totalBuffersize which is the size of each CpaFlatBuffer that makes
+       up our input CpaBufferList. By setting the input buffers to 
+       take QAT_ZLIB_COMPRESSION_OVERHEAD bytes away from 
+       QAT_ZLIB_INTERNAL_FLATBUFFER_SIZE and then multiply by 8 and
+       divide by 9. Then set our output CpaFlatBuffers to be
+       QAT_ZLIB_INTERNAL_FLATBUFFER_SIZE allows us to guarantee
+       that we will not experience overflow even when submitting
+       data that won't compress and will actually expand slightly. */ 
+    s->totalBuffersize = ((QAT_ZLIB_INTERNAL_FLATBUFFER_SIZE - 
+                           QAT_ZLIB_COMPRESSION_OVERHEAD) * 8) / 9; 
+	
+    /* Get the DC session size */
+    rc = cpaDcGetSessionSize(s->instHandle, &(s->sd), &sessSize, &s->contextSize );
+    if(CPA_STATUS_SUCCESS != rc) {
+        fprintf(stderr, "cpaDcGetSessionSize failed. rc = %d\n", rc);
+        goto qat_err;
+    }
+
+    s->contextBuffList.pPrivateMetaData = NULL;
+    s->contextBuffList.pBuffers = NULL;
+
+    if (s->contextSize > 0) {
+        /* Get the size of the Private meta data needed to create Buffer List */
+        rc = cpaDcBufferListGetMetaSize(s->instHandle, 1, &metaSize);
+        if(CPA_STATUS_SUCCESS != rc ) {
+            fprintf(stderr, "cpaDcBufferListGetMetaSize failed. rc = %d\n", rc);
+            goto qat_err;
+        }
+
+        /* Allocate the memory for the private metadata */
+        s->contextBuffList.pPrivateMetaData = qaeZlibPinnedMemAlloc(metaSize, s->nodeId, __FILE__, __LINE__);
+        if(NULL == s->contextBuffList.pPrivateMetaData) {
+            fprintf(stderr, "Failed to allocate memory for pPrivateMetaData\n");
+            goto qat_err;
+        }
+
+        /* Allocate flat buffers */
+        s->contextBuffList.numBuffers = 1;
+        s->contextBuffList.pBuffers = &(s->contextFlatBuffer);
+        if (NULL == s->contextBuffList.pBuffers) {
+            fprintf(stderr, "s->ContextBuffList.pBuffers is not valid\n");
+            goto qat_err;
+        }
+
+        s->contextBuffList.pBuffers->pData =  qaeZlibPinnedMemAlloc(s->contextSize, s->nodeId, __FILE__, __LINE__);
+        if (NULL == s->contextBuffList.pBuffers->pData) {
+            fprintf(stderr, "qaeZlibPinnedMemAlloc() failed for s->contextBuffList.pBuffers->pData\n");
+            goto qat_err;
+        }
+
+        s->contextBuffList.pBuffers->dataLenInBytes = s->contextSize;
+    }
+
+    /* Set up output buffer list */
+    /* For compression we only need the same amount of output buffers as input buffers */
+    s->totalNumOfOutputBuffers = QAT_ZLIB_NUM_INPUT_FLAT_BUFFERS; 
+    s->outl.numBuffers         = s->totalNumOfOutputBuffers;
+    s->outl.pBuffers           = s->out;
+    s->outl.pUserData          = NULL;
+    /* Get the size of the Private meta data needed to create Buffer List */
+    rc = cpaDcBufferListGetMetaSize(s->instHandle, s->totalNumOfOutputBuffers, &metaSize);
+    if(CPA_STATUS_SUCCESS != rc ) {
+        fprintf(stderr, "cpaDcBufferListGetMetaSize failed. rc = %d\n", rc);
+        goto qat_err;
+    }
+    s->outl.pPrivateMetaData = qaeZlibPinnedMemAlloc(metaSize, s->nodeId, __FILE__, __LINE__);
+    if (NULL == s->outl.pPrivateMetaData) {
+        fprintf(stderr, "qaeZlibPinnedMemAlloc() failed for s->outl.pPrivateMetaData\n");
+        goto qat_err;
+    }
+
+    /* Set up input buffer list */
+    s->totalNumOfInputBuffers = QAT_ZLIB_NUM_INPUT_FLAT_BUFFERS;
+    s->inl.numBuffers         = s->totalNumOfInputBuffers;
+    s->inl.pBuffers           = s->in;
+    s->inl.pUserData          = NULL;
+    /* Get the size of the Private meta data needed to create Buffer List */
+    rc = cpaDcBufferListGetMetaSize(s->instHandle, s->totalNumOfInputBuffers, &metaSize);
+    if(CPA_STATUS_SUCCESS != rc ) {
+        fprintf(stderr, "cpaDcBufferListGetMetaSize failed. rc = %d\n", rc);
+        goto qat_err;
+    }
+    s->inl.pPrivateMetaData = qaeZlibPinnedMemAlloc(metaSize, s->nodeId, __FILE__, __LINE__);
+    if (NULL == s->inl.pPrivateMetaData) {
+        fprintf(stderr, "qaeZlibPinnedMemAlloc() failed for s->inl.pPrivateMetaData\n");
+        goto qat_err;
+    }
+
+    /* Set up the output buffer */
+    s->out = (CpaFlatBuffer *)ZALLOC(strm, 1, sizeof(CpaFlatBuffer) * (s->totalNumOfOutputBuffers));
+    s->currentOutputBuffer = s->out;
+    if (NULL == s->out) {
+        fprintf(stderr, "ZALLOC() failed for s->out\n");
+        goto qat_err;
+    }
+    for(numOfFlatBuffers = 0; numOfFlatBuffers < s->totalNumOfOutputBuffers; 
+        numOfFlatBuffers++) {
+       s->currentOutputBuffer->pData = (Cpa8U *) qaeZlibPinnedMemAlloc(QAT_ZLIB_INTERNAL_FLATBUFFER_SIZE,
+                                                                   s->nodeId, __FILE__, __LINE__);
+       if (NULL == s->currentOutputBuffer->pData) {
+           fprintf(stderr, "qaeZlibPinnedMemAlloc() failed for s->in\n");
+           goto qat_err;
+       }
+       s->currentOutputBuffer->dataLenInBytes = QAT_ZLIB_INTERNAL_FLATBUFFER_SIZE;
+       s->currentOutputBuffer++;
+    }
+
+    s->currentOutputBuffer = s->out;
+
+    /* Set up the input buffer */
+    s->in = (CpaFlatBuffer *)ZALLOC(strm, 1, sizeof(CpaFlatBuffer) * (s->totalNumOfInputBuffers));
+    s->currentInputBuffer = s->in;
+    if (NULL == s->in) {
+        fprintf(stderr, "ZALLOC() failed for s->in\n");
+        goto qat_err;
+    }
+    for(numOfFlatBuffers = 0; numOfFlatBuffers < s->totalNumOfInputBuffers; 
+        numOfFlatBuffers++) {
+       s->currentInputBuffer->pData = (Cpa8U *) qaeZlibPinnedMemAlloc(s->totalBuffersize, s->nodeId, __FILE__, __LINE__);
+       if (NULL == s->currentInputBuffer->pData) {
+           fprintf(stderr, "qaeZlibPinnedMemAlloc() failed for s->in\n");
+           goto qat_err;
+       }
+       s->currentInputBuffer->dataLenInBytes = 0;
+       s->currentInputBuffer++;
+    }
+    s->currentInputBuffer = s->in;
+    s->fullInputBuffers = 0;
+  
+    s->inl.pBuffers = s->in;
+    s->outl.pBuffers = s->out;
+	
+     /* Get the session handle */
+    s->session = (CpaDcSessionHandle) qaeZlibPinnedMemAlloc(sessSize, s->nodeId, __FILE__, __LINE__);
+    if (NULL == s->session) {
+       fprintf(stderr, "qaeZlibPinnedMemAlloc() failed for s->session\n");
+       goto qat_err;
+    }
+
+    return deflateReset(strm);
+
+qat_err:
+
+    qatDeflateCleanup(strm);
+
+    return Z_MEM_ERROR;
+}
+
+/* ========================================================================= */
 int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
     z_streamp strm;
     const Bytef *dictionary;
@@ -333,7 +702,12 @@
 
     if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL)
         return Z_STREAM_ERROR;
-    s = strm->state;
+
+    s = (deflate_state *)strm->state;
+    if (qatIsHardwareCompressionEnabled() && !s->useSoftCompForThisStream) {
+        return qatDeflateSetDictionary(strm, dictionary, dictLength);
+    }
+
     wrap = s->wrap;
     if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)
         return Z_STREAM_ERROR;
@@ -389,6 +763,16 @@
 }
 
 /* ========================================================================= */
+int qatDeflateSetDictionary (strm, dictionary, dictLength)
+    z_streamp strm;
+    const Bytef *dictionary;
+    uInt  dictLength;
+{
+    /* not supported when using hardware acceleration */
+    return Z_OK;
+}
+
+/* ========================================================================= */
 int ZEXPORT deflateResetKeep (strm)
     z_streamp strm;
 {
@@ -398,12 +782,15 @@
         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {
         return Z_STREAM_ERROR;
     }
+    s = (deflate_state *)strm->state;
+    if (qatIsHardwareCompressionEnabled() && !s->useSoftCompForThisStream) {
+        return qatDeflateResetKeep(strm);
+    }	
 
     strm->total_in = strm->total_out = 0;
     strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
     strm->data_type = Z_UNKNOWN;
 
-    s = (deflate_state *)strm->state;
     s->pending = 0;
     s->pending_out = s->pending_buf;
 
@@ -424,9 +811,134 @@
 }
 
 /* ========================================================================= */
+int qatDeflateResetKeep (strm)
+    z_streamp strm;
+{
+    deflate_state *s = NULL;
+    CpaStatus rc = CPA_STATUS_FAIL;
+    int retryCountDeflate = 0;
+    if (strm == Z_NULL || strm->state == Z_NULL  ) {
+        return Z_STREAM_ERROR;
+    }
+
+    strm->total_in = strm->total_out = 0;
+    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
+    strm->data_type = Z_UNKNOWN;
+
+    s = (deflate_state *)strm->state;
+    s->status = INIT_STATE;
+    s->qatState = QAT_DEF_STATE_INIT;
+    strm->adler = 0;
+    if (1 == s->wrap) {
+        s->res.checksum = 1;
+    }
+    else {
+        s->res.checksum = 0;
+    }    
+    s->last_flush = Z_NO_FLUSH;
+    s->adjustIntBuffersToMatchExtBuffers = 0;
+    s->totalBytesPlacedInInputBuffer = 0;
+    qatResetInputBufferList(strm);
+    qatResetOutputBufferList(strm);
+    if (NULL != s->footerFlatBuffer.pData) {
+        s->footerFlatBuffer.dataLenInBytes = QAT_DC_GZIP_FOOTER_SIZE; 
+        s->footerBufferPosition = s->footerFlatBuffer.pData;
+        s->footerBufferBytesRemaining = 0;
+    }
+    /* Session Reuse functionaility is only for QAT 1.6 but not supported for QAT1.5*/
+    if(QAT_DRIVER_TYPE_1_5 == s->qatDriverType){
+        /* Close the session if one exists */
+        if (s->sessionStarted) {
+            if (NULL != s->instHandle)
+                rc = cpaDcRemoveSession(s->instHandle, s->session);
+            s->sessionStarted = 0;
+        }
+        rc = CPA_STATUS_FAIL;
+        /* Initialise the DC session */
+        if (s->instHandle && s->session) {
+            if (s->contextSize > 0 ) {
+                 if ( s->contextBuffList.pBuffers->pData) {
+                    rc = cpaDcInitSession( s->instHandle, s->session, &(s->sd), 
+                                      &(s->contextBuffList), qat_callbackFn );
+                 } 
+            }
+            else
+            {
+                rc = cpaDcInitSession( s->instHandle, s->session, &(s->sd), 
+                                    NULL, qat_callbackFn);
+            }    
+        }
+        if(CPA_STATUS_SUCCESS != rc) {
+            fprintf(stderr, "cpaDcInitSession failed or parameters invalid. rc = %d\n", rc);
+            return Z_STREAM_ERROR;
+        }
+        s->sessionStarted = 1;
+    }        
+    else
+    {
+        if(s->sessionStarted){
+            if(NULL != s->instHandle){
+            /* Call the Session reset functionailty */
+                do{
+                    rc = cpaDcResetSession(s->instHandle, s->session);
+                    if( CPA_STATUS_RETRY == rc){
+                        retryCountDeflate++;
+                         /* backoff for retry_count % QAT_RETRY_BACKOFF_MODULO_DIVISOR seconds before we retry */
+                        sleep(retryCountDeflate % QAT_RETRY_BACKOFF_MODULO_DIVISOR);
+                    }
+                }while((CPA_STATUS_RETRY == rc) && 
+                      ((retryCountDeflate <= qatGetMaxNumRetries()) ||
+                      (Z_QAT_INFINITE_MAX_NUM_RETRIES == qatGetMaxNumRetries())));
+                 
+                s->res.checksum = 0;
+                /* If we gave up retrying report an error */
+                if(CPA_STATUS_RETRY == rc){
+                    fprintf(stderr," cpaDcResetSession failed. rc = %d",rc);
+                    /* Not Cleaning Memory here as it is very unlikely to get failure from reset as we are synchronous based
+                     * In upstreamed Zlib, memory is not freed in case of failure of deflateReset */
+                    s->sessionStarted = 0;
+                    return Z_STREAM_ERROR;
+                }
+            }
+        }
+        else{
+            rc = CPA_STATUS_FAIL;
+            /* Initialise the DC session */
+                if (s->instHandle && s->session) {
+                    if (s->contextSize > 0 ) {
+                        if ( s->contextBuffList.pBuffers->pData) {
+                            rc = cpaDcInitSession( s->instHandle, s->session, &(s->sd),
+                                              &(s->contextBuffList), qat_callbackFn );
+                         }
+                    }
+                    else
+                    {
+                        rc = cpaDcInitSession( s->instHandle, s->session, &(s->sd),
+                                            NULL, qat_callbackFn);
+                    }
+                }
+                if(CPA_STATUS_SUCCESS != rc) {
+                    fprintf(stderr, "cpaDcInitSession failed or parameters invalid. rc = %d\n", rc);
+                    return Z_STREAM_ERROR;
+                }   
+            s->sessionStarted = 1;        
+        }
+    }
+    return Z_OK;
+
+}
+
+/* ========================================================================= */
 int ZEXPORT deflateReset (strm)
     z_streamp strm;
 {
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    deflate_state *s;
+    s = (deflate_state *)strm->state;
+    if (qatIsHardwareCompressionEnabled() && !s->useSoftCompForThisStream) {
+        return qatDeflateReset(strm);
+    }			
+	
     int ret;
 
     ret = deflateResetKeep(strm);
@@ -436,23 +948,52 @@
 }
 
 /* ========================================================================= */
+int qatDeflateReset (strm)
+    z_streamp strm;
+{
+    return deflateResetKeep(strm);
+}
+
+
+/* ========================================================================= */
 int ZEXPORT deflateSetHeader (strm, head)
     z_streamp strm;
     gz_headerp head;
 {
     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    deflate_state *s;
+    s = (deflate_state *)strm->state;
+    if (qatIsHardwareCompressionEnabled() && !s->useSoftCompForThisStream) {
+        return qatDeflateSetHeader(strm, head);
+    }			
+	
     if (strm->state->wrap != 2) return Z_STREAM_ERROR;
     strm->state->gzhead = head;
     return Z_OK;
 }
 
 /* ========================================================================= */
+int qatDeflateSetHeader (strm, head)
+    z_streamp strm;
+    gz_headerp head;
+{
+    /* not supported when using hardware acceleration */
+    return Z_OK;
+}
+
+/* ========================================================================= */
 int ZEXPORT deflatePending (strm, pending, bits)
     unsigned *pending;
     int *bits;
     z_streamp strm;
 {
     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    deflate_state *s;
+    s = (deflate_state *)strm->state;
+    if (qatIsHardwareCompressionEnabled() && !s->useSoftCompForThisStream) {
+        return qatDeflatePending(strm, pending, bits);
+    }	
+	
     if (pending != Z_NULL)
         *pending = strm->state->pending;
     if (bits != Z_NULL)
@@ -461,6 +1002,16 @@
 }
 
 /* ========================================================================= */
+int qatDeflatePending (strm, pending, bits)
+    unsigned *pending;
+    int *bits;
+    z_streamp strm;
+{
+    /* not supported when using hardware acceleration */
+    return Z_OK;
+}
+
+/* ========================================================================= */
 int ZEXPORT deflatePrime (strm, bits, value)
     z_streamp strm;
     int bits;
@@ -470,7 +1021,10 @@
     int put;
 
     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    s = strm->state;
+    s = (deflate_state *)strm->state;
+    if (qatIsHardwareCompressionEnabled() && !s->useSoftCompForThisStream) {
+        return qatDeflatePrime(strm, bits, value);
+    }	
     if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))
         return Z_BUF_ERROR;
     do {
@@ -487,6 +1041,16 @@
 }
 
 /* ========================================================================= */
+int qatDeflatePrime (strm, bits, value)
+    z_streamp strm;
+    int bits;
+    int value;
+{
+    /* not supported when using hardware acceleration */
+    return Z_OK;
+}
+
+/* ========================================================================= */
 int ZEXPORT deflateParams(strm, level, strategy)
     z_streamp strm;
     int level;
@@ -497,8 +1061,10 @@
     int err = Z_OK;
 
     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    s = strm->state;
-
+    s = (deflate_state *)strm->state;
+    if (qatIsHardwareCompressionEnabled() && !s->useSoftCompForThisStream) {
+        return qatDeflateParams(strm, level, strategy);
+    }
 #ifdef FASTEST
     if (level != 0) level = 1;
 #else
@@ -528,6 +1094,16 @@
 }
 
 /* ========================================================================= */
+int qatDeflateParams(strm, level, strategy)
+    z_streamp strm;
+    int level;
+    int strategy;
+{
+    /* not supported when using hardware acceleration */
+    return Z_OK;
+}
+
+/* ========================================================================= */
 int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)
     z_streamp strm;
     int good_length;
@@ -538,7 +1114,10 @@
     deflate_state *s;
 
     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    s = strm->state;
+    s = (deflate_state *)strm->state;
+    if (qatIsHardwareCompressionEnabled() && !s->useSoftCompForThisStream) {
+       return qatDeflateTune(strm, good_length, max_lazy, nice_length, max_chain);
+    }	
     s->good_match = good_length;
     s->max_lazy_match = max_lazy;
     s->nice_match = nice_length;
@@ -546,6 +1125,18 @@
     return Z_OK;
 }
 
+/* ========================================================================= */
+int qatDeflateTune(strm, good_length, max_lazy, nice_length, max_chain)
+    z_streamp strm;
+    int good_length;
+    int max_lazy;
+    int nice_length;
+    int max_chain;
+{
+    /* not supported when using hardware acceleration */
+    return Z_OK;
+}
+
 /* =========================================================================
  * For the default windowBits of 15 and memLevel of 8, this function returns
  * a close to exact, as well as small, upper bound on the compressed size.
@@ -662,6 +1253,377 @@
 }
 
 /* ========================================================================= */
+local int qatAddInputToBufferList (strm, flush)
+    z_streamp strm;
+    int flush;
+{
+    deflate_state *s = NULL;
+    uInt avail_in = 0;
+    Bytef * next_in = NULL;
+    uLong total_in = 0;
+    
+    s = strm->state;
+
+    /* For a Z_SYNC_FLUSH we don't want to update strm->avail_in, strm->next_in
+       or strm->total_in as due to the possibility of overflow this will be done 
+       after a compression operation. To keep the logic below a bit simpler we will
+       just backup the values here and then restore them before we return. */
+    if (s->adjustIntBuffersToMatchExtBuffers) {
+        avail_in = strm->avail_in;
+        next_in = strm->next_in;
+        total_in = strm->total_in;
+    }  
+
+    /* If we get called with zero bytes of input but the final block then we need to
+       sort out the number of buffers ready to submit the compression request.
+       This is because we may already have data in the pinned input buffers that hasn't
+       been submitted yet */
+    if (0 == strm->avail_in && Z_FINISH == flush) {
+        s->fullInputBuffers++;
+        s->inl.numBuffers = s->fullInputBuffers;
+    }    
+    
+    /* Keep copying input while there are flatbuffers available to copy into and there are
+       bytes to copy */
+    while ((s->fullInputBuffers < s->totalNumOfInputBuffers) && (strm->avail_in > 0)) {
+          /* Is there room in the current flatbuffer for all the input data */
+          if ((s->totalBuffersize - s->currentInputBuffer->dataLenInBytes) >= strm->avail_in) {
+             /* Yes there is so lets copy all the data in and update counters and pointers*/
+             memcpy(s->currentInputBuffer->pData+s->currentInputBuffer->dataLenInBytes,
+                    strm->next_in, strm->avail_in);
+             s->currentInputBuffer->dataLenInBytes+= strm->avail_in;            
+             strm->total_in += strm->avail_in;
+             s->totalBytesPlacedInInputBuffer += strm->avail_in;
+             strm->next_in += strm->avail_in;
+             strm->avail_in = 0;
+             /* If this is the last data block then there will be no more input so lets tidy
+                our number of buffers ready to submit the compression request */
+             if (Z_FINISH == flush) {    
+                s->fullInputBuffers++;
+                s->inl.numBuffers = s->fullInputBuffers;
+             }
+          }
+          else {
+            /* No there wasn't room in the flatbuffer for all the input data so lets just copy
+               as much as we can into it, update the counters and pointers, and move onto the 
+               next flatbuffer */
+            memcpy(s->currentInputBuffer->pData+s->currentInputBuffer->dataLenInBytes,
+                   strm->next_in, s->totalBuffersize - s->currentInputBuffer->dataLenInBytes);
+            strm->avail_in -= (s->totalBuffersize - s->currentInputBuffer->dataLenInBytes);
+            strm->next_in += (s->totalBuffersize - s->currentInputBuffer->dataLenInBytes); 
+            strm->total_in += (s->totalBuffersize - s->currentInputBuffer->dataLenInBytes);
+            s->totalBytesPlacedInInputBuffer +=
+                           (s->totalBuffersize - s->currentInputBuffer->dataLenInBytes);
+            s->currentInputBuffer->dataLenInBytes = s->totalBuffersize;
+            s->fullInputBuffers++;
+            s->currentInputBuffer++;
+          } 
+
+    }
+
+    if (s->adjustIntBuffersToMatchExtBuffers) {
+        strm->avail_in = avail_in;
+        strm->next_in = next_in;
+        strm->total_in = total_in;
+    }  
+
+    return Z_OK;
+}
+    
+/* ========================================================================= */
+local int qatAdjustOutputBufferList (strm)
+      z_streamp strm;
+{
+    int numOfFlatBuffers = 0;
+    
+    deflate_state *s = NULL;
+    s = strm->state;
+    long unsigned totalOutputSpace = strm->avail_out;
+    s->currentOutputBuffer=s->out;
+    /* Ensure the dataLenInBytes field gets adjusted for each flatbuffer if needed.
+       We should end up with the same amount of buffer space as strm->avail_out */
+    for(numOfFlatBuffers = 0; numOfFlatBuffers < s->totalNumOfOutputBuffers; numOfFlatBuffers++) {
+       if (totalOutputSpace < s->currentOutputBuffer->dataLenInBytes) {
+           s->currentOutputBuffer->dataLenInBytes = totalOutputSpace;
+           totalOutputSpace = 0;
+       }
+       else {
+           totalOutputSpace -= s->currentOutputBuffer->dataLenInBytes;
+       }
+       s->currentOutputBuffer++;
+    }
+    s->currentOutputBuffer=s->out;
+    return Z_OK;
+}
+
+/* ========================================================================= */
+local int qatResetInputBufferList (strm)
+      z_streamp strm;
+{
+    int numOfFlatBuffers = 0;
+    deflate_state *s = NULL;
+    s = strm->state;
+    s->currentInputBuffer=s->in;
+    /* Ensure the dataLenInBytes field gets reset for each flatbuffer */
+    for(numOfFlatBuffers = 0; numOfFlatBuffers < s->totalNumOfInputBuffers; numOfFlatBuffers++) {
+       s->currentInputBuffer->dataLenInBytes=0;
+       s->currentInputBuffer++;
+    }
+    s->currentInputBuffer=s->in;
+    s->fullInputBuffers = 0;
+    s->totalBytesPlacedInInputBuffer = 0;
+    return Z_OK;
+}
+
+/* ========================================================================= */
+local int qatResetOutputBufferList (strm)
+      z_streamp strm;
+{
+    int numOfFlatBuffers = 0;
+    deflate_state *s = NULL;
+    s = strm->state;
+    s->currentOutputBuffer=s->out;
+    /* Ensure the dataLenInBytes field gets reset for each flatbuffer */
+    for(numOfFlatBuffers = 0; numOfFlatBuffers < s->totalNumOfOutputBuffers; numOfFlatBuffers++) {
+       s->currentOutputBuffer->dataLenInBytes=QAT_ZLIB_INTERNAL_FLATBUFFER_SIZE;
+       s->currentOutputBuffer++;
+    }
+    s->currentOutputBuffer=s->out;
+    s->numBytesLeftToCopy = 0;
+    s->positionInOutputBuffer = 0;
+    return Z_OK;
+}
+
+/* ========================================================================= */
+local int qatCopyOutputFromBufferList (strm, flush)
+      z_streamp strm;
+      int flush;
+{
+    int bytesToCopy = 0;
+    int bytesCopied = 0;
+    deflate_state *s = NULL;
+    s = strm->state;
+    /* Keep copying output while there are bytes to copy and there is room in the output buffer */
+    while (s->numBytesLeftToCopy && strm->avail_out) {
+         bytesToCopy = ((s->numBytesLeftToCopy < 
+                       ((s->currentOutputBuffer->dataLenInBytes) - (s->positionInOutputBuffer))) ?
+                       s->numBytesLeftToCopy :
+                       ((s->currentOutputBuffer->dataLenInBytes) - (s->positionInOutputBuffer)));
+         /* Check if we can fit the whole of what's left in the flatbuffer into the 
+            output buffer */
+         if (bytesToCopy > strm->avail_out) {
+             /* We can't so lets copy strm->avail bytes into the output buffer and
+                update all the counters and pointers */  
+             bytesCopied=0;  
+             memcpy(strm->next_out, (s->currentOutputBuffer->pData) + (s->positionInOutputBuffer),
+                    strm->avail_out);
+             bytesCopied = strm->avail_out;
+             s->positionInOutputBuffer += bytesCopied;
+             s->numBytesLeftToCopy -= bytesCopied;
+             strm->next_out+=bytesCopied;
+             strm->total_out+=bytesCopied;
+             strm->avail_out-=bytesCopied;
+         }
+         else {
+             /* We can fit all the bytes from the flatbuffer so lets just copy all (bytesToCopy)
+                into the output buffer and update all counters and pointers moving onto any
+                subsequent flatbuffer for next time round the loop */
+             memcpy(strm->next_out, (s->currentOutputBuffer->pData) + (s->positionInOutputBuffer), 
+                    bytesToCopy);
+             s->numBytesLeftToCopy -= bytesToCopy;
+             strm->next_out+=bytesToCopy;
+             strm->total_out+=bytesToCopy;
+             strm->avail_out-=bytesToCopy;
+             s->currentOutputBuffer++;
+             s->positionInOutputBuffer=0;
+         }
+    }
+    return Z_OK;
+}
+
+/* ========================================================================= */
+local int qatCopyOutputFromFooterBuffer (z_streamp strm)
+{
+    deflate_state *s = NULL;
+    s = strm->state;
+    if (s->footerBufferBytesRemaining) {
+        if (s->footerBufferBytesRemaining > strm->avail_out) {
+           memcpy(strm->next_out, s->footerBufferPosition, strm->avail_out);
+           s->footerBufferPosition += strm->avail_out;
+           s->footerBufferBytesRemaining -= strm->avail_out;
+           strm->next_out += strm->avail_out;
+           strm->total_out += strm->avail_out;
+           strm->avail_out = 0;
+        }
+        else {
+           memcpy(strm->next_out, s->footerBufferPosition, s->footerBufferBytesRemaining);
+           s->footerBufferPosition += s->footerBufferBytesRemaining;
+           strm->next_out += s->footerBufferBytesRemaining;
+           strm->total_out += s->footerBufferBytesRemaining;
+           strm->avail_out -= s->footerBufferBytesRemaining;
+           s->footerBufferBytesRemaining = 0;
+        }
+    }
+    return Z_OK;
+}
+
+/* ========================================================================= */
+local int qatGenerateHeader(z_streamp strm)
+{
+    CpaStatus rc;
+    Cpa32U cnt = 0;
+    deflate_state *s = NULL;
+    s = strm->state;
+    /* This call will generate either a zlib or gzip header depending
+       how the session was setup */
+    rc = cpaDcGenerateHeader( s->session, s->out, &cnt );
+    if (CPA_STATUS_SUCCESS != rc) {
+        fprintf(stderr, "cpaDcGenerateHeader failed, rc=%d\n", rc);
+        return Z_DATA_ERROR;
+    }
+    if (strm->avail_out < cnt) {
+        fprintf(stderr, "strm->avail_out is too small to write header to.\n");
+        return Z_DATA_ERROR;
+    }
+    /* Copy the header straight to the output buffer */
+    memcpy(strm->next_out, s->out->pData, cnt);
+
+    /* Update various counter/pointers */
+    strm->avail_out -= cnt;
+    strm->next_out  += cnt;
+    strm->total_out += cnt;
+    return Z_OK;
+}
+
+/* ========================================================================= */
+local int qatGenerateFooter(z_streamp strm)
+{
+    CpaStatus rc;
+    deflate_state *s = NULL;
+    s = strm->state;
+    s->res.produced=0;
+    s->res.consumed=0;
+    /* This call will generate either a zlib or gzip footer depending
+       how the session was setup */
+    rc = cpaDcGenerateFooter( s->session, &s->footerFlatBuffer, &s->res );
+    if (CPA_STATUS_SUCCESS != rc) {
+        fprintf(stderr, "cpaDcGenerateFooter failed, rc=%d\n", rc);
+        return Z_DATA_ERROR;
+    }
+    s->footerBufferBytesRemaining = s->res.produced;
+    
+    return Z_OK;
+}
+
+/* ========================================================================= */
+local int qatGenerateZeroByteFile(z_streamp strm)
+{
+    deflate_state *s = NULL;
+    s = strm->state;
+    if ( 1 == s->wrap || 2 == s->wrap) {
+    /* Generate the zlib/gzip header */
+        if (Z_OK != qatGenerateHeader(strm)) {
+            s->qatState = QAT_DEF_STATE_ERROR;
+            return Z_DATA_ERROR;
+        }
+    }
+    if (strm->avail_out >= 2) {
+        *strm->next_out = 0x03;
+        *(strm->next_out+1) = 0x00;
+        strm->next_out += 2;
+        strm->total_out += 2;
+        strm->avail_out -= 2;
+    }
+    else {
+        return Z_BUF_ERROR;
+    }
+
+    if (Z_OK != qatGenerateFooter(strm)) {
+        s->qatState = QAT_DEF_STATE_ERROR;
+        return Z_DATA_ERROR;
+    }
+    qatCopyOutputFromFooterBuffer(strm);
+    s->qatState = QAT_DEF_STATE_FINISHED;
+    
+    if (!s->footerBufferBytesRemaining) {    
+        return Z_STREAM_END;
+    }
+    
+    return Z_OK;
+}
+
+/* ======================================================================= */
+local int qatSendCompressionRequest(strm, flush)
+    z_streamp strm;
+    int flush;
+{
+    CpaStatus rc;
+    struct op_done opDone;
+    int retry_count = 0;
+    CpaDcFlush flushType = CPA_DC_FLUSH_SYNC;
+    deflate_state *s = NULL;
+    s = strm->state;
+    /* Set the flush flag. For stateful we only support two flags. 
+       Set CPA_DC_FLUSH_SYNC if it is not the last block of data to 
+       cpaDcCompressData. Set CPA_DC_FLUSH_FINAL if we have been told
+       it's the last data block (Z_FINISH has been set) and we have 
+       read all the input buffer into the pinned memory buffer. */
+    if ((Z_FINISH == flush) && (0 == strm->avail_in)) {
+        QATDEBUG("Setting CPA_DC_FLUSH_FINAL\n");
+        flushType = CPA_DC_FLUSH_FINAL;
+    } 
+   
+    if ((Z_FINISH == flush) && (s->adjustIntBuffersToMatchExtBuffers) && 
+        (strm->avail_in <= s->totalBytesPlacedInInputBuffer)) {
+        QATDEBUG("Setting CPA_DC_FLUSH_FINAL\n");
+        flushType = CPA_DC_FLUSH_FINAL;
+    }
+
+    qatInitOpDone(&opDone);
+
+    do { 
+        /* Make the QAT call to compress */
+        rc = cpaDcCompressData(
+             s->instHandle,
+             s->session,
+             &s->inl,
+             &s->outl,
+             &s->res,
+             flushType,
+             &opDone );
+
+        /* Deal with any errors */
+        if ( CPA_STATUS_RETRY == rc ) {
+            retry_count++;
+            /* backoff for retry_count % QAT_RETRY_BACKOFF_MODULO_DIVISOR seconds before we retry */
+            sleep(retry_count % QAT_RETRY_BACKOFF_MODULO_DIVISOR);
+        }
+        else if ( CPA_STATUS_SUCCESS != rc ) {
+            fprintf(stderr, "Data compression unsuccessful, status %d\n", rc);
+            qatCleanupOpDone(&opDone);
+            return Z_DATA_ERROR;
+        }
+
+    } while ((CPA_STATUS_RETRY == rc) && 
+             ((retry_count <= qatGetMaxNumRetries()) ||
+             (Z_QAT_INFINITE_MAX_NUM_RETRIES == qatGetMaxNumRetries())));
+
+    /* If we gave up retrying report an error */
+    if ( CPA_STATUS_RETRY == rc)
+    {
+        fprintf(stderr, "QAT Driver is too busy, retries exhausted, giving up\n");
+        qatCleanupOpDone(&opDone);
+        return Z_DATA_ERROR;
+    }
+
+    /* Wait for cpaDcCompressData to complete */
+    qatWaitForOpToComplete(&opDone);
+    qatCleanupOpDone(&opDone);
+    
+    return Z_OK;
+}
+    
+/* ========================================================================= */
 int ZEXPORT deflate (strm, flush)
     z_streamp strm;
     int flush;
@@ -673,7 +1635,10 @@
         flush > Z_BLOCK || flush < 0) {
         return Z_STREAM_ERROR;
     }
-    s = strm->state;
+    s = (deflate_state *)strm->state;
+    if (qatIsHardwareCompressionEnabled() && !s->useSoftCompForThisStream) {
+        return qatDeflate(strm, flush);
+    }			
 
     if (strm->next_out == Z_NULL ||
         (strm->next_in == Z_NULL && strm->avail_in != 0) ||
@@ -976,13 +1941,234 @@
 }
 
 /* ========================================================================= */
+int qatDeflate (strm, flush)
+    z_streamp strm;
+    int flush;
+{
+    deflate_state *s = NULL;
+    int rc = Z_OK;
+
+    if (strm == Z_NULL || strm->state == Z_NULL ||
+        flush > Z_BLOCK || flush < 0) {
+        return Z_STREAM_ERROR;
+    }
+    s = strm->state;
+	
+	ZLIB_QAT_LOG("DEFLATE\n");
+	
+    if (strm->next_out == Z_NULL ||
+       (strm->next_in == Z_NULL && strm->avail_in != 0)) {
+        return Z_STREAM_ERROR;
+    }
+
+    if (Z_FINISH != flush && 0 == strm->avail_in) {
+        return Z_BUF_ERROR;
+    }
+    
+    if (0 == strm->avail_out) return Z_BUF_ERROR;
+    s->strm = strm; /* just in case */
+    s->last_flush = flush;
+    
+    QATDEBUG("*** qatDeflate ***\n");
+    QATDEBUG("s->numBytesLeftToCopy = %d\n", s->numBytesLeftToCopy);
+    QATDEBUG("strm->avail_in = %d\n", strm->avail_in);
+    QATDEBUG("strm->avail_out = %d\n", strm->avail_out);
+    QATDEBUG("strm->total_in = %ld\n", strm->total_in);
+    QATDEBUG("strm->total_out = %ld\n", strm->total_out);
+    QATDEBUG("flush = %ld\n", flush);
+    
+    /* If there are bytes left to copy out of the pinned memory output buffer
+       then we need to copy as many of them out to the output buffer as is 
+       possible as we need to empty the pinned memory output buffer before we
+       can call another cpaDcCompressData */ 
+    if (s->numBytesLeftToCopy) {
+       qatCopyOutputFromBufferList(strm, flush);
+    }
+    /* If the output buffer is full return Z_OK so it can be emptied. */ 
+    if (0 == strm->avail_out) return Z_OK;
+   
+    /* Check if we have stored a footer in the footerFlatBuffer. If we have then
+       copy as much of it out to the output buffer as we can fit. The 
+       order of emtying the pinned output buffer before the footerBuffer is
+       important */ 
+    qatCopyOutputFromFooterBuffer(strm);
+    
+    /* if the output buffer is full return Z_OK so it can be emptied.
+       There may or may not be further bytes to copy to the output buffer */ 
+    if (0 == strm->avail_out) return Z_OK;
+    
+    switch (s->qatState) {
+
+    case QAT_DEF_STATE_INIT:
+        QATDEBUG("*QAT_DEF_STATE_INIT*\n");
+
+        /* look for the specific case of compressing a zero byte file. If we encounter it
+           take special action to generate the same content as software compression would */
+        if ((0 == strm->avail_in) &&  (0 == strm->total_in)) {
+            return qatGenerateZeroByteFile(strm);
+        }
+        if ( 1 == s->wrap || 2 == s->wrap) {
+            /* Generate the zlib/gzip header */
+            if (Z_OK != qatGenerateHeader(strm)) {
+                s->qatState = QAT_DEF_STATE_ERROR;
+                return Z_DATA_ERROR;
+            }
+        }
+        s->qatState = QAT_DEF_STATE_BODY;
+        /* Don't return here lets just fall through into the next state for efficiency */
+        
+    /* Don't add new states here as we purposely fall from the QAT_DEF_STATE_INIT above
+       into the QAT_DEF_STATE_BODY below. */
+
+    case QAT_DEF_STATE_BODY:
+        QATDEBUG("*QAT_DEF_STATE_BODY*\n");
+        if (Z_SYNC_FLUSH == flush) {
+            s->adjustIntBuffersToMatchExtBuffers = 1;
+        }
+        /* Copy as much input as we can from the input buffer to the pinned memory
+        input buffer */
+        if (Z_OK != qatAddInputToBufferList(strm, flush)) {
+            fprintf(stderr, "Error adding input to internal bufferList\n");
+            s->qatState = QAT_DEF_STATE_ERROR;
+            return Z_STREAM_ERROR;
+        }
+    
+        QATDEBUG("Total Bytes Now in Input Buffer: %d\n", s->totalBytesPlacedInInputBuffer);
+
+        /* if we are not on the final block and we copied all the input data into
+           pinned memory then return Z_OK so we can get more input data to fill
+           the pinned memory. If we are on the final block we want to goahead and
+           compress regardless of whether we empty the input buffer or not */	
+        if (Z_NO_FLUSH == flush && 0 == strm->avail_in && !s->adjustIntBuffersToMatchExtBuffers)
+            return Z_OK;
+
+        s->res.produced=0;		
+        /* Reset the pinned memory output buffer ready for the next call to cpaDcCompressData */
+        qatResetOutputBufferList(strm);
+        if(QAT_DRIVER_TYPE_1_6 == s->qatDriverType) {
+            if (s->adjustIntBuffersToMatchExtBuffers) {
+                qatAdjustOutputBufferList(strm);
+            }
+        }
+        rc = qatSendCompressionRequest(strm, flush);
+        if ( Z_OK != rc ) {
+            s->qatState = QAT_DEF_STATE_ERROR;
+            return rc;
+        }
+        
+        /* Reset the pinned memory input buffer ready to reuse on the next qatDeflate call. */ 
+        qatResetInputBufferList(strm);
+   
+        QATDEBUG("s->res.status = %d\n", s->res.status);
+        QATDEBUG("s->res.consumed = %ld\n", s->res.consumed);
+        QATDEBUG("s->res.produced = %ld\n", s->res.produced);
+        QATDEBUG("s->res.checksum = %x\n", s->res.checksum);
+        
+        /* Report any errors - Note overflow is not supported on DH89XXCC
+           and is reported as an error. On other platforms overflow is ok. */
+        if (CPA_DC_OK != s->res.status)  {
+            if(s->qatDriverType >= QAT_DRIVER_TYPE_1_6) {
+                if (CPA_DC_OVERFLOW != s->res.status) {
+                    fprintf(stderr, "Data compression unsuccessful, status %d\n", s->res.status);
+                    s->qatState = QAT_DEF_STATE_ERROR;
+                    return Z_DATA_ERROR;
+                }
+            }     
+            else
+            {
+                fprintf(stderr, "Data compression unsuccessful, status %d\n", s->res.status);
+                s->qatState = QAT_DEF_STATE_ERROR;
+                return Z_DATA_ERROR;
+            }
+        }
+        
+        if (CPA_DC_OVERFLOW == s->res.status) { 
+            QATDEBUG("CPA_DC_OVERFLOW detected\n");
+        }
+
+        if (s->adjustIntBuffersToMatchExtBuffers) {
+            strm->avail_in -= s->res.consumed;
+            strm->next_in += s->res.consumed;
+            strm->total_in += s->res.consumed;
+        }
+
+        s->numBytesLeftToCopy = s->res.produced;
+        s->strm->adler = s->res.checksum;
+
+        /* Copy as much output as possible from pinned memory to the output buffer */
+        qatCopyOutputFromBufferList(strm, flush);
+
+        /* if we aren't on the final packet or if there is still data in the input buffer
+           then return Z_OK at this point */
+        if (Z_FINISH != flush || 
+            ((Z_FINISH == flush) && (0 != strm->avail_in))) { 
+            return Z_OK;
+        }
+
+        /* We are at the end with all buffers sorted so lets set the FINISH_STATE
+           and generate the footer if needed */
+        s->qatState = QAT_DEF_STATE_FINISHED;
+
+        if (s->wrap <= 0) {
+            s->strm->avail_in = 0;
+            if ( 0 == s->numBytesLeftToCopy )
+                return Z_STREAM_END;
+        }
+        else {
+            if (Z_OK != qatGenerateFooter(strm)) {
+                s->qatState = QAT_DEF_STATE_ERROR;
+                return Z_DATA_ERROR;
+            }
+            if ( 0 == s->numBytesLeftToCopy )
+            {
+                /* if there is room lets empty the footerBuffer into the output buffer now and
+                   save another iteration round the loop */
+                qatCopyOutputFromFooterBuffer (strm);
+
+                if (!s->footerBufferBytesRemaining) {
+                    strm->avail_in=0;
+                    return Z_STREAM_END;
+                }
+            }
+        }
+
+        QATDEBUG("*** End qatDeflate ***\n");
+        
+        return Z_OK;
+
+    case QAT_DEF_STATE_FINISHED:
+        QATDEBUG("*QAT_DEF_STATE_FINISHED*\n");
+        if (flush != Z_FINISH) {
+            s->qatState = QAT_DEF_STATE_ERROR;
+            return Z_STREAM_ERROR;
+        }
+        /* To reach this point we know we have emptied any outstanding buffers.
+           So if we are in the QAT_DEF_STATE_FINISHED then we can ensure 
+           strm->avail_in is zero (it should be anyway) and return Z_STREAM_END 
+           to say we have finished */	
+        strm->avail_in=0;
+        return Z_STREAM_END;
+        
+    case QAT_DEF_STATE_ERROR:
+        QATDEBUG("*QAT_DEF_STATE_ERROR*\n");
+        /* Purposely fall through to next state */
+    default:
+        return Z_STREAM_ERROR;
+    }
+}
+
+/* ========================================================================= */
 int ZEXPORT deflateEnd (strm)
     z_streamp strm;
 {
+    deflate_state *s;
     int status;
 
     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-
+    s = (deflate_state *)strm->state;
+    if (qatIsHardwareCompressionEnabled() && !s->useSoftCompForThisStream) {
+        return qatDeflateEnd(strm);
+    }	
     status = strm->state->status;
     if (status != INIT_STATE &&
         status != EXTRA_STATE &&
@@ -1006,6 +2192,130 @@
     return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
 }
 
+/* ========================================================================= */
+int qatDeflateEnd (strm)
+    z_streamp strm;
+{
+    qat_deflate_state status;
+    deflate_state *s = NULL;
+    CpaStatus rc = CPA_STATUS_FAIL;
+    
+    if (strm == Z_NULL || strm->state == Z_NULL) {
+      fprintf(stderr, "strm == Z_NULL or strm->state == Z_NULL\n"); 
+      return Z_STREAM_ERROR;
+    }
+
+    status = strm->state->qatState;
+    if (status != QAT_DEF_STATE_INIT &&
+        status != QAT_DEF_STATE_BODY &&
+        status != QAT_DEF_STATE_FINISHED &&
+        status != QAT_DEF_STATE_ERROR) {
+      fprintf(stderr, "status is not equal to a valid state - quiting with an error\n");
+      return Z_STREAM_ERROR;
+    }
+
+    /* Free QAT resources */
+    s = (deflate_state *)strm->state;
+	
+    ZLIB_CLOSE_QAT_LOG();
+	
+    if (NULL != s) {
+        if ((NULL != s->instHandle) && (s->sessionStarted))
+            rc = cpaDcRemoveSession(s->instHandle, s->session);
+        s->sessionStarted = 0;
+    }
+
+    if (rc != CPA_STATUS_SUCCESS) {
+        fprintf(stderr, "Error removing session - ignoring\n");
+    }
+    
+    qatDeflateCleanup(strm);
+
+    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
+}
+
+/* ========================================================================= */
+int qatDeflateCleanup(strm)
+    z_streamp strm;
+{
+    /* Cleanup in reverse order checking for NULL pointers and ensuring pointers are
+       set to NULL. It is possible some pointers have not been created when this
+       function is called (if something goes wrong in the deflateInit). Also it is
+       possible this function may get called twice if something goes wrong in the 
+       deflateInit but the client either doesn't check the status or chooses to
+       still call deflateEnd to cleanup */
+    deflate_state *s = NULL;
+    int numOfFlatBuffers = 0;
+	s = (deflate_state *)strm->state;
+	
+    if (NULL != s->session) {
+        qaeZlibPinnedMemFree(s->session);
+        s->session = NULL;
+    }
+    
+    s->currentOutputBuffer=s->out;
+    for(numOfFlatBuffers = 0; numOfFlatBuffers < s->totalNumOfOutputBuffers; numOfFlatBuffers++) {
+       if (NULL != s->currentOutputBuffer->pData) {
+          qaeZlibPinnedMemFree(s->currentOutputBuffer->pData);
+          s->currentOutputBuffer->pData=NULL;
+       }
+       s->currentOutputBuffer++;
+    }
+
+    s->currentInputBuffer=s->in;
+    for(numOfFlatBuffers = 0; numOfFlatBuffers < s->totalNumOfInputBuffers; numOfFlatBuffers++) {
+       if (NULL != s->currentInputBuffer->pData) {
+          qaeZlibPinnedMemFree(s->currentInputBuffer->pData);
+          s->currentInputBuffer->pData=NULL;
+       }
+       s->currentInputBuffer++;
+    }
+
+    if (NULL != s->in) {
+        ZFREE(strm, s->in);
+        s->in = NULL;
+    }
+
+    if (NULL != s->out) {
+        ZFREE(strm, s->out);
+        s->out = NULL;
+    }
+
+    if (NULL != s->inl.pPrivateMetaData) {
+        qaeZlibPinnedMemFree(s->inl.pPrivateMetaData);
+        s->inl.pPrivateMetaData = NULL;
+    }
+
+    if (NULL != s->outl.pPrivateMetaData) {
+        qaeZlibPinnedMemFree(s->outl.pPrivateMetaData);
+        s->outl.pPrivateMetaData = NULL;
+    }
+    
+    if (NULL != s->contextBuffList.pBuffers) {
+        if (NULL != s->contextBuffList.pBuffers->pData) {
+            qaeZlibPinnedMemFree(s->contextBuffList.pBuffers->pData);
+            s->contextBuffList.pBuffers->pData = NULL;
+            s->contextBuffList.pBuffers = NULL;
+        }
+    }
+		   
+    if (NULL != s->contextBuffList.pPrivateMetaData) {
+        qaeZlibPinnedMemFree(s->contextBuffList.pPrivateMetaData);
+        s->contextBuffList.pPrivateMetaData = NULL;
+    }
+
+    if (NULL != s->footerFlatBuffer.pData) {
+       ZFREE(strm, s->footerFlatBuffer.pData);
+       s->footerFlatBuffer.pData = NULL;
+    }
+
+    ZFREE(strm, strm->state);
+    strm->state = Z_NULL;
+	
+    return Z_OK;
+}
+
+
 /* =========================================================================
  * Copy the source state to the destination state.
  * To simplify the source, this is not supported for 16-bit MSDOS (which
@@ -1027,7 +2337,10 @@
         return Z_STREAM_ERROR;
     }
 
-    ss = source->state;
+    ss = (deflate_state *)source->state;
+    if (qatIsHardwareCompressionEnabled() && !ss->useSoftCompForThisStream) {
+        return qatDeflateCopy(dest, source);
+    }			
 
     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
 
@@ -1066,6 +2379,15 @@
 #endif /* MAXSEG_64K */
 }
 
+int qatDeflateCopy (dest, source)
+    z_streamp dest;
+    z_streamp source;
+{
+    /* not supported with hardware acceleration */
+    return Z_STREAM_ERROR;
+}
+
+
 /* ===========================================================================
  * Read a new buffer from the current input stream, update the adler32
  * and total number of bytes read.  All deflate() input goes through
diff -uBbw -Nr ../zlib-1.2.8/deflate.h ./deflate.h
--- ../zlib-1.2.8/deflate.h	2012-06-02 18:16:43.000000000 +0100
+++ ./deflate.h	2016-09-06 13:13:26.561255000 +0100
@@ -14,6 +14,11 @@
 #define DEFLATE_H
 
 #include "zutil.h"
+/* Additions for QAT hardware acceleration. */
+#include "cpa.h"
+#include "cpa_dc.h"
+#include "engine.h"
+
 
 /* define NO_GZIP when compiling if you want to disable gzip header and
    trailer creation by deflate().  NO_GZIP would be used to avoid linking in
@@ -60,6 +65,25 @@
 #define FINISH_STATE 666
 /* Stream status */
 
+typedef enum {
+    QAT_DEF_STATE_INIT,
+    QAT_DEF_STATE_BODY,
+    QAT_DEF_STATE_FINISHED,
+    QAT_DEF_STATE_ERROR
+} qat_deflate_state;
+/*
+    State Transitions for above:-
+    
+    QAT_DEF_STATE_INIT->QAT_DEF_STATE_BODY->
+    QAT_DEF_STATE_FINISHED
+    
+    On a qatDeflateReset all state will get reset including this state
+    machine back to QAT_DEF_STATE_INIT.
+    
+    Any state may transition to the QAT_DEF_STATE_ERROR state. The only way to
+    recover once in the QAT_DEF_STATE_ERROR state is to call a qatDeflateReset.
+*/
+
 
 /* Data structure describing a single value and its code string. */
 typedef struct ct_data_s {
@@ -270,6 +294,127 @@
      * updated to the new high water mark.
      */
 
+    /********************************************/
+    /* Additions for QAT hardware acceleration. */
+    
+    /* The current state the deflate operation is at */
+    qat_deflate_state     qatState;
+
+    /* Setup parameters for the compression. They will be passed down on
+       each call to cpaDcCompressData */
+    CpaDcSessionSetupData sd;
+
+    /* Pointer to the session handle that is passed into various functions. */
+    void                  *session;
+
+    /* A pointer to the output flat buffer within the pinned memory output
+       buffer list*/
+    CpaFlatBuffer         *out;
+
+    /* A pointer to the input flat buffer within the pinned memory input
+       buffer list*/
+
+    CpaFlatBuffer         *in;
+
+    /* The buffer list of pinned memory that will be passed to the driver
+       via the QAT API as the output buffer. */
+    CpaBufferList         outl;
+    
+    /* The buffer list of pinned memory that will be passed to the driver
+       via the QAT API as the input buffer. */
+    CpaBufferList         inl;
+   
+    /* The results structure populated by calls to cpaDcCompressData and
+       cpaDcGenerateFooter. The result need to be maintained across calls
+       to cpaDcCompressData as the checksum needs to be fed back in */
+    CpaDcRqResults        res;
+
+    /* A pointer to the handle of the compression instance we will use */
+    CpaInstanceHandle     *instHandle;
+
+    /* The NUMA Node Id associated with a particular instance. This is
+       used so we may allocate memory on the same node Id. */
+    Cpa32U                nodeId;
+
+    /* The size of the QAT context buffer required, this will depend on the
+       compression level selected */ 
+    Cpa32U                contextSize;
+
+    /* A bufferlist that will contain metadata and the context flatbuffer.
+       it will be passed to the driver to use to hold context data */ 
+    CpaBufferList         contextBuffList;
+
+    /* A flat buffer that will be passed into the driver to hold context
+       data */ 
+    CpaFlatBuffer         contextFlatBuffer;
+
+    /* The footer flatbuffer that is passed into cpaDcGenerateFooter and will
+       be populated with the footer */
+    CpaFlatBuffer         footerFlatBuffer;
+
+    /* A pointer to the position in the footer buffer to copy data from. This
+       is important to keep if we could not fit all the footer bytes into the 
+       output buffer on the first attempt */
+    Cpa8U                 *footerBufferPosition;
+
+    /* The number of footer bytes still to be copied to the output buffer */ 
+    Cpa16U                footerBufferBytesRemaining;
+
+    /* A pointer to the current input flatbuffer we are copying data into */ 
+    CpaFlatBuffer         *currentInputBuffer;
+
+    /* A pointer to the current output flatbuffer we are copying data out of */
+    CpaFlatBuffer         *currentOutputBuffer;
+
+    /* The size of one input flat buffer */
+    int                   totalBuffersize;
+    
+    /* The total number of flat buffers allocated for input but not necessarily
+       the amount of flat buffers that have input data in them. */
+    int                   totalNumOfInputBuffers; 
+                                                    
+    /* The total number of flat buffers allocated for output but not necessarily
+       the amount of flat buffers that have output data in them. */
+    int                   totalNumOfOutputBuffers;
+ 
+    /* The total amount of bytes that have been placed into all the input flat
+       buffers for one call to cpaDcCompressData. */
+    int                   totalBytesPlacedInInputBuffer;
+
+    /* The amount of input flat buffers with input data in */
+    int                   fullInputBuffers;
+
+    /* The total amount of bytes left in the output buffer list that need copying 
+       out to the zlib API output buffer */
+    int                   numBytesLeftToCopy;
+    
+    /* The offset into the output flat buffer where we need to start copying
+       data from */
+    int                   positionInOutputBuffer;
+
+    /* A flag to store whether we have decided to use software compression just
+       for this stream. Currently this is used if the compression level is passed
+       in as 0 */
+    int                   useSoftCompForThisStream;
+
+    /* A flag to store whether we have an open session or not. This is used by
+       qatDeflateResetKeep to determine whether the session needs to be
+       reinitialized */
+    int                   sessionStarted;
+
+    /* A flag to store whether we have seen a Z_SYNC_FLUSH so we know whether to
+       adjust input and output buffers once we reach Z_FINISH. */
+    int                   adjustIntBuffersToMatchExtBuffers;
+
+#ifdef QAT_TESTS_LOG
+    /* A FILE pointer to a file used during debugging */
+    FILE                  *zlibQatLogger;                  
+#endif
+    QatDriverType      qatDriverType;
+ 
+    /* End of additions for QAT hardware acceleration. */
+    /***************************************************/
+
 } FAR deflate_state;
 
 /* Output a byte on the stream.
diff -uBbw -Nr ../zlib-1.2.8/engine.c ./engine.c
--- ../zlib-1.2.8/engine.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engine.c	2016-09-12 08:19:06.223215000 +0100
@@ -0,0 +1,551 @@
+/* engine.c -- Support code for Intel QAT hardware acceleration of zlib.
+ * Copyright (C) 2013 Intel Corporation. All rights reserved.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* maxros defined to allow the use of the cpu get and set affinity functions */
+#define __USE_GNU
+
+#include "engine.h"
+#include "qat_zlib.h"
+#include "zutil.h"
+#include <pthread.h>
+#include <malloc.h>
+#include <stdio.h>
+#include <sched.h>
+#include <ctype.h>
+#include "icp_sal_versions.h"
+#include "icp_sal_user.h"
+#include "qat_parseconf.h"
+
+int qat_keep_polling = 1;
+static pthread_mutex_t startup_mutex = PTHREAD_MUTEX_INITIALIZER;
+static Cpa16U numInstances  = 0;
+static int currentInstance  = -1;
+static CpaInstanceHandle * iHandle = NULL;
+static pthread_t *icp_polling_threads = NULL;
+static struct qatBufferListContainer *pIntBuffersForEachInstance = NULL;
+static long polling_interval = Z_QAT_DEFAULT_POLLING_INTERVAL;
+static int max_num_of_retries = Z_QAT_DEFAULT_MAX_NUM_RETRIES;
+
+/* How many times we have called zlibStartupEngine. Used to ensure we only actually start the
+   IA driver once and to track when we can make the one call to shutdown the IA driver. */
+static int ref_count = 0; 
+
+static int hardwareCompressionEnabled = 0;
+static int hardwareDecompressionEnabled = 0;
+static int engineStarted = 0;
+char *ICPConfigSectionName = "SHIM";
+
+#define SAL_STOP_DELAY 1
+
+
+local void qatEngineCleanup()
+{
+    int sts                    = 1;
+    int instNum                = 0;
+    int numIntBuffers          = 0;
+    int numOfFlatBuffers       = 0;
+    for (instNum = 0; instNum < numInstances; instNum++) {
+        if (icp_polling_threads[instNum]) {  
+            /* Exit the thread */
+            sts = pthread_join(icp_polling_threads[instNum], NULL);
+            if (sts != 0) {
+                fprintf(stderr, "Unsuccessful call to pthread_mutex_lock - sts = %d. Continuing regardless.\n", sts);
+            }
+        }
+        if (NULL != pIntBuffersForEachInstance) {
+            if (NULL != pIntBuffersForEachInstance[instNum].ppBufferList) {
+                for (numIntBuffers = 0; numIntBuffers < pIntBuffersForEachInstance[instNum].numOfIntBuffers; numIntBuffers++) {
+                    if (NULL != pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]) {
+                        if (NULL != pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pBuffers) {
+                            for(numOfFlatBuffers = 0; numOfFlatBuffers < 
+                                pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->numBuffers; 
+                                numOfFlatBuffers++) {
+                                if (NULL != pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pBuffers[numOfFlatBuffers].pData) {
+                                    qaeZlibPinnedMemFree(pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pBuffers[numOfFlatBuffers].pData);
+                                    pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pBuffers[numOfFlatBuffers].pData = NULL;
+                                }
+                            }
+                            free(pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pBuffers);
+                            pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pBuffers = NULL;
+                        }
+
+                        if (NULL != pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pPrivateMetaData) {
+                            qaeZlibPinnedMemFree(pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pPrivateMetaData);
+                            pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pPrivateMetaData = NULL;
+                        }
+
+                        free(pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]);
+                        pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers] = NULL;
+
+                    }
+                }
+                free(pIntBuffersForEachInstance[instNum].ppBufferList);
+                pIntBuffersForEachInstance[instNum].ppBufferList = NULL;
+            }
+        } 
+    }
+
+    if (NULL != pIntBuffersForEachInstance) {
+        free(pIntBuffersForEachInstance);
+        pIntBuffersForEachInstance = NULL;
+    }
+
+    if (NULL != iHandle) {
+        free(iHandle);
+        iHandle = NULL;
+    }
+    
+    if (NULL != icp_polling_threads) {
+        free(icp_polling_threads);
+        icp_polling_threads = NULL;
+    }
+}
+
+void ZEXPORT zlibSetupEngine(long pollingInterval, int maxNumRetries)
+{
+     if ((pollingInterval >= 1) && (pollingInterval <= 10000000)) {
+         polling_interval = pollingInterval;
+     }
+     else {
+         fprintf(stderr, "The polling interval value is out of range, using default value %ld\n", polling_interval);
+     }
+     if ((maxNumRetries >= -1) && (maxNumRetries <= 100000)) {
+         max_num_of_retries = maxNumRetries;
+     }
+     else {
+         fprintf(stderr, "The maximum number of retries value is out of range, using default value %d\n", max_num_of_retries);
+     }
+}
+
+/* ========================================================================= */
+int ZEXPORT zlibStartupEngine(int SwHwCompressionFlag)
+{
+    CpaStatus rc               = CPA_STATUS_SUCCESS;
+    int sts                    = 1;
+    int instNum                = 0;
+    int numOfFlatBuffers       = 0;
+    int numIntBuffers          = 0;
+    Cpa32U metaSize            = 0;
+    Cpa32U nodeId              = 0;
+    Cpa16U bufferCount         = 0;
+    icp_sal_dev_version_info_t versionInfo
+                               = {0};
+    char configKeyValue[ZLIB_CONF_MAX_LINE_LENGTH]
+                               = {0};
+    int configKeyValueSize     = ZLIB_CONF_MAX_LINE_LENGTH;
+    int checkLimitStatus       = 0;
+    CpaBoolean limitDevAccess  = CPA_FALSE;
+    int returnStatus           = Z_MEM_ERROR;
+
+    /* Initialise the QAT hardware if not already done */
+    sts = pthread_mutex_lock(&startup_mutex);
+    if (sts != 0) {
+        fprintf(stderr, "Unsuccessful call to pthread_mutex_lock - sts = %d.\n", sts);
+        return returnStatus;
+    }
+       
+    if (!ref_count) {
+        /* Setup whether we will use Hardware or Software Compression/Decompression
+           based on the flag passed in. Note: this is only set the first time. Changing
+           the parameter on subsequent calls will have no effect. */
+        switch (SwHwCompressionFlag) {
+            case Z_SW_COMP_SW_DECOMP:                             
+                hardwareCompressionEnabled = 0;
+	        hardwareDecompressionEnabled = 0;
+                break;
+	    case Z_HW_COMP_SW_DECOMP:                             
+                hardwareCompressionEnabled = 1;
+	        hardwareDecompressionEnabled = 0;
+                break;
+	    case Z_SW_COMP_HW_DECOMP:                             
+                hardwareCompressionEnabled = 0;
+	        hardwareDecompressionEnabled = 1;
+                break;
+	    case Z_HW_COMP_HW_DECOMP:                             
+                hardwareCompressionEnabled = 1;
+	        hardwareDecompressionEnabled = 1;
+                break;
+	    default: /* for compiler happiness */
+	        hardwareCompressionEnabled = 0;
+	        hardwareDecompressionEnabled = 0;
+        }
+        /* If either hardware compression or decompression is enabled then we will need
+           to start the QAT and setup the instances and intermediate buffers */
+	if (hardwareCompressionEnabled || hardwareDecompressionEnabled) {
+            qat_keep_polling = 1;
+
+            checkLimitStatus =
+                    zlibCheckLimitDevAccessValue((int *)&limitDevAccess,
+                                                     ICPConfigSectionName);
+            if (!checkLimitStatus) {
+                    fprintf(stderr, "Unable to find LimitDevAccess line in driver config file."
+                                    " Defaulting to use a value of 0\n");
+            }        
+            /* Call icp_sal_userStartMultiProcess on the config section name string */
+            rc = icp_sal_userStartMultiProcess(ICPConfigSectionName, 
+                                               limitDevAccess);
+            if (CPA_STATUS_SUCCESS != rc) {
+                fprintf(stderr, "QAT Zlib Cannot use Acceleration Driver - "
+                                "Acceleration Driver is not running or "
+                                "Hardware Acceleration not present.\n");
+                fprintf(stderr, "Defaulting to Software Compression/Decompression\n");
+                hardwareCompressionEnabled = 0;
+                hardwareDecompressionEnabled = 0;
+                ref_count++;
+                sts = pthread_mutex_unlock(&startup_mutex);
+                if (sts != 0) {
+                    fprintf(stderr, "Unsuccessful pthread_mutex_unlock. sts = %d\n", sts);
+                    /* This should never fail, if it does lets just continue anyway as we
+                       can't do anything about it.*/
+                }
+                returnStatus = Z_OK; /* Return Z_OK even though we couldn't start. For use
+                                        case where user has not got hardware acceleration 
+                                        but wants to use shim*/
+                goto startup_err;
+            }
+
+            engineStarted = 1;
+
+            /* Get the number of available instances */
+            rc = cpaDcGetNumInstances(&numInstances);
+            if (CPA_STATUS_SUCCESS != rc) {
+                fprintf(stderr, "cpaDcGetNumInstances failed, rc=%d\n", rc);
+                goto startup_err;
+            }
+            
+            if (0 == numInstances) {
+                fprintf(stderr, "No Compression Instances were detected."
+                                " Please check config file is setup correctly.\n");
+                goto startup_err;
+            }
+    
+            /* Allocate memory for the instance handle array */
+            iHandle = (CpaInstanceHandle *)malloc(numInstances * sizeof(CpaInstanceHandle));
+            if (NULL == iHandle) {
+                fprintf(stderr, "malloc() failed for instance handles.\n");
+                goto startup_err;
+            }
+
+            /* Get the DC instances */
+            rc = cpaDcGetInstances(numInstances, iHandle);
+            if (CPA_STATUS_SUCCESS != rc) {
+                fprintf(stderr, "cpaDcGetInstances failed, rc=%d\n", rc);
+                goto startup_err;
+            }
+
+            /* Allocate memory for the polling threads */
+            icp_polling_threads = (pthread_t *)malloc(numInstances * sizeof(pthread_t));
+            if (NULL == icp_polling_threads) {
+                fprintf(stderr, "malloc() failed for icp_polling_threads.\n");
+                goto startup_err;
+            }
+       
+            /* Allocate memory to store pointers to buffer lists */
+            pIntBuffersForEachInstance = malloc(numInstances * sizeof(struct qatBufferListContainer));
+            if (NULL == pIntBuffersForEachInstance) {
+                fprintf(stderr, "Failed to malloc() pIntBuffersForEachInstance.\n");
+                goto startup_err;
+            }
+            memset(pIntBuffersForEachInstance, 0, numInstances * sizeof(struct qatBufferListContainer));
+		
+            /* Declare the Info Instance 2 structures */
+            CpaInstanceInfo2 instanceInfo2[numInstances];	
+
+            /* loop round for each instance */
+            for (instNum = 0; instNum < numInstances; instNum++) {
+                /* Retrieve InstanceInfo2 structure for that instance */
+                rc = cpaDcInstanceGetInfo2(iHandle[instNum], &instanceInfo2[instNum]);
+                if (CPA_STATUS_SUCCESS != rc ) {
+                    fprintf(stderr, "cpaDcInstanceGetInfo2 failed. rc = %d\n", rc);
+                    goto startup_err;
+                }
+			
+                /* Use the packageId contained in the InstanceInfo2 structure to retrieve 
+                   version info for the instance using the icp_salDevVersionInfo call */	
+                rc = icp_sal_getDevVersionInfo(instanceInfo2[instNum].physInstId.packageId,
+                                               &versionInfo);		
+                if (CPA_STATUS_SUCCESS != rc ) {
+                    fprintf(stderr, "icp_sal_getDevVersionInfo failed. packageId = %d rc = %d\n",
+                            instanceInfo2[instNum].physInstId.packageId, rc);
+                    goto startup_err;
+                }
+
+                /* Get NUMA Node Id so we alloc on the same NUMA node as the instance */
+                nodeId = instanceInfo2[instNum].nodeAffinity;
+                
+                rc = cpaDcGetNumIntermediateBuffers(iHandle[instNum], &bufferCount);
+                if (CPA_STATUS_SUCCESS != rc ) {
+                    fprintf(stderr, "cpaDcGetNumIntermediateBuffers failed. rc = %d\n", rc);
+                    goto startup_err;
+                }
+                    
+                /* Allocate the buffer list memory for the Intermediate Buffers */
+                pIntBuffersForEachInstance[instNum].ppBufferList = malloc(bufferCount * sizeof(CpaBufferList*));
+                if (NULL == pIntBuffersForEachInstance[instNum].ppBufferList) {
+                    fprintf(stderr, "malloc() failed for pIntBuffersForEachInstance[].ppBufferList\n");
+                    goto startup_err;
+                }
+                memset(pIntBuffersForEachInstance[instNum].ppBufferList, 0, bufferCount * sizeof(CpaBufferList*));
+                pIntBuffersForEachInstance[instNum].numOfIntBuffers=bufferCount;
+                
+                for (numIntBuffers = 0; numIntBuffers < bufferCount; numIntBuffers++) {
+                    pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers] = malloc(sizeof(CpaBufferList));
+                    if (NULL == pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]){
+                        fprintf(stderr, "malloc() failed for pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]\n");
+                        goto startup_err;
+                    }
+
+                    pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pPrivateMetaData = NULL;
+                    pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pBuffers = NULL;
+
+                    /* Get the size of the Private meta data needed to create Buffer List */
+                    rc = cpaDcBufferListGetMetaSize(iHandle[instNum], QAT_ZLIB_NUM_INPUT_FLAT_BUFFERS * 3, &metaSize);
+                    if (CPA_STATUS_SUCCESS != rc ) {
+                        fprintf(stderr, "cpaDcBufferListGetMetaSize failed. rc = %d\n", rc);
+                        goto startup_err;
+                    }
+
+                    /* Allocate the memory for the private metadata */
+                    pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pPrivateMetaData = 
+                        qaeZlibPinnedMemAlloc(metaSize, nodeId, __FILE__, __LINE__);
+                    if (NULL == pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pPrivateMetaData) {
+                        fprintf(stderr, "Failed to allocate memory for pPrivateMetaData\n");
+                        goto startup_err;
+                    }
+
+                    /* Allocate Intermediate flat buffers */
+                    pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->numBuffers = 
+                        QAT_ZLIB_NUM_INPUT_FLAT_BUFFERS * 3;
+                    pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pBuffers = 
+                        malloc(sizeof(CpaFlatBuffer) * 
+                        pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->numBuffers); 
+                    if (NULL == pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pBuffers) {
+                        fprintf(stderr, "malloc() failed for pBuffers\n");
+                        goto startup_err;
+                    }
+                    memset(pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pBuffers, 0, sizeof(CpaFlatBuffer) * pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->numBuffers);
+          
+                    for(numOfFlatBuffers = 0; 
+                        numOfFlatBuffers < pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->numBuffers;
+                        numOfFlatBuffers++) {
+                        pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pBuffers[numOfFlatBuffers].pData =  
+                        qaeZlibPinnedMemAlloc(QAT_ZLIB_INTERNAL_FLATBUFFER_SIZE, nodeId, __FILE__, __LINE__);
+                        if (NULL == pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pBuffers[numOfFlatBuffers].pData) {
+                            fprintf(stderr, "qaeZlibPinnedMemAlloc() failed for \
+                                             pBuffers[%d].pData\n", numOfFlatBuffers);
+                            goto startup_err;
+                        }
+                        pIntBuffersForEachInstance[instNum].ppBufferList[numIntBuffers]->pBuffers[numOfFlatBuffers].dataLenInBytes = QAT_ZLIB_INTERNAL_FLATBUFFER_SIZE;
+                    }
+                }
+      
+                /* Configure memory translation function */
+                rc = cpaDcSetAddressTranslation(iHandle[instNum], qaeZlibMemV2P);
+                if(CPA_STATUS_SUCCESS != rc ) {
+                    fprintf(stderr, "cpaDcSetAddressTranslation failed. rc = %d\n", rc);
+                    goto startup_err;
+                }
+
+                /* Start the DC Instance */
+                rc = cpaDcStartInstance(iHandle[instNum], bufferCount, pIntBuffersForEachInstance[instNum].ppBufferList); 
+                if(CPA_STATUS_SUCCESS != rc) {
+                    fprintf(stderr, "cpaDcStartInstance failed. rc = %d\n", rc);
+                    goto startup_err;
+                }
+
+                /* Create the polling threads */
+                sts = pthread_create(&(icp_polling_threads[instNum]), NULL, 
+                                    qatSendPoll, iHandle[instNum]);
+                if(sts != 0) {
+                    printf("pthread_create failed. sts = %d\n", rc);
+                    goto startup_err;
+                }
+#ifdef QAT_POLL_CORE_AFFINITY
+                /* Set affinity of the polling thread to match the cpu thread */
+                int coreID = 0;
+                cpu_set_t cpuset;
+          
+                CPU_ZERO(&cpuset);
+
+                CPU_SET(coreID, &cpuset);
+
+                sts = pthread_setaffinity_np(icp_polling_threads[instNum],
+                                             sizeof(cpu_set_t), &cpuset);
+
+                if (sts != 0) {
+                    fprintf(stderr, "pthread_setaffinity_np error, status = %d \n", sts);
+                    goto startup_err;
+                }
+
+                sts = pthread_getaffinity_np(icp_polling_threads[instNum],
+                                              sizeof(cpu_set_t), &cpuset);
+                if (sts != 0) {
+                    fprintf(stderr, "pthread_getaffinity_np error, status = %d \n", sts);
+                    goto startup_err;
+                }
+
+                if (CPU_ISSET(coreID, &cpuset))
+                    fprintf(stderr, "Polling thread assigned on CPU core %d\n", coreID);
+#endif
+            }
+        }
+    } 
+    ref_count++;
+    returnStatus = Z_OK;
+
+startup_err:
+
+    if (returnStatus != Z_OK) {
+        qatEngineCleanup();
+    }
+
+    sts = pthread_mutex_unlock(&startup_mutex);
+    if (sts != 0) {
+        fprintf(stderr, "Unsuccessful pthread_mutex_unlock. sts = %d\n", sts);
+    }
+    
+    return returnStatus;
+}
+
+/* ========================================================================= */
+int ZEXPORT zlibShutdownEngine(void)
+{
+    CpaStatus rc               = CPA_STATUS_SUCCESS;
+    int sts                    = 1;
+    int instNum                = 0;
+    sts = pthread_mutex_lock(&startup_mutex);
+    if (sts != 0) {
+        fprintf(stderr, "Unsuccessful call to pthread_mutex_lock - sts = %d. Continuing regardless.\n", sts);
+    }
+    ref_count--;
+    if (!ref_count) { 
+        qat_keep_polling = 0;
+        /* Check if we actually started the engine as if using software only 
+           compression/decompression then we may not have */
+        if (engineStarted) {
+            /* We did start the engine so loop through each instance, stopping it
+               and cleaning up all the buffers */
+            if (hardwareCompressionEnabled || hardwareDecompressionEnabled) {
+                for (instNum = 0; instNum < numInstances; instNum++) {
+                    /* Stop the DC Instance */
+                    rc = cpaDcStopInstance(iHandle[instNum]); 
+                    if(CPA_STATUS_SUCCESS != rc) {
+                        fprintf(stderr, "cpaDcStopInstance failed. rc = %d. Continuing regardless.\n", rc);
+                    }
+                }
+
+                qatEngineCleanup();
+
+            }
+
+            /* Stop the engine */
+            icp_sal_userStop();
+
+            /* Delay to stop us stopping and restarting the engine too soon */	   
+	    #ifdef SAL_STOP_DELAY
+                sleep(SAL_STOP_DELAY);
+            #endif
+	}
+    }
+
+    if (0 == sts) {
+        /* Only try and unlock the mutex if we got it successfully */
+        sts = pthread_mutex_unlock(&startup_mutex);
+        if (sts != 0) {
+            fprintf(stderr, "Unsuccessful pthread_mutex_unlock. sts = %d. Continuing regardless.\n", sts);
+        }
+    }
+    return Z_OK;
+}
+
+/* ========================================================================= */
+CpaInstanceHandle* qatIncrementCurrentInstance()
+{
+   if (0 == numInstances || NULL == iHandle) {
+       return NULL;
+   }
+   currentInstance = (currentInstance +1) % numInstances;
+   return iHandle[currentInstance];
+} 
+  
+/* ========================================================================= */
+int qatGetNumberOfInstances()
+{
+   return numInstances;
+} 
+
+/* ========================================================================= */
+Cpa32U qatGetNodeId(CpaInstanceHandle handle)
+{
+   CpaStatus status = CPA_STATUS_FAIL;
+   CpaInstanceInfo2 pInstanceInfo2;
+
+   status = cpaDcInstanceGetInfo2(handle, &pInstanceInfo2);
+   if(CPA_STATUS_SUCCESS != status)
+   {
+       fprintf(stderr, "Unable to get Node affinity\n");
+       return 0; /*Return 0 here rather than a failure.
+                   This is a design decision to not fail
+                   with an error as we can still carry
+                   on, but an error message is output to
+                   alert the user */
+   }
+
+   return pInstanceInfo2.nodeAffinity;
+} 
+
+/* ========================================================================= */
+int qatIsHardwareCompressionEnabled()
+{
+   return hardwareCompressionEnabled;
+}
+
+/* ========================================================================= */
+int qatIsHardwareDecompressionEnabled()
+{
+   return hardwareDecompressionEnabled;
+}
+
+/* ========================================================================= */
+long qatGetMaxNumRetries()
+{
+   return max_num_of_retries;
+}
+
+/* ========================================================================= */
+QatDriverType qatGetInstanceDriverType(CpaInstanceHandle handle)
+{
+   CpaStatus status = CPA_STATUS_FAIL;
+   CpaInstanceInfo2 pInstanceInfo2;
+   status = cpaDcInstanceGetInfo2(handle, &pInstanceInfo2);
+   if(CPA_STATUS_SUCCESS != status)
+   {
+       return QAT_DRIVER_TYPE_INVALID;
+   }
+
+   char *partName = (char *) pInstanceInfo2.partName;
+   if((NULL != strstr(partName,"c6xx")) || (NULL != strstr(partName,"c3xxx")))
+   {
+       return QAT_DRIVER_TYPE_1_7;
+   }
+   if (NULL != strstr(partName,"dh895xcc"))
+   {
+       return QAT_DRIVER_TYPE_1_6;
+   }
+   if (NULL != strstr(partName,"DH89XXCC"))
+   {
+       return QAT_DRIVER_TYPE_1_5;
+   }
+   
+   return QAT_DRIVER_TYPE_1_5; /* On versions of 1.5 you may get a blank
+                                  string for this field. To cover this
+                                  case we will make the default 1.5 */
+}
+
+/* ========================================================================= */
+long qatGetPollingInterval()
+{
+   return polling_interval;
+}
diff -uBbw -Nr ../zlib-1.2.8/engine.h ./engine.h
--- ../zlib-1.2.8/engine.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engine.h	2016-09-06 13:13:26.564255000 +0100
@@ -0,0 +1,137 @@
+/* engine.h -- Support code for Intel QAT hardware acceleration of zlib.
+ * Copyright (C) 2012 Intel Corporation. All rights reserved.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+ 
+#ifndef ENGINE_H
+#define ENGINE_H
+
+#include "cpa.h"
+#include "cpa_dc.h"
+
+typedef enum
+{
+    QAT_DRIVER_TYPE_1_5 = 0,
+    /**< Indicates registration of a DH89XXCC driver/library */
+    QAT_DRIVER_TYPE_1_6,
+    /**< Indicates registration of a DH895XCC driver/library */
+    QAT_DRIVER_TYPE_1_7,
+    /**< Indicates registration of a c6xx or c3xxx driver/library*/
+    QAT_DRIVER_TYPE_INVALID,
+    /**< Indicates upper end of enumeration range */
+} QatDriverType;
+
+struct qatBufferListContainer {
+    CpaBufferList **ppBufferList;
+    Cpa16U numOfIntBuffers;
+};
+
+/*****************************************************************************
+ * function:
+ *         qatIncrementCurrentInstance();
+ *
+ * @description
+ *      increments the static stored value of the instance. It will wrap 
+ *      back around when the value exceeds the number of instances available
+ *
+ * @retval a CpaInstanceHandle* containing the pointer to the incremented instance 
+ *
+ *****************************************************************************/
+CpaInstanceHandle* qatIncrementCurrentInstance();
+
+/*****************************************************************************
+ * function:
+ *         qatGetNodeId();
+ *
+ * @description
+ *      function to retrieve the NUMA node Id associated with the instance 
+ *
+ * @param[in] handle - the QAT compression instance to retrieve the NUMA
+ *                     node Id for.
+ *
+ * @retval a Cpa32U containing the NUMA node Id. On an error node 0 is
+ *         returned.
+ *
+ *****************************************************************************/
+Cpa32U qatGetNodeId(CpaInstanceHandle handle);
+
+/*****************************************************************************
+ * function:
+ *         qatGetNumberOfInstances();
+ *
+ * @description
+ *      function to retrieve the total number of available instances 
+ *
+ * @retval an int containing the number of available instances
+ *
+ *****************************************************************************/
+int qatGetNumberOfInstances();
+
+/*****************************************************************************
+ * function:
+ *         qatIsHardwareCompressionEnabled();
+ *
+ * @description
+ *      function to determine whether to use Hardware Compression (qat) 
+ *
+ * @retval 1 to use Hardware Compression, 0 to use Software Compression
+ *
+ *****************************************************************************/
+int qatIsHardwareCompressionEnabled();
+
+/*****************************************************************************
+ * function:
+ *         qatIsHardwareDecompressionEnabled();
+ *
+ * @description
+ *      function to determine whether to use Hardware Decompression (qat) 
+ *
+ * @retval 1 to use Hardware Decompression, 0 to use Software Decompression
+ *
+ *****************************************************************************/
+int qatIsHardwareDecompressionEnabled();
+
+/*****************************************************************************
+ * function:
+ *         qatGetMaxNumRetries();
+ *
+ * @description
+ *      function to return the maximum number of retries to attempt when
+ *      CPA_STATUS_RETRY is returned on a compression or decompression 
+ *      request
+ *
+ * @retval an int containing the maximum number of retries. -1 represents
+ *      infinite retries. 
+ * 
+ *****************************************************************************/
+long qatGetMaxNumRetries();
+
+/*****************************************************************************
+ * function:
+ *         qatGetPollingInterval();
+ *
+ * @description
+ *      function to return the polling interval for polling for QAT messages
+ *
+ * @retval a long containing the polling interval in nanoseconds 
+ * 
+ *****************************************************************************/
+long qatGetPollingInterval();
+
+/*****************************************************************************
+ * function:
+ *         qatGetInstanceDriverType(CpaInstanceHandle handle);
+ *
+ * @description
+ *      function to return the the type of driver a particular instance
+ *      resides on.
+ *
+ * @param[in] handle - the QAT compression instance to get the driver type
+ *                     for.
+ *
+ * @retval an enum representing the type of driver. 
+ * 
+ *****************************************************************************/
+QatDriverType qatGetInstanceDriverType(CpaInstanceHandle handle);
+
+#endif /* ENGINE_H */
diff -uBbw -Nr ../zlib-1.2.8/examples/zpipe.c ./examples/zpipe.c
--- ../zlib-1.2.8/examples/zpipe.c	2005-12-11 20:57:03.000000000 +0000
+++ ./examples/zpipe.c	2016-04-06 08:50:13.998276000 +0100
@@ -45,12 +45,20 @@
     strm.zalloc = Z_NULL;
     strm.zfree = Z_NULL;
     strm.opaque = Z_NULL;
+    /* initialize strm.avail_in as we will check it now */
+    strm.avail_in = 0;
     ret = deflateInit(&strm, level);
     if (ret != Z_OK)
         return ret;
 
     /* compress until end of file */
     do {
+        /* Added to workaround the fact zpipe assumes that the output buffer will always be
+           fully filled until all the data has been consumed. It then does not check the 
+           input has been fully consumed before overwriting with new input. As it happens
+           the qat zlib implementation does not always fill the output buffer so the zpipe
+           code has been corrected to add a proper check */   
+        if (strm.avail_in == 0) {
         strm.avail_in = fread(in, 1, CHUNK, source);
         if (ferror(source)) {
             (void)deflateEnd(&strm);
@@ -58,6 +66,7 @@
         }
         flush = feof(source) ? Z_FINISH : Z_NO_FLUSH;
         strm.next_in = in;
+        }
 
         /* run deflate() on input until output buffer not full, finish
            compression if all of source has been read in */
@@ -72,10 +81,10 @@
                 return Z_ERRNO;
             }
         } while (strm.avail_out == 0);
-        assert(strm.avail_in == 0);     /* all input will be used */
 
-        /* done when last data in file processed */
-    } while (flush != Z_FINISH);
+    /* done when last data in file processed. Note: additional check to make sure all input
+       has been consumed as qat zlib may still have input outstanding*/
+    } while (flush != Z_FINISH || strm.avail_in != 0);
     assert(ret == Z_STREAM_END);        /* stream will be complete */
 
     /* clean up and return */
@@ -91,7 +100,7 @@
    is an error reading or writing the files. */
 int inf(FILE *source, FILE *dest)
 {
-    int ret;
+    int ret, flush;
     unsigned have;
     z_stream strm;
     unsigned char in[CHUNK];
@@ -109,20 +118,32 @@
 
     /* decompress until deflate stream ends or end of file */
     do {
+        /* Added to workaround the fact zpipe assumes that the output buffer will always be
+           fully filled until all the data has been consumed. It then does not check the 
+           input has been fully consumed before overwriting with new input. As it happens
+           the qat zlib implementation does not always fill the output buffer so the zpipe
+           code has been corrected to add a proper check */   
+        if (strm.avail_in == 0) {
         strm.avail_in = fread(in, 1, CHUNK, source);
         if (ferror(source)) {
             (void)inflateEnd(&strm);
             return Z_ERRNO;
         }
+            /* Qat Zlib needs to know where the end of the file is as it is not
+               decoding the stream itself, it is offloading to hardware. As such
+               this additional line is needed to set the Z_FINISH flag on the
+               last data chunk */
+            flush = feof(source) ? Z_FINISH : Z_NO_FLUSH;
         if (strm.avail_in == 0)
             break;
         strm.next_in = in;
+        }
 
         /* run inflate() on input until output buffer not full */
         do {
             strm.avail_out = CHUNK;
             strm.next_out = out;
-            ret = inflate(&strm, Z_NO_FLUSH);
+            ret = inflate(&strm, flush);
             assert(ret != Z_STREAM_ERROR);  /* state not clobbered */
             switch (ret) {
             case Z_NEED_DICT:
@@ -181,9 +202,13 @@
     SET_BINARY_MODE(stdin);
     SET_BINARY_MODE(stdout);
 
+    zlibSetupEngine(Z_QAT_DEFAULT_POLLING_INTERVAL, Z_QAT_DEFAULT_MAX_NUM_RETRIES);
+
     /* do compression if no arguments */
     if (argc == 1) {
+        zlibStartupEngine(Z_HW_COMP_HW_DECOMP);
         ret = def(stdin, stdout, Z_DEFAULT_COMPRESSION);
+        zlibShutdownEngine();
         if (ret != Z_OK)
             zerr(ret);
         return ret;
@@ -191,7 +216,9 @@
 
     /* do decompression if -d specified */
     else if (argc == 2 && strcmp(argv[1], "-d") == 0) {
+        zlibStartupEngine(Z_HW_COMP_HW_DECOMP);
         ret = inf(stdin, stdout);
+        zlibShutdownEngine();
         if (ret != Z_OK)
             zerr(ret);
         return ret;
diff -uBbw -Nr ../zlib-1.2.8/gzread.c ./gzread.c
--- ../zlib-1.2.8/gzread.c	2013-03-25 05:47:59.000000000 +0000
+++ ./gzread.c	2016-09-06 13:13:26.568255000 +0100
@@ -38,6 +38,26 @@
     }
     if (ret == 0)
         state->eof = 1;
+
+    /* If we read all the bytes we requested in then lets have a check whether
+       we have reached the end of the file */
+    else if (len == *have)
+    {
+        /* Lets try and read 1 more byte. If we can't we are at the end of the 
+           file and can set the eof flag. This is needed because on the qat
+           zlib it is mandatory to send down Z_FINISH on the last request.
+           By reading a byte ahead we can be sure whether or not it is the
+           last chunk of data. If we managed to read a byte then don't set the
+           flag and seek back 1 byte ready for next time.*/
+        ret = read(state->fd, buf + *have, 1);
+        if (ret == 0)
+        {
+           state->eof = 1;
+        }
+        else
+            lseek(state->fd, -1, SEEK_CUR);
+    }
+
     return 0;
 }
 
@@ -188,7 +208,17 @@
         }
 
         /* decompress and handle errors */
+        /* For qat zlib it is mandatory to send down Z_FINISH on the last chunk of data.
+           This is because zlib is no longer decoding the stream it is offloading it to 
+           hardware but it still needs to know where the stream ends. */
+        if (state->eof == 1)
+        {
+           ret = inflate(strm, Z_FINISH);
+        }
+        else
+        {
         ret = inflate(strm, Z_NO_FLUSH);
+        }
         if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {
             gz_error(state, Z_STREAM_ERROR,
                      "internal error: inflate stream corrupt");
diff -uBbw -Nr ../zlib-1.2.8/inflate.c ./inflate.c
--- ../zlib-1.2.8/inflate.c	2012-08-13 08:02:40.000000000 +0100
+++ ./inflate.c	2016-09-08 14:54:39.974360000 +0100
@@ -85,6 +85,11 @@
 #include "inflate.h"
 #include "inffast.h"
 
+/* QAT Hardware support */
+#include "qat_zlib.h"
+
+#define QAT_NIBBLE_SHIFT 4
+
 #ifdef MAKEFIXED
 #  ifndef BUILDFIXED
 #    define BUILDFIXED
@@ -100,6 +105,37 @@
 #endif
 local unsigned syncsearch OF((unsigned FAR *have, const unsigned char FAR *buf,
                               unsigned len));
+local int qatCheckHeader OF((z_streamp strm, int flush));
+local int qatAddInputToBufferList OF((z_streamp strm, int flush));
+local int qatAdjustInputBuffers OF((z_streamp strm, int flush));
+local int qatCopyOutputFromBufferList OF((z_streamp strm, int flush));
+local int qatResetInputBufferList OF((z_streamp strm));
+local int qatResetOutputBufferList OF((z_streamp strm));
+local int qatDecodeGzipFooter OF((z_streamp strm));
+local int qatDecodeZlibFooter OF((z_streamp strm));
+local int qatCreateSession OF((z_streamp strm));
+local int qatCloseSession OF((z_streamp strm));
+local int qatSendDecompressionRequest OF((z_streamp strm, int flush));
+local int qatProcessFooter OF((z_streamp strm, int flush));
+local int qatInflateCleanup OF((z_streamp strm));
+local int qatInflateReset OF((z_streamp strm));
+local int qatInflateReset2 OF((z_streamp strm, int windowBits));
+local int qatInflateInit2 OF((z_streamp strm, int windowBits, 
+                              const char* version, int stream_size));
+local int qatInflatePrime OF((z_streamp strm, int bits, int value));
+local int qatInflate OF((z_streamp strm, int flush));
+local int qatInflate_DH895 OF((z_streamp strm, int flush));
+local int qatInflateEnd OF((z_streamp strm));
+local int qatInflateGetDictionary OF((z_streamp strm, Bytef *dictionary, 
+                                      uInt *dictLength));
+local int qatInflateSetDictionary OF((z_streamp strm, const Bytef *dictionary, 
+                                      uInt dictLength));
+local int qatInflateGetHeader OF((z_streamp strm, gz_headerp head));
+local int qatInflateSync OF((z_streamp strm));
+local int qatInflateSyncPoint OF((z_streamp strm));
+local int qatInflateCopy OF((z_streamp dest, z_streamp source));
+local int qatInflateUndermine OF((z_streamp strm, int subvert));
+local long qatInflateMark OF((z_streamp strm));
 
 int ZEXPORT inflateResetKeep(strm)
 z_streamp strm;
@@ -129,6 +165,10 @@
 int ZEXPORT inflateReset(strm)
 z_streamp strm;
 {
+    if (qatIsHardwareDecompressionEnabled()) {
+	    return qatInflateReset(strm);
+    }
+
     struct inflate_state FAR *state;
 
     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
@@ -139,10 +179,92 @@
     return inflateResetKeep(strm);
 }
 
+int ZEXPORT qatInflateReset(strm)
+z_streamp strm;
+{
+    struct inflate_state FAR *state;
+    CpaStatus ret = CPA_STATUS_FAIL;
+    int retValue  = Z_MEM_ERROR;
+    int retryCount = 0;
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+    state->wsize = 0;
+    state->whave = 0;
+    state->wnext = 0;
+    state->clientWorkAround = 0;
+    state->noProgressDetected = 0;
+    if(QAT_DRIVER_TYPE_1_5 == state->qatDriverType){
+        if (state->sessionStarted)
+           qatCloseSession(strm);
+        retValue = qatCreateSession(strm);
+        if(retValue != Z_OK){
+            fprintf(stderr,"QAT is not able to create Session\n");
+            return retValue;        
+        }
+    }
+    else 
+    {
+        if(state->sessionStarted){
+          do{
+              ret = cpaDcResetSession(state->instHandle, state->session); 
+              if(CPA_STATUS_RETRY == ret){
+                  retryCount++;
+                  /*backoff for retry_count % QAT_RETRY_BACKOFF_MODULO_DIVISOR seconds before we retry */
+                  sleep(retryCount % QAT_RETRY_BACKOFF_MODULO_DIVISOR);
+              }
+          }while ((CPA_STATUS_RETRY == ret) && 
+                 ((retryCount <= qatGetMaxNumRetries()) ||
+                 (Z_QAT_INFINITE_MAX_NUM_RETRIES == qatGetMaxNumRetries())));
+
+           /* If we gave up retrying report an error */
+          if(CPA_STATUS_RETRY == ret){
+              fprintf(stderr, "QAT Driver is too busy, retries exhausted, giving up\n");
+              state->sessionStarted = 0; 
+              /* Not Cleaning Memory here as it is very unlikely to get failure from reset as we are synchronous based
+              *  In upstreamed Zlib, memory is not freed in case of failure of deflateReset */
+              return Z_STREAM_ERROR;
+          }
+        }
+        else{
+            retValue = qatCreateSession(strm);
+            if(retValue != Z_OK){
+                fprintf(stderr,"QAT is not able to create Session\n");
+                return retValue;
+            }   
+        }
+    }
+    qatResetInputBufferList(strm);
+    qatResetOutputBufferList(strm);
+    state->qatState = QAT_INF_STATE_HEADER;
+    if(state->qatDriverType >= QAT_DRIVER_TYPE_1_6)
+    {
+        if (NULL != state->simpleFooterBuffer)
+            zmemzero(state->simpleFooterBuffer, state->footerLength);
+    }
+    else
+    {
+        if (NULL != state->footerBuffer)
+            csbReset(state->footerBuffer);
+    }
+    state->footerBytesLeftToCopy = state->footerLength;
+    state->numBytesLeftToCopy = 0;
+    state->positionInOutputBuffer = 0;
+    state->totalBytesPlacedInInputBuffer = 0;
+    state->footerCrc = 0;
+    state->footerFilesize = 0;
+    state->ignoreFurtherExternalInput = 0;
+    state->inputBufferAdjustment = 0;
+    return inflateResetKeep(strm);
+}
+
 int ZEXPORT inflateReset2(strm, windowBits)
 z_streamp strm;
 int windowBits;
 {
+    if (qatIsHardwareDecompressionEnabled()) {
+	    return qatInflateReset2(strm, windowBits);
+    }
+
     int wrap;
     struct inflate_state FAR *state;
 
@@ -177,12 +299,122 @@
     return inflateReset(strm);
 }
 
+int qatInflateReset2(strm, windowBits)
+z_streamp strm;
+int windowBits;
+{
+    int wrap = 0;
+    struct inflate_state FAR *state;
+
+    /* get the state */
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+
+    state->footerLength = 0;
+    state->res.checksum = 1;
+    state->res.endOfLastBlock = CPA_FALSE;
+
+    /* extract wrap request from windowBits parameter */
+    if (windowBits < 0) {
+        windowBits = -windowBits;
+        wrap = 0;
+    }
+    else {
+        wrap = (windowBits >> QAT_NIBBLE_SHIFT) + 1;
+        if (windowBits < 48)
+            windowBits &= 15;
+    }
+    if(state->qatDriverType >= QAT_DRIVER_TYPE_1_6) {
+        if (state->simpleFooterBuffer) {
+            ZFREE(strm, state->simpleFooterBuffer);
+        }
+    }
+    else {
+        csbFree(state->footerBuffer);
+    }
+
+    /* Setup parameter based on the strm->wrap */
+    if ( 0 == wrap ) {
+        state->res.checksum = 0;
+        state->sd.checksum = CPA_DC_NONE;
+        state->footerLength = 0;
+    }
+#ifdef GUNZIP
+    if ( 1 == wrap ) { 
+        state->sd.checksum = CPA_DC_ADLER32;
+        state->footerLength = QAT_DC_ZLIB_FOOTER_SIZE;
+        if(state->qatDriverType >= QAT_DRIVER_TYPE_1_6) {
+            state->simpleFooterBuffer = (unsigned char *)ZALLOC(strm, 1, state->footerLength);
+            if ( NULL == state->simpleFooterBuffer ) {
+                return Z_STREAM_ERROR;
+            }
+        }
+        else {
+            if(!csbInit(state->footerBuffer,  state->footerLength))
+            {
+                return Z_STREAM_ERROR;
+            }
+        }
+    }
+    else if ( wrap > 1  ) { 
+        state->res.checksum = 0;
+        state->sd.checksum = CPA_DC_CRC32;
+        state->footerLength = QAT_DC_GZIP_FOOTER_SIZE;
+        if(state->qatDriverType >= QAT_DRIVER_TYPE_1_6) {
+            state->simpleFooterBuffer = (unsigned char *)ZALLOC(strm, 1, state->footerLength);
+            if ( NULL == state->simpleFooterBuffer ) {
+                return Z_STREAM_ERROR;
+            }
+        }
+        else {
+            if(!csbInit(state->footerBuffer,  state->footerLength))
+            {
+                return Z_STREAM_ERROR;
+            }
+        }
+    }
+#else
+    if ( wrap >= 1  ) { 
+        state->sd.checksum = CPA_DC_ADLER32;
+        state->footerLength = QAT_DC_ZLIB_FOOTER_SIZE;
+        if(state->qatDriverType >= QAT_DRIVER_TYPE_1_6) {
+            state->simpleFooterBuffer = (unsigned char *)ZALLOC(strm, 1, state->footerLength);
+            if ( NULL == state->simpleFooterBuffer ) {
+                return Z_STREAM_ERROR;
+            }
+        }
+        else
+        {
+            if(!csbInit(state->footerBuffer,  state->footerLength))
+            {
+                return Z_STREAM_ERROR;
+            }
+        }
+    }
+#endif
+	   
+    if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {
+        ZFREE(strm, state->window);
+        state->window = Z_NULL;
+    }
+    
+    /* update state and reset the rest of it */
+    state->wrap = wrap;
+    state->wbits = (unsigned)windowBits;
+    return qatInflateReset(strm);
+}
+
+
 int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
 z_streamp strm;
 int windowBits;
 const char *version;
 int stream_size;
 {
+    if (qatIsHardwareDecompressionEnabled()) {
+	    return qatInflateInit2(strm, windowBits, version, stream_size);
+    }
+
     int ret;
     struct inflate_state FAR *state;
 
@@ -219,6 +451,297 @@
     return ret;
 }
 
+int qatInflateInit2(strm, windowBits, version, stream_size)
+z_streamp strm;
+int windowBits;
+const char *version;
+int stream_size;
+{
+    int ret;
+    int wrap;
+    struct inflate_state FAR *state;
+
+    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
+        stream_size != (int)(sizeof(z_stream)))
+        return Z_VERSION_ERROR;
+    if (strm == Z_NULL) return Z_STREAM_ERROR;
+    strm->msg = Z_NULL;                 /* in case we return an error */
+    if (strm->zalloc == (alloc_func)0) {
+#ifdef Z_SOLO
+        return Z_STREAM_ERROR;
+#else
+        strm->zalloc = zcalloc;
+        strm->opaque = (voidpf)0;
+#endif
+    }
+    if (strm->zfree == (free_func)0)
+#ifdef Z_SOLO
+        return Z_STREAM_ERROR;
+#else
+        strm->zfree = zcfree;
+#endif
+    state = (struct inflate_state FAR *)
+            ZALLOC(strm, 1, sizeof(struct inflate_state));
+    if (state == Z_NULL) return Z_MEM_ERROR;
+    Tracev((stderr, "inflate: allocated\n"));
+    strm->state = (struct internal_state FAR *)state;
+    state->window = Z_NULL;
+    
+    /* QAT specific variables and code. */
+    CpaStatus rc               = CPA_STATUS_SUCCESS;
+    Cpa32U metaSize            = 0;
+    int numOfFlatBuffers = 0; 
+
+    state->instHandle = NULL;
+    state->footerLength = 0;
+    state->sessionStarted = 0;
+    state->clientWorkAround = 0;
+    state->noProgressDetected = 0;
+
+    state->instHandle = qatIncrementCurrentInstance();
+    if (NULL == state->instHandle) {
+        fprintf(stderr, "Error: No instances available\n");
+        ZFREE(strm, strm->state);
+        strm->state = Z_NULL;
+        return Z_STREAM_ERROR;
+    }
+    state->qatDriverType=qatGetInstanceDriverType(state->instHandle);
+
+
+    if(state->qatDriverType == QAT_DRIVER_TYPE_1_5) {
+        state->footerBuffer = (CircularCharBuffer *)ZALLOC(strm, 1, sizeof(CircularCharBuffer));
+        if (state->footerBuffer) {
+            zmemzero(state->footerBuffer, sizeof(CircularCharBuffer));
+        } 
+        else {
+            ZFREE(strm, strm->state);
+            strm->state = Z_NULL;
+            return Z_MEM_ERROR;
+        }
+    }
+    /* Set up the DC SessionSetupData */
+    state->sd.compLevel                 = CPA_DC_L7;
+    state->sd.deflateWindowSize         = QAT_32K_WIN_SIZE;
+    state->sd.compType                  = CPA_DC_DEFLATE;
+    state->sd.sessDirection             = CPA_DC_DIR_DECOMPRESS;
+    state->sd.huffType                  = CPA_DC_HT_FULL_DYNAMIC;
+    state->sd.fileType                  = CPA_DC_FT_OTHER;
+    state->sd.autoSelectBestHuffmanTree = CPA_DC_ASB_UNCOMP_STATIC_DYNAMIC_WITH_STORED_HDRS;/* We can have this flag as we only have one type of tree in Decompression process */
+    state->sd.sessState                 = CPA_DC_STATEFUL;
+    state->sd.checksum                  = CPA_DC_NONE;
+
+    state->res.checksum = 1;
+    state->res.endOfLastBlock = CPA_FALSE;
+    
+    /* extract wrap request from windowBits parameter */
+    if (windowBits < 0) {
+        wrap = 0;
+    }
+    else {
+        wrap = (windowBits >> QAT_NIBBLE_SHIFT) + 1;
+    }
+
+    /* Setup parameter based on the strm->wrap */
+    if ( 0 == wrap ) {
+        state->res.checksum = 0;
+        state->sd.checksum = CPA_DC_NONE;
+        state->footerLength = 0;
+        if(state->qatDriverType >= QAT_DRIVER_TYPE_1_6) {
+            state->simpleFooterBuffer = NULL;
+        }
+    }
+#ifdef GUNZIP
+    if ( 1 == wrap ) {
+        state->sd.checksum = CPA_DC_ADLER32;
+        state->footerLength = QAT_DC_ZLIB_FOOTER_SIZE;
+        if(state->qatDriverType >= QAT_DRIVER_TYPE_1_6) {
+            state->simpleFooterBuffer = (unsigned char *)ZALLOC(strm, 1, state->footerLength);
+            if ( NULL == state->simpleFooterBuffer ) {
+                ZFREE(strm, strm->state);
+                strm->state = Z_NULL;
+                return Z_MEM_ERROR;
+            }
+        }
+        else {
+            if(!csbInit(state->footerBuffer,  state->footerLength))
+            {
+                if (NULL != state->footerBuffer) {
+                    ZFREE(strm, state->footerBuffer);
+                    state->footerBuffer = NULL;
+                }
+	
+                ZFREE(strm, strm->state);
+                strm->state = Z_NULL;
+                return Z_MEM_ERROR;
+            }
+        }
+    }
+    else if ( wrap > 1  ) {
+        state->res.checksum = 0; 
+        state->sd.checksum = CPA_DC_CRC32;
+        state->footerLength = QAT_DC_GZIP_FOOTER_SIZE;
+        if(state->qatDriverType >= QAT_DRIVER_TYPE_1_6) {
+            state->simpleFooterBuffer = (unsigned char *)ZALLOC(strm, 1, state->footerLength);
+            if ( NULL == state->simpleFooterBuffer ) {
+                ZFREE(strm, strm->state);
+                strm->state = Z_NULL;
+                return Z_MEM_ERROR;
+            }
+        }
+        else {
+            if(!csbInit(state->footerBuffer,  state->footerLength))
+            {
+                if (NULL != state->footerBuffer) {
+                    ZFREE(strm, state->footerBuffer);
+                    state->footerBuffer = NULL;
+                }
+	
+                ZFREE(strm, strm->state);
+                strm->state = Z_NULL;
+                return Z_MEM_ERROR;
+            }
+        }
+    }
+#else
+    if ( wrap >= 1  ) { 
+        state->sd.checksum = CPA_DC_ADLER32;
+        state->footerLength = QAT_DC_ZLIB_FOOTER_SIZE;
+        if(state->qatDriverType >= QAT_DRIVER_TYPE_1_6) {
+            state->simpleFooterBuffer = (unsigned char *)ZALLOC(strm, 1, state->footerLength);
+            if ( NULL == state->simpleFooterBuffer ) {
+                ZFREE(strm, strm->state);
+                strm->state = Z_NULL;
+                return Z_MEM_ERROR;
+            }
+        }
+        else {
+            if(!csbInit(state->footerBuffer,  state->footerLength))
+            {
+                if (NULL != state->footerBuffer) {
+                    ZFREE(strm, state->footerBuffer);
+                    state->footerBuffer = NULL;
+                }
+	    
+                ZFREE(strm, strm->state);
+                strm->state = Z_NULL;
+                return Z_MEM_ERROR;
+            }
+        }
+    }
+#endif
+	   
+    
+    state->qatState = QAT_INF_STATE_HEADER;
+    state->footerBytesLeftToCopy = state->footerLength;
+    state->nodeId = qatGetNodeId(state->instHandle);
+    state->numBytesLeftToCopy = 0;
+    state->positionInOutputBuffer = 0;
+    state->totalBytesPlacedInInputBuffer = 0;
+    state->footerCrc = 0;
+    state->footerFilesize = 0;
+    state->totalBuffersize = QAT_ZLIB_INTERNAL_FLATBUFFER_SIZE;
+    state->ignoreFurtherExternalInput = 0;
+    state->inputBufferAdjustment = 0;
+    state->wrap = wrap;
+    
+    /* Set up output buffer list */
+    state->totalNumOfOutputBuffers = QAT_ZLIB_NUM_OUTPUT_FLAT_BUFFERS;
+    state->outl.numBuffers       = state->totalNumOfOutputBuffers;
+    state->outl.pBuffers         = state->out;
+    state->outl.pUserData        = NULL;
+    /* Get the size of the Private meta data needed to create Buffer List */
+    rc = cpaDcBufferListGetMetaSize(state->instHandle, 
+                                    state->totalNumOfOutputBuffers, &metaSize);
+    if(CPA_STATUS_SUCCESS != rc ) {
+        fprintf(stderr, "cpaDcBufferListGetMetaSize failed. rc = %d\n", rc);
+        goto qat_err;
+    }
+    state->outl.pPrivateMetaData = qaeZlibPinnedMemAlloc(metaSize, state->nodeId, __FILE__, __LINE__);
+    if (NULL == state->outl.pPrivateMetaData) {
+        fprintf(stderr, "qaeZlibPinnedMemAlloc() failed for state->outl.pPrivateMetaData\n");
+        goto qat_err;
+    }
+
+    /* Set up input buffer list */
+    state->totalNumOfInputBuffers = QAT_ZLIB_NUM_INPUT_FLAT_BUFFERS;
+    state->inl.numBuffers       = state->totalNumOfInputBuffers;
+    state->inl.pBuffers         = state->in;
+    state->inl.pUserData        = NULL;
+    /* Get the size of the Private meta data needed to create Buffer List */
+    rc = cpaDcBufferListGetMetaSize(state->instHandle, 
+                                    state->totalNumOfInputBuffers, &metaSize);
+    if(CPA_STATUS_SUCCESS != rc ) {
+        fprintf(stderr, "cpaDcBufferListGetMetaSize failed. rc = %d\n", rc);
+        goto qat_err;
+    }
+    state->inl.pPrivateMetaData = qaeZlibPinnedMemAlloc(metaSize, state->nodeId, __FILE__, __LINE__);
+    if (NULL == state->inl.pPrivateMetaData) {
+        fprintf(stderr, "qaeZlibPinnedMemAlloc() failed for state->inl.pPrivateMetaData\n");
+        goto qat_err;
+    }
+
+    /* Set up the output buffer */
+    state->out = (CpaFlatBuffer *)ZALLOC(strm, 1, 
+                 sizeof(CpaFlatBuffer) * (state->totalNumOfOutputBuffers));
+    state->currentOutputBuffer = state->out;
+    if (NULL == state->out) {
+        fprintf(stderr, "ZALLOC() failed for state->out\n");
+        goto qat_err;
+    }
+    for(numOfFlatBuffers = 0; numOfFlatBuffers < state->totalNumOfOutputBuffers; 
+        numOfFlatBuffers++) {
+       state->currentOutputBuffer->pData = (Cpa8U *) qaeZlibPinnedMemAlloc(QAT_ZLIB_INTERNAL_FLATBUFFER_SIZE,
+                                                                       state->nodeId, __FILE__, __LINE__);
+       if (NULL == state->currentOutputBuffer->pData) {
+           fprintf(stderr, "qaeZlibPinnedMemAlloc() failed for state->out\n");
+           goto qat_err;
+       }
+       state->currentOutputBuffer->dataLenInBytes = QAT_ZLIB_INTERNAL_FLATBUFFER_SIZE;
+       state->currentOutputBuffer++;
+    }
+
+    state->currentOutputBuffer = state->out;
+
+    /* Set up the input buffer */
+    state->in = (CpaFlatBuffer *)ZALLOC(strm, 1,
+                sizeof(CpaFlatBuffer) * (state->totalNumOfInputBuffers));
+    state->currentInputBuffer = state->in;
+    if (NULL == state->in) {
+        fprintf(stderr, "ZALLOC() failed for state->in\n");
+        goto qat_err;
+    }
+    for(numOfFlatBuffers = 0; numOfFlatBuffers < state->totalNumOfInputBuffers; 
+        numOfFlatBuffers++) {
+       state->currentInputBuffer->pData = (Cpa8U *) qaeZlibPinnedMemAlloc(state->totalBuffersize, state->nodeId, __FILE__, __LINE__);
+       if (NULL == state->currentInputBuffer->pData) {
+           fprintf(stderr, "qaeZlibPinnedMemAlloc() failed for state->in\n");
+           goto qat_err;
+       }
+       state->currentInputBuffer->dataLenInBytes = 0;
+       state->currentInputBuffer++;
+    }
+    state->currentInputBuffer = state->in;
+    state->fullInputBuffers = 0;
+  
+    state->inl.pBuffers         = state->in;
+    state->outl.pBuffers        = state->out;
+	
+    ret = qatInflateReset2(strm, windowBits);
+    if (ret != Z_OK) {
+       goto qat_err;
+    }
+    return ret;
+
+
+qat_err:
+   
+    qatInflateCleanup(strm);
+
+    return Z_MEM_ERROR;
+
+
+}
+
 int ZEXPORT inflateInit_(strm, version, stream_size)
 z_streamp strm;
 const char *version;
@@ -232,6 +755,10 @@
 int bits;
 int value;
 {
+    if (qatIsHardwareDecompressionEnabled()) {
+	    return qatInflatePrime(strm, bits, value);
+	}
+
     struct inflate_state FAR *state;
 
     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
@@ -248,6 +775,15 @@
     return Z_OK;
 }
 
+int qatInflatePrime(strm, bits, value)
+z_streamp strm;
+int bits;
+int value;
+{
+    /* not supported when using hardware acceleration */
+    return Z_STREAM_ERROR;
+}
+
 /*
    Return state with length and distance decoding tables and index sizes set to
    fixed code decoding.  Normally this returns fixed tables from inffixed.h.
@@ -303,7 +839,7 @@
 
 #ifdef MAKEFIXED
 #include <stdio.h>
-
+local void qatMakeFixed OF((void));
 /*
    Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
    defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
@@ -324,6 +860,10 @@
  */
 void makefixed()
 {
+    if (qatIsHardwareDecompressionEnabled()) {
+	    qatMakeFixed();
+	}
+	else {
     unsigned low, size;
     struct inflate_state state;
 
@@ -360,6 +900,13 @@
     }
     puts("\n    };");
 }
+}
+
+void qatMakeFixed()
+{
+    /* not supported when using hardware acceleration */
+}
+
 #endif /* MAKEFIXED */
 
 /*
@@ -426,7 +973,634 @@
     return 0;
 }
 
-/* Macros for inflate(): */
+/* ======================================================================= */
+local int qatAddInputToBufferList (strm, flush)
+      z_streamp strm;
+      int flush;
+{
+    struct inflate_state FAR *s;
+    uInt avail_in = 0;
+    Bytef * next_in = NULL;
+    uLong total_in = 0;
+    s = (struct inflate_state FAR *)strm->state;
+    
+    /* For DH895xcc we don't want to update strm->avail_in, strm->next_in
+       or strm->total_in as due to needing to support multigzip streams we will do this 
+       after a decompression operation. To keep the logic below a bit simpler we will
+       just backup the values here and then restore them before we return. */
+    if(s->qatDriverType >= QAT_DRIVER_TYPE_1_6) {
+        avail_in = strm->avail_in;
+        next_in = strm->next_in;
+        total_in = strm->total_in; 
+    }
+    
+    /* If we get called with zero bytes of input but the final block then we need to
+       sort out the number of buffers ready to submit the decompression request.
+       This is because we may already have data in the pinned input buffers that hasn't
+       been submitted yet */
+    if (0 == strm->avail_in && Z_FINISH == flush) {
+        if (0 != s->currentInputBuffer->dataLenInBytes &&
+           (s->fullInputBuffers < s->totalNumOfInputBuffers)) {
+            s->fullInputBuffers++;
+        }
+        s->inl.numBuffers = s->fullInputBuffers;
+    }
+   
+    /* Keep copying input while there are flatbuffers available to copy into and there are 
+       bytes to copy */ 
+    while ((s->fullInputBuffers < s->totalNumOfInputBuffers) && (strm->avail_in > 0)) {
+          /* Is there room in the current flatbuffer for all the input data */
+          if ((s->totalBuffersize - s->currentInputBuffer->dataLenInBytes) >= strm->avail_in) {
+             /* Yes there is so lets copy all the data in and update counters and pointers*/
+             memcpy(s->currentInputBuffer->pData+s->currentInputBuffer->dataLenInBytes,
+                    strm->next_in, strm->avail_in);
+             s->currentInputBuffer->dataLenInBytes+= strm->avail_in;            
+             strm->total_in += strm->avail_in;
+             s->totalBytesPlacedInInputBuffer += strm->avail_in;
+             strm->next_in += strm->avail_in; 
+             strm->avail_in = 0;
+             /* If this is the last data block then there will be no more input so lets tidy
+                our number of buffers ready to submit the decompression request */
+             if (flush == Z_FINISH) {
+                s->fullInputBuffers++;
+                s->inl.numBuffers = s->fullInputBuffers;
+             }
+          }
+          else {
+            /* No there wasn't room in the flatbuffer for all the input data so lets just copy
+               as much as we can into it, update the counters and pointers, and move onto the
+               next flatbuffer */
+            memcpy(s->currentInputBuffer->pData+s->currentInputBuffer->dataLenInBytes, 
+                   strm->next_in, s->totalBuffersize - s->currentInputBuffer->dataLenInBytes);
+            strm->avail_in -= (s->totalBuffersize - s->currentInputBuffer->dataLenInBytes);
+            strm->next_in += (s->totalBuffersize - s->currentInputBuffer->dataLenInBytes); 
+            strm->total_in += (s->totalBuffersize - s->currentInputBuffer->dataLenInBytes);
+            s->totalBytesPlacedInInputBuffer += 
+                          (s->totalBuffersize - s->currentInputBuffer->dataLenInBytes);
+            s->currentInputBuffer->dataLenInBytes = s->totalBuffersize;
+            s->fullInputBuffers++;
+            s->currentInputBuffer++;
+          }
+    }
+    
+    if(s->qatDriverType >= QAT_DRIVER_TYPE_1_6) {
+        strm->avail_in = avail_in;
+        strm->next_in = next_in;
+        strm->total_in = total_in;
+    }
+    
+    return Z_OK;
+}
+
+/* ======================================================================= */
+local int qatAdjustInputBuffers (strm, flush)
+      z_streamp strm;
+      int flush;
+{
+    struct inflate_state FAR *s;
+    s = (struct inflate_state FAR *)strm->state;
+    int bytesToBeWalked = s->res.consumed;
+    int foundStartOfData = 0;
+    int numBuffersWalked = 0;
+    int position = 0;
+    int destPosition = 0;
+    CpaFlatBuffer *destinationInputBuffer;
+    int numDestBuffersWalked = 0;
+    int spaceInBuffer = 0;
+    int bytesToCopy = 0;
+    int numOfFlatBuffers = 0;
+    s->fullInputBuffers = 0;
+    /* Calculate how many bytes need copying out of the pinned input buffer */
+    int bytesToBackup = s->totalBytesPlacedInInputBuffer - s->res.consumed;
+    s->currentInputBuffer=s->in;
+    destinationInputBuffer=s->in;
+
+    QATDEBUG("*** qatAdjustInputBuffers ***\n");
+    QATDEBUG("Bytes to Backup: %d\n", bytesToBackup);
+    /* Loop while there are still bytes to backup and we haven't looped through all the 
+       flatbuffers */
+    while (bytesToBackup && (numBuffersWalked < s->totalNumOfInputBuffers)) {
+         /* Have we already reached the point where the data to be copied out starts */
+         if (foundStartOfData) {
+               /* We need to work out if we can fit all the data into the current buffer */
+             spaceInBuffer = s->totalBuffersize - 
+                                 destinationInputBuffer->dataLenInBytes;
+             bytesToCopy = (bytesToBackup < 
+                       (s->totalBuffersize - position) ?
+                       bytesToBackup :
+                       (s->totalBuffersize - position));
+             if (bytesToCopy > spaceInBuffer) {
+                 bytesToCopy = spaceInBuffer;
+                 memmove(destinationInputBuffer->pData+destinationInputBuffer->dataLenInBytes, 
+                         s->currentInputBuffer->pData+position, 
+                         bytesToCopy);
+                 bytesToBackup -= bytesToCopy;
+                 destinationInputBuffer->dataLenInBytes += bytesToCopy;
+                 s->fullInputBuffers++;
+                 destinationInputBuffer++;
+                 destinationInputBuffer->dataLenInBytes = 0;
+                 numDestBuffersWalked++;
+                 destPosition = 0;
+                 position += bytesToCopy;        
+             }
+             else {
+                 memmove(destinationInputBuffer->pData+destinationInputBuffer->dataLenInBytes, 
+                         s->currentInputBuffer->pData+position, 
+                         bytesToCopy);
+                 bytesToBackup -= bytesToCopy;
+                 destPosition += bytesToCopy;      
+                 destinationInputBuffer->dataLenInBytes += bytesToCopy;
+                 if (destinationInputBuffer->dataLenInBytes == 
+                     s->totalBuffersize ) {
+                     s->fullInputBuffers++;
+                     destinationInputBuffer++;
+                     destinationInputBuffer->dataLenInBytes = 0;
+                     numDestBuffersWalked++;
+                     destPosition = 0;
+                 }
+                 s->currentInputBuffer++;
+                 numBuffersWalked++;
+                 position = 0;
+             }
+         }
+         else {
+             /* We haven't found the start of the data yet, so lets check whether we are 
+                going to find the start in this buffer */ 
+             if (s->currentInputBuffer->dataLenInBytes <= bytesToBeWalked) {
+                 /* No we are not so lets update counters and pointers and move onto the
+                    next flatbuffer */ 
+                 bytesToBeWalked -= s->currentInputBuffer->dataLenInBytes;
+                 s->currentInputBuffer++;
+                 numBuffersWalked++;
+             }
+             else {
+                 /* Yes we've found the start of the data in the current buffer so lets set
+                    the flag and copy data to the new position, then move onto the next
+                    flatbuffer */
+                 foundStartOfData = 1;
+                 memmove(destinationInputBuffer->pData, 
+                         s->currentInputBuffer->pData+bytesToBeWalked, 
+                         s->currentInputBuffer->dataLenInBytes - bytesToBeWalked);
+                 bytesToBackup -= (s->currentInputBuffer->dataLenInBytes - bytesToBeWalked);
+                 destPosition = (s->currentInputBuffer->dataLenInBytes - bytesToBeWalked);
+                 destinationInputBuffer->dataLenInBytes = 
+                     s->currentInputBuffer->dataLenInBytes - bytesToBeWalked;
+                 if (destinationInputBuffer->dataLenInBytes == 
+                     s->totalBuffersize ) {
+                     s->fullInputBuffers++;
+                     destinationInputBuffer++;
+                     destinationInputBuffer->dataLenInBytes = 0;
+                     numDestBuffersWalked++;
+                     destPosition = 0;
+                 }
+                    
+                 bytesToBeWalked = 0;
+                 s->currentInputBuffer++;
+                 numBuffersWalked++;
+                 position = 0;
+             }
+        }
+    }
+    s->totalBytesPlacedInInputBuffer -= s->res.consumed; 
+    s->currentInputBuffer = destinationInputBuffer;
+    if (Z_FINISH == flush && 0 == strm->avail_in) {
+        if (destinationInputBuffer->dataLenInBytes != 0) {    
+            s->fullInputBuffers++;
+        }
+        s->inl.numBuffers = s->fullInputBuffers;
+    }
+    if (destPosition > 0) {
+        destinationInputBuffer++;
+        numDestBuffersWalked++;
+    }
+    /* reset the rest of the input buffers to 0 */
+    for(numOfFlatBuffers = numDestBuffersWalked; 
+        numOfFlatBuffers < s->totalNumOfInputBuffers; 
+        numOfFlatBuffers++) {
+       destinationInputBuffer->dataLenInBytes=0;
+       destinationInputBuffer++;
+    }
+
+    QATDEBUG("Total Bytes Placed in Input Buffer: %d\n", s->totalBytesPlacedInInputBuffer);
+    QATDEBUG("*** End qatAdjustInputBuffers ***\n");
+    return Z_OK;
+}
+
+
+/* ======================================================================= */
+local int qatResetInputBufferList (strm)
+      z_streamp strm;
+{
+    int numOfFlatBuffers = 0;
+    struct inflate_state FAR *s;
+    s = (struct inflate_state FAR *)strm->state;
+    s->currentInputBuffer=s->in;
+    /* Ensure the dataLenInBytes field gets reset for each flatbuffer */
+    for(numOfFlatBuffers = 0; numOfFlatBuffers < s->totalNumOfInputBuffers; numOfFlatBuffers++) {
+       s->currentInputBuffer->dataLenInBytes=0;
+       s->currentInputBuffer++;
+    }
+    s->currentInputBuffer=s->in;
+    s->fullInputBuffers = 0;
+    s->totalBytesPlacedInInputBuffer = 0;
+    return Z_OK;
+}
+
+/* ======================================================================= */
+local int qatResetOutputBufferList (strm)
+      z_streamp strm;
+{
+    int numOfFlatBuffers = 0;
+    struct inflate_state FAR *s;
+    s = (struct inflate_state FAR *)strm->state;
+    s->currentOutputBuffer=s->out;
+    /* Ensure the dataLenInBytes field gets reset for each flatbuffer */
+    for(numOfFlatBuffers = 0; numOfFlatBuffers < s->totalNumOfOutputBuffers; numOfFlatBuffers++) {
+       s->currentOutputBuffer->dataLenInBytes=QAT_ZLIB_INTERNAL_FLATBUFFER_SIZE;
+       s->currentOutputBuffer++;
+    }
+    s->currentOutputBuffer=s->out;
+    s->numBytesLeftToCopy = 0;
+    s->positionInOutputBuffer = 0;
+    s->outl.numBuffers = s->totalNumOfOutputBuffers;
+    return Z_OK;
+}
+
+/* ======================================================================= */
+local int qatCopyOutputFromBufferList (strm, flush)
+      z_streamp strm;
+      int flush;
+{
+    int bytesToCopy = 0;
+    int bytesCopied = 0;
+    struct inflate_state FAR *s;
+    s = (struct inflate_state FAR *)strm->state;
+    /* Keep copying output while there are bytes to copy and there is room in the output buffer */
+    while (s->numBytesLeftToCopy && strm->avail_out) {
+         bytesToCopy = ((s->numBytesLeftToCopy < 
+                       ((s->currentOutputBuffer->dataLenInBytes) - (s->positionInOutputBuffer))) ?
+                       s->numBytesLeftToCopy :
+                       ((s->currentOutputBuffer->dataLenInBytes) - (s->positionInOutputBuffer)));
+         /* Check if we can fit the whole of what's left in the flatbuffer into the
+            output buffer */
+         if (bytesToCopy > strm->avail_out) {
+             /* We can't so lets copy strm->avail bytes into the output buffer and
+                update all the counters and pointers */
+             bytesCopied=0;  
+             memcpy(strm->next_out, (s->currentOutputBuffer->pData) +
+                   (s->positionInOutputBuffer), strm->avail_out);
+             bytesCopied = strm->avail_out;
+             s->positionInOutputBuffer += bytesCopied;
+             s->numBytesLeftToCopy -= bytesCopied;
+             strm->next_out+=bytesCopied;
+             strm->total_out+=bytesCopied;
+             strm->avail_out-=bytesCopied;
+         }
+         else {
+             /* We can fit all the bytes from the flatbuffer so lets just copy all (bytesToCopy)
+                into the output buffer and update all counters and pointers moving onto any
+                subsequent flatbuffer for next time round the loop */
+             memcpy(strm->next_out, (s->currentOutputBuffer->pData) + 
+                   (s->positionInOutputBuffer), bytesToCopy); 
+             s->numBytesLeftToCopy -= bytesToCopy;
+             strm->next_out+=bytesToCopy;
+             strm->total_out+=bytesToCopy;
+             strm->avail_out-=bytesToCopy;
+             s->currentOutputBuffer++;
+             s->positionInOutputBuffer=0;
+         }
+    }
+    return Z_OK;
+}
+
+/* ======================================================================= */
+local int qatDecodeGzipFooter(z_streamp strm)
+{
+   unsigned char tempChar=0;
+   struct inflate_state FAR *s;
+   s = (struct inflate_state FAR *)strm->state;
+  
+   /* The gzip footer consists of 8 bytes, the first 4 bytes are the crc32.
+      The next 4 bytes are the filesize. */
+   if(s->qatDriverType >= QAT_DRIVER_TYPE_1_6) {
+       memcpy(&(s->footerCrc), s->simpleFooterBuffer, 4);
+       memcpy(&(s->footerFilesize), s->simpleFooterBuffer+4, 4);
+       return Z_OK;   
+   }
+   if (QAT_DC_GZIP_FOOTER_SIZE == csbCount(s->footerBuffer)) {
+       csbRead(s->footerBuffer, (unsigned char*)&tempChar);
+       s->footerCrc = (uLong)(tempChar & 0x000000ff);
+       csbRead(s->footerBuffer, (unsigned char*)&tempChar);
+       s->footerCrc += (uLong)((tempChar << 8) & 0x0000ff00);
+       csbRead(s->footerBuffer, (unsigned char*)&tempChar);
+       s->footerCrc += (uLong)((tempChar << 16) & 0x00ff0000);
+       csbRead(s->footerBuffer, (unsigned char*)&tempChar);
+       s->footerCrc += (uLong)((tempChar << 24) & 0xff000000);
+       csbRead(s->footerBuffer, (unsigned char*)&tempChar);
+       s->footerFilesize = (uLong)(tempChar & 0x000000ff);
+       csbRead(s->footerBuffer, (unsigned char*)&tempChar);
+       s->footerFilesize += (uLong)((tempChar << 8) & 0x0000ff00);
+       csbRead(s->footerBuffer, (unsigned char*)&tempChar);
+       s->footerFilesize += (uLong)((tempChar << 16) & 0x00ff0000);
+       csbRead(s->footerBuffer, (unsigned char*)&tempChar);
+       s->footerFilesize += (uLong)((tempChar << 24) & 0xff000000);
+       return Z_OK;
+   }
+   return Z_STREAM_ERROR;
+}
+
+/* ======================================================================= */
+local int qatDecodeZlibFooter(z_streamp strm)
+{
+   unsigned char tempChar=0;
+   struct inflate_state FAR *s;
+   s = (struct inflate_state FAR *)strm->state;
+   /* zlib footers are only 4 bytes containing the adler32 and no filesize */
+   /* Note: the endianess is the other way round on adler32 so process 
+      appropriately */ 
+   if(s->qatDriverType >= QAT_DRIVER_TYPE_1_6) {
+       s->footerCrc = (uLong)((s->simpleFooterBuffer[0] << 24) & 0xff000000);
+       s->footerCrc += (uLong)((s->simpleFooterBuffer[1] << 16) & 0x00ff0000);
+       s->footerCrc += (uLong)((s->simpleFooterBuffer[2] << 8) & 0x0000ff00);
+       s->footerCrc += (uLong)(s->simpleFooterBuffer[3] & 0x000000ff);
+       return Z_OK;
+   }
+
+   if (QAT_DC_ZLIB_FOOTER_SIZE == csbCount(s->footerBuffer)) {
+       csbRead(s->footerBuffer, (unsigned char*)&tempChar);
+       s->footerCrc = (uLong)((tempChar << 24) & 0xff000000);
+       csbRead(s->footerBuffer, (unsigned char*)&tempChar);
+       s->footerCrc += (uLong)((tempChar << 16) & 0x00ff0000);
+       csbRead(s->footerBuffer, (unsigned char*)&tempChar);
+       s->footerCrc += (uLong)((tempChar << 8) & 0x0000ff00);
+       csbRead(s->footerBuffer, (unsigned char*)&tempChar);
+       s->footerCrc += (uLong)(tempChar & 0x000000ff);
+       return Z_OK;
+   }
+   return Z_STREAM_ERROR;
+}
+
+/* ======================================================================= */
+local int qatCreateSession(z_streamp strm)
+{
+    Cpa32U sessSize            = 0;
+    Cpa32U cntxtSize           = 0;
+    CpaStatus rc               = CPA_STATUS_SUCCESS;
+    Cpa32U metaSize            = 0;
+    struct inflate_state FAR *s;
+    s = (struct inflate_state FAR *)strm->state;
+    if (NULL == s) {
+        fprintf(stderr, "state is NULL\n");
+        return Z_MEM_ERROR;
+    } 
+
+    s->contextBuffList.pPrivateMetaData = NULL; 
+    s->contextBuffList.numBuffers = 0; 
+    s->contextBuffList.pBuffers = NULL;
+    s->contextFlatBuffer.pData = NULL;
+    s->contextFlatBuffer.dataLenInBytes = 0;
+    
+ 
+    /* Get the DC session size */
+    rc = cpaDcGetSessionSize(s->instHandle, &(s->sd), &sessSize, &cntxtSize );
+    if(CPA_STATUS_SUCCESS != rc) {
+        fprintf(stderr, "cpaDcGetSessionSize failed. rc = %d\n", rc);
+        return Z_MEM_ERROR;
+    }
+
+    /* Get the size of the Private meta data needed to create Buffer List */
+    rc = cpaDcBufferListGetMetaSize(s->instHandle, 1, &metaSize);
+    if(CPA_STATUS_SUCCESS != rc ) {
+       fprintf(stderr, "cpaDcBufferListGetMetaSize failed. rc = %d\n", rc);
+       return Z_MEM_ERROR;
+    }
+
+    /* Allocate the memory for the private metadata */
+    s->contextBuffList.pPrivateMetaData = qaeZlibPinnedMemAlloc(metaSize, s->nodeId, __FILE__, __LINE__);
+    if(NULL == s->contextBuffList.pPrivateMetaData) {
+       fprintf(stderr, "Failed to allocate memory for pPrivateMetaData\n");
+       return Z_MEM_ERROR;
+    }
+
+    /* Allocate flat buffers */
+    s->contextBuffList.numBuffers = 1;
+    s->contextBuffList.pBuffers = &(s->contextFlatBuffer);
+    if (NULL == s->contextBuffList.pBuffers) {
+        fprintf(stderr, "ZALLOC() failed for s->contextBuffList.pBuffers\n");
+        return Z_MEM_ERROR;
+    }
+
+    s->contextBuffList.pBuffers->pData =  qaeZlibPinnedMemAlloc(cntxtSize, s->nodeId, __FILE__, __LINE__);
+    if (NULL == s->contextBuffList.pBuffers->pData) {
+        fprintf(stderr, "qaeZlibPinnedMemAlloc() failed for \
+                         s->contextBuffList.pBuffers->pData\n");
+        return Z_MEM_ERROR;
+    }
+
+    s->contextBuffList.pBuffers->dataLenInBytes = cntxtSize;
+
+    /* Get the session handle */
+    s->session = (CpaDcSessionHandle) qaeZlibPinnedMemAlloc(sessSize, s->nodeId, __FILE__, __LINE__);
+    if (NULL == s->session) {
+       fprintf(stderr, "qaeZlibPinnedMemAlloc() failed for s->session\n");
+       return Z_MEM_ERROR;
+    }
+
+    /* Initialise the DC session */
+    rc = cpaDcInitSession( s->instHandle, s->session, &(s->sd), 
+                           &(s->contextBuffList), qat_callbackFn ); 
+    if(CPA_STATUS_SUCCESS != rc) {
+        fprintf(stderr, "cpaDcInitSession failed. rc = %d\n", rc);
+        return Z_MEM_ERROR;
+    }
+
+    s->sessionStarted = 1;
+
+    return Z_OK;
+}
+ 
+/* ======================================================================= */
+local int qatCloseSession(z_streamp strm)
+{
+    CpaStatus rc               = CPA_STATUS_SUCCESS;
+    struct inflate_state FAR *s;
+    s = (struct inflate_state FAR *)strm->state;
+
+    if (NULL != s->instHandle) {
+        rc = cpaDcRemoveSession(s->instHandle, s->session);
+	    if (rc != CPA_STATUS_SUCCESS) {
+            fprintf(stderr, "cpaDcRemoveSession failed - ignoring\n");
+		}
+    }
+
+    if (NULL != s->session) {
+        qaeZlibPinnedMemFree(s->session);
+        s->session = NULL;
+    }
+
+    if (NULL != s->contextBuffList.pBuffers) {
+        if (NULL != s->contextBuffList.pBuffers->pData) {
+            qaeZlibPinnedMemFree(s->contextBuffList.pBuffers->pData);
+            s->contextBuffList.pBuffers->pData = NULL;
+            s->contextBuffList.pBuffers = NULL;
+        }
+    }
+       
+    if (NULL != s->contextBuffList.pPrivateMetaData) {
+        qaeZlibPinnedMemFree(s->contextBuffList.pPrivateMetaData);
+        s->contextBuffList.pPrivateMetaData = NULL;
+    }
+
+    s->sessionStarted = 0;
+
+    return Z_OK;
+}
+
+/* ======================================================================= */
+local int qatSendDecompressionRequest(strm, flush)
+    z_streamp strm;
+    int flush;
+{
+    struct inflate_state FAR *state;
+    CpaStatus rc;
+    struct op_done opDone;
+    int retry_count = 0;
+    CpaDcFlush flushType = CPA_DC_FLUSH_SYNC;
+    state = (struct inflate_state FAR *)strm->state;
+          
+    /* if we are on the final call to inflate and there is no data left in the input buffer
+       then set flush type to CPA_DC_FLUSH_FINAL to indicate it's the last call. */
+    if ((Z_FINISH == flush) && (0 == strm->avail_in)) {
+        flushType = CPA_DC_FLUSH_FINAL;
+    }    
+    if(state->qatDriverType >= QAT_DRIVER_TYPE_1_6) {
+        if ((Z_FINISH == flush) && ((strm->avail_in + state->inputBufferAdjustment)
+                                      <= state->totalBytesPlacedInInputBuffer)) {
+           QATDEBUG("Setting CPA_DC_FLUSH_FINAL\n");
+           flushType = CPA_DC_FLUSH_FINAL;
+        }
+    
+        if (state->noProgressDetected > 3) {
+            QATDEBUG("Setting CPA_DC_FLUSH_FINAL\n");
+            flushType = CPA_DC_FLUSH_FINAL;
+        }
+    }
+
+    qatInitOpDone(&opDone);
+
+    do {
+        /* Decompress the data */
+        rc = cpaDcDecompressData(
+             state->instHandle,
+             state->session,
+             &(state->inl),
+             &(state->outl),
+             &(state->res),
+             flushType,
+             &opDone); 
+
+        /* deal with any errors */
+        if ( CPA_STATUS_RETRY == rc ) {
+            retry_count++;
+            /* backoff for retry_count % QAT_RETRY_BACKOFF_MODULO_DIVISOR seconds before we retry */
+            sleep(retry_count % QAT_RETRY_BACKOFF_MODULO_DIVISOR);
+        }
+        else if ( CPA_STATUS_SUCCESS != rc ) {
+            fprintf(stderr, "Data decompression unsuccessful, status = %d\n", rc);
+            qatCleanupOpDone(&opDone);
+            return Z_DATA_ERROR;
+        }
+
+    } while ((CPA_STATUS_RETRY == rc) && 
+            ((retry_count <= qatGetMaxNumRetries()) || 
+            (Z_QAT_INFINITE_MAX_NUM_RETRIES == qatGetMaxNumRetries())));
+
+    /* If we gave up retrying then report an error message */ 
+    if (CPA_STATUS_RETRY == rc) {
+        fprintf(stderr, "QAT Driver is too busy, retries exhausted, giving up\n");
+        qatCleanupOpDone(&opDone);
+        return Z_DATA_ERROR;
+    }
+
+    /* Wait for cpaDcDecompressData to complete */
+    qatWaitForOpToComplete(&opDone);
+    qatCleanupOpDone(&opDone);
+    
+    return Z_OK;
+}
+
+
+/* ======================================================================= */
+local int qatProcessFooter(strm, flush)
+      z_streamp strm;
+      int flush;
+{
+    struct inflate_state FAR *state;
+    state = (struct inflate_state FAR *)strm->state;
+    /* we are finished so check the footer depending on state->wrap to determine
+       whether there is a footer and what type */
+    if ((1 == state->clientWorkAround) && (1 == strm->avail_in)) {
+        strm->avail_in = 0; /* Workaround for badly behaved clients */
+    }
+       
+#ifdef GUNZIP
+    if ( 1 == state->wrap ) {
+        /* Check zlib Footer Adler */
+        if (qatDecodeZlibFooter(strm) != Z_OK) { 
+            fprintf(stderr, "footer missing\n");
+            state->qatState = QAT_INF_STATE_ERROR;
+            return Z_STREAM_ERROR; 
+        }
+        if ( strm->adler == state->footerCrc ) {
+            state->qatState = QAT_INF_STATE_FINISHED;
+            return Z_STREAM_END;
+        } 
+        fprintf(stderr, "Missing Footer/Incorrect Adler\n");
+        state->qatState = QAT_INF_STATE_ERROR;
+        return Z_STREAM_ERROR;
+    }
+    else if ( state->wrap > 1 ) {
+        /* Check Gzip Footer CRC and Filesize*/
+        if (qatDecodeGzipFooter(strm) != Z_OK) {
+	        fprintf(stderr, "footer missing\n");
+            state->qatState = QAT_INF_STATE_ERROR;
+	        return Z_STREAM_ERROR;
+	    }
+        if ((strm->adler == state->footerCrc ) && 
+           ((strm->total_out & 0xffffffffL) == state->footerFilesize))
+        {
+            state->qatState = QAT_INF_STATE_FINISHED;
+            return Z_STREAM_END;
+        } 
+
+        fprintf(stderr, "Missing Footer/Incorrect CRC/Incorrect Filesize\n");
+        state->qatState = QAT_INF_STATE_ERROR;
+        return Z_STREAM_ERROR;
+    }
+#else
+    if ( state->wrap >= 1 ) {
+        /* Check zlib Footer Adler */
+        if (qatDecodeZlibFooter(strm) != Z_OK) { 
+            fprintf(stderr, "footer missing\n");
+            state->qatState = QAT_INF_STATE_ERROR;
+            return Z_STREAM_ERROR; 
+        }
+        if ( strm->adler == state->footerCrc ) {
+            state->qatState = QAT_INF_STATE_FINISHED;
+            return Z_STREAM_END;
+        } 
+        fprintf(stderr, "Missing Footer/Incorrect Adler\n");
+        state->qatState = QAT_INF_STATE_ERROR;
+        return Z_STREAM_ERROR;
+    }
+#endif 
+    /* wrap == 0 so we are processing raw deflate data, no need to check for footer */
+    state->qatState = QAT_INF_STATE_FINISHED;        
+    return Z_STREAM_END;
+}
+
+/* ======================================================================= */
+/* Macros for inflate(): */
 
 /* check function to use adler32() for zlib or crc32() for gzip */
 #ifdef GUNZIP
@@ -606,6 +1780,9 @@
 z_streamp strm;
 int flush;
 {
+    if (qatIsHardwareDecompressionEnabled()) {
+        return qatInflate(strm, flush);
+    }
     struct inflate_state FAR *state;
     z_const unsigned char FAR *next;    /* next input */
     unsigned char FAR *put;     /* next output */
@@ -1251,98 +2428,708 @@
     return ret;
 }
 
-int ZEXPORT inflateEnd(strm)
+int qatInflate_DH895(strm, flush)
 z_streamp strm;
+int flush;
 {
     struct inflate_state FAR *state;
-    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
+    int rc = Z_OK;
+    int footerBufferLoop = 0;
+    int footerBytesToCopy = 0;
+    int hdrRet = QAT_RET_HEADER_COMPLETE;
+    if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
+        (strm->next_in == Z_NULL && strm->avail_in != 0)) {
+        if(strm != Z_NULL && strm->state != Z_NULL)
+            ((struct inflate_state FAR *) strm->state)->qatState = QAT_INF_STATE_ERROR;
         return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->window != Z_NULL) ZFREE(strm, state->window);
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-    Tracev((stderr, "inflate: end\n"));
-    return Z_OK;
 }
-
-int ZEXPORT inflateGetDictionary(strm, dictionary, dictLength)
-z_streamp strm;
-Bytef *dictionary;
-uInt *dictLength;
-{
-    struct inflate_state FAR *state;
-
-    /* check state */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
     state = (struct inflate_state FAR *)strm->state;
 
-    /* copy dictionary */
-    if (state->whave && dictionary != Z_NULL) {
-        zmemcpy(dictionary, state->window + state->wnext,
-                state->whave - state->wnext);
-        zmemcpy(dictionary + state->whave - state->wnext,
-                state->window, state->wnext);
+    QATDEBUG("*** qatInflate ***\n");
+    QATDEBUG("state->numBytesLeftToCopy = %d\n", state->numBytesLeftToCopy);
+    QATDEBUG("state->ignoreFurtherExternalInput = %d\n", state->ignoreFurtherExternalInput);
+    QATDEBUG("strm->avail_in = %d\n", strm->avail_in);
+    QATDEBUG("strm->avail_out = %d\n", strm->avail_out);
+    QATDEBUG("state->total = %ld\n", state->total);
+    QATDEBUG("strm->total_in = %ld\n", strm->total_in);
+    QATDEBUG("strm->total_out = %ld\n", strm->total_out);
+    QATDEBUG("flush = %ld\n", flush);
+
+    /* If there are bytes left in the pinned output buffer then copy them
+       to the actual output buffer - lets do this whatever state we are in.*/	
+    if (state->numBytesLeftToCopy) {
+       qatCopyOutputFromBufferList(strm, flush);
+       /* If we filled the output buffer then return Z_OK so it can be emptied */
+       if (0 == strm->avail_out) return Z_OK;
+    }
+
+    switch (state->qatState) {
+
+    case QAT_INF_STATE_HEADER:
+        QATDEBUG("*QAT_INF_STATE_HEADER*\n");
+        /* We are at the start so lets check the appropriate header */
+        switch(qatCheckHeader(strm, flush)) {
+        case QAT_RET_HEADER_COMPLETE:
+            state->qatState = QAT_INF_STATE_BODY;
+            if (flush == Z_BLOCK || flush == Z_TREES) {
+                return Z_OK;
     }
-    if (dictLength != Z_NULL)
-        *dictLength = state->whave;
+            break;
+        case QAT_RET_MORE_INPUT_REQUIRED:
     return Z_OK;
+        case QAT_RET_BUFFER_ERROR:
+            return Z_BUF_ERROR;
+        case QAT_RET_DATA_ERROR:
+        default:
+            state->qatState = QAT_INF_STATE_ERROR;
+            return Z_STREAM_ERROR;
 }
+        /*Purposely drop through here to next state for efficiency*/
 
-int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
-z_streamp strm;
-const Bytef *dictionary;
-uInt dictLength;
-{
-    struct inflate_state FAR *state;
-    unsigned long dictid;
-    int ret;
+    /* Don't add new case statements here as we can drop into this case from the case above */     
 
-    /* check state */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->wrap != 0 && state->mode != DICT)
+    case QAT_INF_STATE_BODY:
+        QATDEBUG("*QAT_INF_STATE_BODY*\n");
+        if (!state->ignoreFurtherExternalInput) {
+            /* Copy any input data into the pinned memory input buffer */
+            if (qatAddInputToBufferList(strm, flush) != Z_OK) {
+               QATDEBUG("Error adding input\n");
+               state->qatState = QAT_INF_STATE_ERROR;
         return Z_STREAM_ERROR;
+            }     
+        }
 
-    /* check for correct dictionary identifier */
-    if (state->mode == DICT) {
-        dictid = adler32(0L, Z_NULL, 0);
-        dictid = adler32(dictid, dictionary, dictLength);
-        if (dictid != state->check)
+        QATDEBUG("Total Bytes Now in Input Buffer: %d\n", state->totalBytesPlacedInInputBuffer);
+
+        /* Reset the DC result states. */
+        state->res.consumed = 0;
+        state->res.produced = 0;	
+        /* Reset the pinned memory output buffers */ 
+        qatResetOutputBufferList(strm);
+    
+        rc = qatSendDecompressionRequest(strm, flush);
+        if ( Z_OK != rc ) {
+            state->qatState = QAT_INF_STATE_ERROR;
+            return rc;
+        }
+
+        QATDEBUG("state->res.status = %d\n", state->res.status);
+        QATDEBUG("state->res.consumed = %ld\n", state->res.consumed);
+        QATDEBUG("state->res.produced = %ld\n", state->res.produced);
+        QATDEBUG("state->res.checksum = %x\n", state->res.checksum);
+        QATDEBUG("state->res.endOfLastBlock = %d\n", state->res.endOfLastBlock);
+        if (state->res.consumed == 0 && state->res.produced == 0) {
+            state->noProgressDetected++;
+        }
+        else {
+            state->noProgressDetected = 0;
+        }
+
+
+        /* Check return status of decompression call. On decompression it is okay to get overflow
+           although we will need to deal with the pinned input buffers appropriately */
+        if ((CPA_DC_OK != state->res.status) && (CPA_DC_OVERFLOW != state->res.status)) {
+           fprintf(stderr, "Data decompression unsuccessful, status = %d\n", state->res.status);
+           state->qatState = QAT_INF_STATE_ERROR;
             return Z_DATA_ERROR;
     }
 
-    /* copy dictionary to window using updatewindow(), which will amend the
-       existing dictionary if appropriate */
-    ret = updatewindow(strm, dictionary + dictLength, dictLength);
-    if (ret) {
-        state->mode = MEM;
-        return Z_MEM_ERROR;
+        if (CPA_DC_OVERFLOW == state->res.status) { 
+            QATDEBUG("CPA_DC_OVERFLOW detected\n");
     }
-    state->havedict = 1;
-    Tracev((stderr, "inflate:   dictionary set\n"));
-    return Z_OK;
+
+        state->numBytesLeftToCopy = state->res.produced;
+   
+        /* Adjust zlib counts and pointers if we consumed more than 
+           state->inputBufferAdjustment (anything less than or equal
+           has already been accounted for so does not need adjustment)*/
+        if (state->res.consumed > state->inputBufferAdjustment) {
+            strm->next_in     += (state->res.consumed - state->inputBufferAdjustment);
+            strm->avail_in    -= (state->res.consumed - state->inputBufferAdjustment);
+            strm->total_in    += (state->res.consumed - state->inputBufferAdjustment);
+            state->inputBufferAdjustment = 0;
+        }
+        else {
+            state->inputBufferAdjustment -= state->res.consumed;
 }
 
-int ZEXPORT inflateGetHeader(strm, head)
-z_streamp strm;
-gz_headerp head;
-{
-    struct inflate_state FAR *state;
+        state->total      += state->res.produced;
+        strm->adler       = state->res.checksum;
 
-    /* check state */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;
+        if (state->res.consumed < state->totalBytesPlacedInInputBuffer && 
+            state->res.status != CPA_DC_OVERFLOW &&
+            !state->res.endOfLastBlock) {
+            /* In the case where we are not making any progress we need to leave the data at  
+               the start of the pinned input buffer and pretend we have consumed it so we
+               trick the client into providing more data. */ 
+            strm->next_in += (state->totalBytesPlacedInInputBuffer - (state->res.consumed + state->inputBufferAdjustment));
+            strm->avail_in -= (state->totalBytesPlacedInInputBuffer - (state->res.consumed + state->inputBufferAdjustment));
+            strm->total_in += (state->totalBytesPlacedInInputBuffer - (state->res.consumed + state->inputBufferAdjustment));
+            state->inputBufferAdjustment = (state->totalBytesPlacedInInputBuffer - state->res.consumed); 
+            qatAdjustInputBuffers(strm, flush);
+        } 
+        else {
+            /* We will throw away any data not consumed as it is just as expensive to move
+               it within the buffers as it is to throw it away and copy it back in.
+               As we are not normally internally buffering up requests in order to support
+               multiple gzip files in a stream, we need to do this */
+            qatResetInputBufferList(strm);
+        }
 
-    /* save header structure */
-    state->head = head;
-    head->done = 0;
-    return Z_OK;
+        /* Copy as much output from the pinned output buffer to the regular output buffer */
+        qatCopyOutputFromBufferList(strm, flush);
+
+        /* If we have found the end of the last deflate block then lets move our
+          state on to read the footer data */
+        if (state->res.endOfLastBlock) {
+            state->qatState = QAT_INF_STATE_ASSEMBLE_FOOTER;
 }
 
-/*
-   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
-   or when out of input.  When called, *have is the number of pattern bytes
+        if ((QAT_INF_STATE_ASSEMBLE_FOOTER == state->qatState) && (0 == state->footerBytesLeftToCopy) && (0 == strm->avail_in)) {
+            strm->avail_in=1; /* Workaround for badly behaved clients */ 
+            state->ignoreFurtherExternalInput = 1;
+            state->clientWorkAround = 1;
+        }
+       
+
+        QATDEBUG("*** End qatInflate ***\n");
+
+        return Z_OK;
+    
+    
+    case QAT_INF_STATE_ASSEMBLE_FOOTER:
+        QATDEBUG("*QAT_INF_STATE_ASSEMBLE_FOOTER*\n");
+        /* Lets copy some of the input into the circular buffer that will end up
+           containing the footer. First lets determine how many bytes to copy. */
+        if (strm->avail_in < state->footerBytesLeftToCopy) {
+            /* The input is smaller than the footer length so we want to copy all the input.
+               This may only be a partial footer but the rest will get copied in next
+               time so we'll end up with the full length of the footer in the circular buffer. */
+            footerBytesToCopy = strm->avail_in;
+        }
+        else {
+            /* The input is bigger than the footer length so we just want to copy 
+               state->footerBytesLeftToCopy bytes. This is then the whole footer
+               so we can move onto the next state to actually process the footer. */
+            footerBytesToCopy = state->footerBytesLeftToCopy;
+            state->qatState = QAT_INF_STATE_PROCESS_FOOTER;
+        }
+
+        if(footerBytesToCopy)
+        {
+            memcpy(state->simpleFooterBuffer+(state->footerLength - state->footerBytesLeftToCopy), 
+               strm->next_in, footerBytesToCopy);
+        } 
+        strm->total_in += footerBytesToCopy;
+        strm->avail_in -= footerBytesToCopy;
+        strm->next_in += footerBytesToCopy;
+        state->footerBytesLeftToCopy -= footerBytesToCopy; 
+        
+        if ((QAT_INF_STATE_PROCESS_FOOTER == state->qatState) && (0 == strm->avail_in)) {
+            strm->avail_in = 1; /* Workaround for badly behaved clients */
+            state->ignoreFurtherExternalInput = 1;
+            state->clientWorkAround=1;
+        }
+        
+        return Z_OK;
+    
+    case QAT_INF_STATE_PROCESS_FOOTER:
+        QATDEBUG("*QAT_INF_STATE_PROCESS_FOOTER*\n");
+        
+        return qatProcessFooter(strm, flush);
+        
+    case QAT_INF_STATE_FINISHED: 
+        QATDEBUG("*QAT_INF_STATE_FINISHED*\n");
+        return Z_STREAM_END;
+    case QAT_INF_STATE_ERROR:
+        QATDEBUG("*QAT_INF_STATE_ERROR*\n");
+        /* Purposely fall through to next state */
+    default:
+        return Z_STREAM_ERROR;
+    } /* End switch */ 
+}
+
+int qatInflate(strm, flush)
+z_streamp strm;
+int flush;
+{
+    struct inflate_state FAR *state;
+    int rc = Z_OK;
+    int footerBufferLoop = 0;
+    int footerBytesToCopy = 0;
+    int tempTotalInputBytes = 0;
+    if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
+        (strm->next_in == Z_NULL && strm->avail_in != 0)) {
+        return Z_STREAM_ERROR;
+    }
+
+    state = (struct inflate_state FAR *)strm->state;
+
+    if(state->qatDriverType >= QAT_DRIVER_TYPE_1_6)
+    {
+        return qatInflate_DH895(strm, flush);
+    }
+    
+    if (Z_NO_FLUSH == flush && 0 == strm->avail_in) {
+        return Z_BUF_ERROR;
+    }
+
+    QATDEBUG("*** qatInflate ***\n");
+    QATDEBUG("state->numBytesLeftToCopy = %d\n", state->numBytesLeftToCopy);
+    QATDEBUG("state->ignoreFurtherExternalInput = %d\n", state->ignoreFurtherExternalInput);
+    QATDEBUG("strm->avail_in = %d\n", strm->avail_in);
+    QATDEBUG("strm->avail_out = %d\n", strm->avail_out);
+    QATDEBUG("state->total = %ld\n", state->total);
+    QATDEBUG("strm->total_in = %ld\n", strm->total_in);
+    QATDEBUG("strm->total_out = %ld\n", strm->total_out);
+    QATDEBUG("flush = %ld\n", flush);
+
+    /* If there are bytes left in the pinned output buffer then copy them
+       to the actual output buffer */	
+    if (state->numBytesLeftToCopy) {
+       qatCopyOutputFromBufferList(strm, flush);
+       /* If we filled the output buffer then return Z_OK so it can be emptied */
+       if (0 == strm->avail_out) return Z_OK;
+    }
+    
+    switch (state->qatState) {
+
+    case QAT_INF_STATE_HEADER:
+        QATDEBUG("*QAT_INF_STATE_HEADER*\n");
+        /* We are at the start so lets check the appropriate header */
+        switch(qatCheckHeader(strm, flush)) {
+        case QAT_RET_HEADER_COMPLETE:
+            state->qatState = QAT_INF_STATE_BODY;
+            if (flush == Z_BLOCK || flush == Z_TREES) {
+                return Z_OK;
+            }
+            break;
+        case QAT_RET_MORE_INPUT_REQUIRED:
+            return Z_OK;
+        case QAT_RET_BUFFER_ERROR:
+            return Z_BUF_ERROR;
+        case QAT_RET_DATA_ERROR:
+        default:
+            state->qatState = QAT_INF_STATE_ERROR;
+            return Z_STREAM_ERROR;
+        }
+        
+        /* Check for a zero byte file and deal with it appropriately as we should not
+          submit this to the hardware */
+        if (strm->avail_in >= 2  && Z_FINISH == flush) {
+            if ((*(strm->next_in) == 0x03) && (*(strm->next_in+1) == 0x00)) {
+                QATDEBUG("Detected zero byte file\n");
+                strm->next_in += 2;
+                strm->avail_in -= 2;
+                strm->total_in += 2;
+                /* We are so lets copy some of the input into the circular buffer that will end up
+                containing the footer. First let determine how many bytes to copy. */
+                if (strm->avail_in < state->footerLength) {
+                    /* The input is smaller than the footer length so we want to copy all the input.
+                    This may only be a partial footer but the rest will have been copied in last
+                    time so we'll end up with the full length of the footer in the circular buffer. */
+                    footerBytesToCopy = strm->avail_in;
+                }
+                else {
+                    /* The input is bigger than the footer length so we just want to copy the
+                    last footer length amount of bytes. This may or may not contain actual
+                    footer information but as it's a circular buffer it will get overwritten
+                    on the next call if not  */
+                    footerBytesToCopy = state->footerLength;
+                }
+
+                for (footerBufferLoop = strm->avail_in-footerBytesToCopy; 
+                    footerBufferLoop < strm->avail_in; footerBufferLoop++) {
+                    csbWrite(state->footerBuffer, (unsigned char *)(strm->next_in+footerBufferLoop));
+                }
+                /* If we are on the last block and there is no input in the input buffer then
+                   we can set the flag to ignore further input. We also set strm->avail_in to 1
+                   as a workaround as some clients will drop out of the loop calling inflate if
+                   they see the input buffer is empty and the output buffer is not full. */
+                if (( Z_FINISH == flush ) && ( 0 == strm->avail_in )) {
+                    strm->avail_in=1; /* Workaround for badly behaved clients */ 
+                    state->ignoreFurtherExternalInput = 1;
+                    state->qatState = QAT_INF_STATE_ASSEMBLE_FOOTER;
+                }
+                else {
+                    state->qatState = QAT_INF_STATE_BODY;
+                }
+                
+                return Z_OK; 
+            }
+        } 
+        /*Purposely drop through here to next state for efficiency*/
+    
+    /* Don't add new case statements here as we can drop into this case from the case above */  
+
+    case QAT_INF_STATE_BODY:
+        QATDEBUG("*QAT_INF_STATE_BODY*\n");
+        /* Check if we are still processing input */
+        if (!state->ignoreFurtherExternalInput) {
+            /* We are so lets copy some of the input into the circular buffer that will end up
+               containing the footer. First let determine how many bytes to copy. */
+            if (strm->avail_in < state->footerLength) {
+                /* The input is smaller than the footer length so we want to copy all the input.
+                   This may only be a partial footer but the rest will have been copied in last
+                   time so we'll end up with the full length of the footer in the circular buffer. */
+                footerBytesToCopy = strm->avail_in;
+            }
+            else {
+                /* The input is bigger than the footer length so we just want to copy the
+                   last footer length amount of bytes. This may or may not contain actual
+                   footer information but as it's a circular buffer it will get overwritten
+                   on the next call if not  */
+                footerBytesToCopy = state->footerLength;
+            }
+
+            for (footerBufferLoop = strm->avail_in-footerBytesToCopy; footerBufferLoop < strm->avail_in; footerBufferLoop++) {
+                csbWrite(state->footerBuffer, (unsigned char *)(strm->next_in+footerBufferLoop));
+            }
+
+            /* If only footer is left then throw it away as we don't want to submit it to
+               the QAT Engine as it will not like it */
+            if (flush == Z_FINISH && strm->avail_in <= state->footerLength && state->wrap > 0) {
+                QATDEBUG("Detected footer we can discard\n");
+                strm->total_in += strm->avail_in;
+                strm->avail_in=0;
+                if (0 == state->totalBytesPlacedInInputBuffer) {
+                    strm->avail_in=1; /* Workaround for badly behaved clients */
+                    state->ignoreFurtherExternalInput = 1;
+                    state->qatState = QAT_INF_STATE_ASSEMBLE_FOOTER;
+                    return Z_OK; 
+                }
+            }
+
+            /* Copy any input data into the pinned memory input buffer */
+            if (qatAddInputToBufferList(strm, flush) != Z_OK) {
+               QATDEBUG("Error adding input\n");
+               state->qatState = QAT_INF_STATE_ERROR;
+               return Z_STREAM_ERROR;
+            }
+
+            QATDEBUG("Total Bytes Now in Input Buffer: %d\n", state->totalBytesPlacedInInputBuffer);
+            /* If we aren't on the last block and we have copied all the input into the pinned
+               input buffer then return Z_OK so the input buffer can be refilled */
+            if (Z_NO_FLUSH == flush && 0 == strm->avail_in) {
+                QATDEBUG("Request more input\n");
+                QATDEBUG("*** End qatInflate ***\n");
+                return Z_OK;
+            }
+        }
+        else {
+            /* We are not processing further input. Ensure the workaround of setting strm->avail_in
+               to 1 so that the client continues to call inflate is set back to zero before we
+               we make any real calls to inflate data */ 
+            if (1 == strm->avail_in)
+               strm->avail_in = 0;
+        }
+        
+        /* Reset the DC result states. */
+        state->res.consumed = 0;
+        state->res.produced = 0;	
+        /* Reset the pinned memory output buffers */ 
+        qatResetOutputBufferList(strm);
+        
+        rc = qatSendDecompressionRequest(strm, flush);
+        if ( Z_OK != rc ) {
+            state->qatState = QAT_INF_STATE_ERROR;
+            return rc;
+        }
+    
+        QATDEBUG("state->res.status = %d\n", state->res.status);
+        QATDEBUG("state->res.consumed = %ld\n", state->res.consumed);
+        QATDEBUG("state->res.produced = %ld\n", state->res.produced);
+        QATDEBUG("state->res.checksum = %x\n", state->res.checksum);
+
+        /* Check return status of decompression call. On decompression it is okay to get overflow
+           although we will need to deal with the pinned input buffers appropriately */
+        if ((CPA_DC_OK != state->res.status) && (CPA_DC_OVERFLOW != state->res.status)) {
+           fprintf(stderr, "Data decompression unsuccessful, status = %d\n", state->res.status);
+           state->qatState = QAT_INF_STATE_ERROR;
+           return Z_DATA_ERROR;
+        }
+
+        if (CPA_DC_OVERFLOW == state->res.status) { 
+            QATDEBUG("CPA_DC_OVERFLOW detected\n");
+        }
+
+        tempTotalInputBytes = state->totalBytesPlacedInInputBuffer;
+        state->numBytesLeftToCopy = state->res.produced;
+    
+        /* In the case of overflow there will be data in the middle to the end of the pinned input 
+           buffer that was not consumed. We want to move this data to the start of the pinned 
+           input buffer ready to resubmit. */ 
+        qatAdjustInputBuffers(strm, flush);
+
+        /* Copy as much output from the pinned output buffer to the regular output buffer */
+        qatCopyOutputFromBufferList(strm, flush);
+
+        /* Adjust zlib counts and pointers */
+        state->total    += state->res.produced;
+        strm->adler     = state->res.checksum;
+
+        /* If we are on the last block and there is no input in the input buffer then
+           we can set the flag to ignore further input. We also set strm->avail_in to 1
+           as a workaround as some clients will drop out of the loop calling inflate if
+           they see the input buffer is empty and the output buffer is not full. */
+        if (( Z_FINISH == flush ) && ( 0 == strm->avail_in )) {
+            state->ignoreFurtherExternalInput=1;
+            strm->avail_in=1; 
+        }
+        /* To further that if we are ignoring further external input and we have consumed
+           all the input data in the pinned input buffer then set the final drain required
+           flag to empty out the output buffers and finish off */
+        if (( state->ignoreFurtherExternalInput && (state->res.consumed == tempTotalInputBytes)) ||
+            ( state->ignoreFurtherExternalInput && 
+            (state->totalBytesPlacedInInputBuffer <= state->footerLength) && state->wrap > 0)) {
+            state->qatState = QAT_INF_STATE_ASSEMBLE_FOOTER;
+        }
+
+        QATDEBUG("*** End qatInflate ***\n");
+
+        return Z_OK;
+
+    /* In this version QAT_INF_STATE_ASSEMBLE_FOOTER is not needed as we can only transition 
+       to the state when we have read in the whole footer. Lets keep the state for completeness
+       but fall straight through into QAT_INF_STATE_PROCESS_FOOTER. */       
+    case QAT_INF_STATE_ASSEMBLE_FOOTER: 
+        QATDEBUG("*QAT_INF_STATE_ASSEMBLE_FOOTER*\n");    
+    case QAT_INF_STATE_PROCESS_FOOTER:
+        QATDEBUG("*QAT_INF_STATE_PROCESS_FOOTER*\n");
+        
+        return qatProcessFooter(strm, flush);
+        
+    case QAT_INF_STATE_FINISHED: /* Any operations once we have finished will be treated as errors */
+        QATDEBUG("*QAT_INF_STATE_FINISHED*\n");
+        /* Purposely fall through to next state */
+    case QAT_INF_STATE_ERROR:
+        QATDEBUG("*QAT_INF_STATE_ERROR*\n");
+        /* Purposely fall through to next state */
+    default:
+        return Z_STREAM_ERROR;
+    } /* End switch */        
+}
+
+int ZEXPORT inflateEnd(strm)
+z_streamp strm;
+{
+    if (qatIsHardwareDecompressionEnabled()) {
+	    return qatInflateEnd(strm);
+	}
+
+    struct inflate_state FAR *state;
+    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
+        return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+    if (state->window != Z_NULL) ZFREE(strm, state->window);
+    ZFREE(strm, strm->state);
+    strm->state = Z_NULL;
+    Tracev((stderr, "inflate: end\n"));
+    return Z_OK;
+}
+
+int qatInflateEnd(strm)
+z_streamp strm;
+{
+    struct inflate_state FAR *state;
+    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
+        return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+    if (state->window != Z_NULL) ZFREE(strm, state->window);
+    /* Free QAT resources */
+    qatInflateCleanup(strm);
+
+    Tracev((stderr, "inflate: end\n"));
+    return Z_OK;
+}
+
+int qatInflateCleanup(strm)
+z_streamp strm;
+{
+    /* Cleanup in reverse order checking for NULL pointers and ensuring pointers are
+       set to NULL. It is possible some pointers have not been created when this
+       function is called (if something goes wrong in inflateInit). Also it is
+       possible this function may get called twice if something goes wrong in the
+       inflateInit but the client either doesn't check the status or chooses to
+       still call inflateEnd to cleanup */ 
+    int numOfFlatBuffers = 0;
+    struct inflate_state FAR *state;
+    state = (struct inflate_state FAR *)strm->state;
+ 
+    if (state->sessionStarted) {
+        qatCloseSession(strm);
+    }
+
+    if (state->out) {
+        state->currentOutputBuffer=state->out;
+        for(numOfFlatBuffers = 0; numOfFlatBuffers < state->totalNumOfOutputBuffers; numOfFlatBuffers++) {
+            if (NULL != state->currentOutputBuffer->pData) {
+                qaeZlibPinnedMemFree(state->currentOutputBuffer->pData);
+                state->currentOutputBuffer->pData=NULL;
+            }
+            state->currentOutputBuffer++;
+        }
+        ZFREE(strm, state->out);
+        state->out = NULL;
+    }
+
+    if (state->in) {
+        state->currentInputBuffer=state->in;
+        for(numOfFlatBuffers = 0; numOfFlatBuffers < state->totalNumOfInputBuffers; numOfFlatBuffers++) {
+           if (NULL != state->currentInputBuffer->pData) {
+               qaeZlibPinnedMemFree(state->currentInputBuffer->pData);
+               state->currentInputBuffer->pData=NULL;
+           }
+           state->currentInputBuffer++;
+        }
+        ZFREE(strm, state->in);
+        state->in = NULL;
+    }
+    		
+    if (NULL != state->inl.pPrivateMetaData) {
+        qaeZlibPinnedMemFree(state->inl.pPrivateMetaData);
+        state->inl.pPrivateMetaData = NULL;
+    }
+
+    if (NULL != state->outl.pPrivateMetaData) {
+        qaeZlibPinnedMemFree(state->outl.pPrivateMetaData);
+        state->outl.pPrivateMetaData = NULL;
+    }
+
+    if(state->qatDriverType >= QAT_DRIVER_TYPE_1_6) {
+        if (NULL != state->simpleFooterBuffer) {
+           ZFREE(strm, state->simpleFooterBuffer);
+           state->simpleFooterBuffer = NULL;
+        }
+    }
+    else {
+        if (NULL != state->footerBuffer) {
+           csbFree(state->footerBuffer);
+           ZFREE(strm, state->footerBuffer);
+           state->footerBuffer = NULL;
+        }
+    }
+
+    ZFREE(strm, strm->state);
+    strm->state = Z_NULL;
+	
+	return Z_OK;
+}
+
+int ZEXPORT inflateGetDictionary(strm, dictionary, dictLength)
+z_streamp strm;
+Bytef *dictionary;
+uInt *dictLength;
+{
+    struct inflate_state FAR *state;
+
+    /* check state */
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (qatIsHardwareDecompressionEnabled()) {
+        return qatInflateGetDictionary(strm, dictionary, dictLength);
+    }
+    state = (struct inflate_state FAR *)strm->state;
+
+    /* copy dictionary */
+    if (state->whave && dictionary != Z_NULL) {
+        zmemcpy(dictionary, state->window + state->wnext,
+                state->whave - state->wnext);
+        zmemcpy(dictionary + state->whave - state->wnext,
+                state->window, state->wnext);
+    }
+    if (dictLength != Z_NULL)
+        *dictLength = state->whave;
+    return Z_OK;
+}
+
+int ZEXPORT qatInflateGetDictionary(strm, dictionary, dictLength)
+z_streamp strm;
+Bytef *dictionary;
+uInt *dictLength;
+{
+    /* not supported when using hardware acceleration */
+    return Z_STREAM_ERROR;
+}
+
+int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
+z_streamp strm;
+const Bytef *dictionary;
+uInt dictLength;
+{
+    struct inflate_state FAR *state;
+    unsigned long dictid;
+    int ret;
+
+    /* check state */
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (qatIsHardwareDecompressionEnabled()) {
+	    return qatInflateSetDictionary(strm, dictionary, dictLength);
+    }
+    state = (struct inflate_state FAR *)strm->state;
+
+    if (state->wrap != 0 && state->mode != DICT)
+        return Z_STREAM_ERROR;
+
+    /* check for correct dictionary identifier */
+    if (state->mode == DICT) {
+        dictid = adler32(0L, Z_NULL, 0);
+        dictid = adler32(dictid, dictionary, dictLength);
+        if (dictid != state->check)
+            return Z_DATA_ERROR;
+    }
+
+    /* copy dictionary to window using updatewindow(), which will amend the
+       existing dictionary if appropriate */
+    ret = updatewindow(strm, dictionary + dictLength, dictLength);
+    if (ret) {
+        state->mode = MEM;
+        return Z_MEM_ERROR;
+    }
+    state->havedict = 1;
+    Tracev((stderr, "inflate:   dictionary set\n"));
+    return Z_OK;
+}
+
+int qatInflateSetDictionary(strm, dictionary, dictLength)
+z_streamp strm;
+const Bytef *dictionary;
+uInt dictLength;
+{
+    /* not supported when using hardware acceleration */
+    return Z_STREAM_ERROR;
+}
+
+int ZEXPORT inflateGetHeader(strm, head)
+z_streamp strm;
+gz_headerp head;
+{
+    struct inflate_state FAR *state;
+    if (qatIsHardwareDecompressionEnabled()) {
+        return qatInflateGetHeader(strm, head);
+    }
+
+    /* check state */
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+    if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;
+
+    /* save header structure */
+    state->head = head;
+    head->done = 0;
+    return Z_OK;
+}
+
+int qatInflateGetHeader(strm, head)
+z_streamp strm;
+gz_headerp head;
+{
+    /* not supported when using hardware acceleration */
+    return Z_STREAM_ERROR;
+}
+
+/*
+   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
+   or when out of input.  When called, *have is the number of pattern bytes
    found in order so far, in 0..3.  On return *have is updated to the new
    state.  If on return *have equals four, then the pattern was found and the
    return value is how many bytes were read including the last byte of the
@@ -1382,6 +3169,10 @@
     unsigned char buf[4];       /* to restore bit buffer to byte string */
     struct inflate_state FAR *state;
 
+    if (qatIsHardwareDecompressionEnabled()) {
+        return qatInflateSync(strm);
+    }
+
     /* check parameters */
     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
     state = (struct inflate_state FAR *)strm->state;
@@ -1417,6 +3208,13 @@
     return Z_OK;
 }
 
+int qatInflateSync(strm)
+z_streamp strm;
+{
+    /* not supported when using hardware acceleration */
+    return Z_STREAM_ERROR;
+}
+
 /*
    Returns true if inflate is currently at the end of a block generated by
    Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
@@ -1430,11 +3228,22 @@
 {
     struct inflate_state FAR *state;
 
+    if (qatIsHardwareDecompressionEnabled()) {
+        return qatInflateSyncPoint(strm);
+    }
+
     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
     state = (struct inflate_state FAR *)strm->state;
     return state->mode == STORED && state->bits == 0;
 }
 
+int qatInflateSyncPoint(strm)
+z_streamp strm;
+{
+    /* not supported when using hardware acceleration */
+    return Z_STREAM_ERROR;
+}
+
 int ZEXPORT inflateCopy(dest, source)
 z_streamp dest;
 z_streamp source;
@@ -1444,6 +3253,10 @@
     unsigned char FAR *window;
     unsigned wsize;
 
+    if (qatIsHardwareDecompressionEnabled()) {
+        return qatInflateCopy(dest, source);
+    }
+
     /* check input */
     if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
         source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)
@@ -1482,12 +3295,24 @@
     return Z_OK;
 }
 
+int qatInflateCopy(dest, source)
+z_streamp dest;
+z_streamp source;
+{
+    /* not supported when using hardware acceleration */
+    return Z_STREAM_ERROR;
+}
+
 int ZEXPORT inflateUndermine(strm, subvert)
 z_streamp strm;
 int subvert;
 {
     struct inflate_state FAR *state;
 
+    if (qatIsHardwareDecompressionEnabled()) {
+        return qatInflateUndermine(strm, subvert);
+    }
+
     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
     state = (struct inflate_state FAR *)strm->state;
     state->sane = !subvert;
@@ -1499,14 +3324,273 @@
 #endif
 }
 
+int qatInflateUndermine(strm, subvert)
+z_streamp strm;
+int subvert;
+{
+    /* not supported when using hardware acceleration */
+    return Z_STREAM_ERROR;
+}
+
 long ZEXPORT inflateMark(strm)
 z_streamp strm;
 {
     struct inflate_state FAR *state;
 
+    if (qatIsHardwareDecompressionEnabled()) {
+        return qatInflateMark(strm);
+    }
+	
     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;
     state = (struct inflate_state FAR *)strm->state;
     return ((long)(state->back) << 16) +
         (state->mode == COPY ? state->length :
             (state->mode == MATCH ? state->was - state->length : 0));
 }
+
+long qatInflateMark(strm)
+z_streamp strm;
+{
+    /* not supported when using hardware acceleration */
+     return -1L << 16;
+}
+
+local int qatCheckHeader(strm, flush)
+z_streamp strm;
+int flush;
+{
+    struct inflate_state FAR *state;
+    unsigned char FAR *next;    /* next input */
+    unsigned char FAR *put;     /* next output */
+    unsigned have, left;        /* available input and output */
+    unsigned long hold;         /* bit buffer */
+    unsigned bits;              /* bits in bit buffer */
+    unsigned in, out;           /* save starting available input and output */
+    unsigned copy;              /* number of stored or match bytes to copy */
+    unsigned len;               /* length to copy for repeats, bits to drop */
+    int ret;                    /* return code */
+#ifdef GUNZIP
+    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
+#endif
+    if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
+        (strm->next_in == Z_NULL && strm->avail_in != 0))
+        return QAT_RET_DATA_ERROR;
+
+    state = (struct inflate_state FAR *)strm->state;
+    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
+    LOAD();
+    in = have;
+    out = left;
+    ret = QAT_RET_MORE_INPUT_REQUIRED;
+    for (;;) {
+        switch (state->mode) {
+        case HEAD:
+            if (state->wrap == 0) {
+                state->mode = TYPEDO;
+                break;
+            }
+            NEEDBITS(16);
+#ifdef GUNZIP
+            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
+                state->check = crc32(0L, Z_NULL, 0);
+                CRC2(state->check, hold);
+                INITBITS();
+                state->mode = FLAGS;
+                break;
+            }
+            state->flags = 0;           /* expect zlib header */
+            if (state->head != Z_NULL)
+                state->head->done = -1;
+            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
+#else
+            if (
+#endif
+                ((BITS(8) << 8) + (hold >> 8)) % 31) {
+                strm->msg = (char *)"incorrect header check";
+                state->mode = BAD;
+                break;
+            }
+            if (BITS(4) != Z_DEFLATED) {
+                strm->msg = (char *)"unknown compression method";
+                state->mode = BAD;
+                break;
+            }
+            DROPBITS(4);
+            len = BITS(4) + 8;
+            if (state->wbits == 0)
+                state->wbits = len;
+            else if (len > state->wbits) {
+                strm->msg = (char *)"invalid window size";
+                state->mode = BAD;
+                break;
+            }
+            state->dmax = 1U << len;
+            Tracev((stderr, "inflate:   zlib header ok\n"));
+            strm->adler = state->check = adler32(0L, Z_NULL, 0);
+            state->mode = hold & 0x200 ? DICTID : TYPE;
+            INITBITS();
+            break;
+#ifdef GUNZIP
+        case FLAGS:
+            NEEDBITS(16);
+            state->flags = (int)(hold);
+            if ((state->flags & 0xff) != Z_DEFLATED) {
+                strm->msg = (char *)"unknown compression method";
+                state->mode = BAD;
+                break;
+            }
+            if (state->flags & 0xe000) {
+                strm->msg = (char *)"unknown header flags set";
+                state->mode = BAD;
+                break;
+            }
+            if (state->head != Z_NULL)
+                state->head->text = (int)((hold >> 8) & 1);
+            if (state->flags & 0x0200) CRC2(state->check, hold);
+            INITBITS();
+            state->mode = TIME;
+        case TIME:
+            NEEDBITS(32);
+            if (state->head != Z_NULL)
+                state->head->time = hold;
+            if (state->flags & 0x0200) CRC4(state->check, hold);
+            INITBITS();
+            state->mode = OS;
+        case OS:
+            NEEDBITS(16);
+            if (state->head != Z_NULL) {
+                state->head->xflags = (int)(hold & 0xff);
+                state->head->os = (int)(hold >> 8);
+            }
+            if (state->flags & 0x0200) CRC2(state->check, hold);
+            INITBITS();
+            state->mode = EXLEN;
+        case EXLEN:
+            if (state->flags & 0x0400) {
+                NEEDBITS(16);
+                state->length = (unsigned)(hold);
+                if (state->head != Z_NULL)
+                    state->head->extra_len = (unsigned)hold;
+                if (state->flags & 0x0200) CRC2(state->check, hold);
+                INITBITS();
+            }
+            else if (state->head != Z_NULL)
+                state->head->extra = Z_NULL;
+            state->mode = EXTRA;
+        case EXTRA:
+            if (state->flags & 0x0400) {
+                copy = state->length;
+                if (copy > have) copy = have;
+                if (copy) {
+                    if (state->head != Z_NULL &&
+                        state->head->extra != Z_NULL) {
+                        len = state->head->extra_len - state->length;
+                        zmemcpy(state->head->extra + len, next,
+                                len + copy > state->head->extra_max ?
+                                state->head->extra_max - len : copy);
+                    }
+                    if (state->flags & 0x0200)
+                        state->check = crc32(state->check, next, copy);
+                    have -= copy;
+                    next += copy;
+                    state->length -= copy;
+                }
+                if (state->length) goto inf_leave;
+            }
+            state->length = 0;
+            state->mode = NAME;
+        case NAME:
+            if (state->flags & 0x0800) {
+                if (have == 0) goto inf_leave;
+                copy = 0;
+                do {
+                    len = (unsigned)(next[copy++]);
+                    if (state->head != Z_NULL &&
+                            state->head->name != Z_NULL &&
+                            state->length < state->head->name_max)
+                        state->head->name[state->length++] = len;
+                } while (len && copy < have);
+                if (state->flags & 0x0200)
+                    state->check = crc32(state->check, next, copy);
+                have -= copy;
+                next += copy;
+                if (len) goto inf_leave;
+            }
+            else if (state->head != Z_NULL)
+                state->head->name = Z_NULL;
+            state->length = 0;
+            state->mode = COMMENT;
+        case COMMENT:
+            if (state->flags & 0x1000) {
+                if (have == 0) goto inf_leave;
+                copy = 0;
+                do {
+                    len = (unsigned)(next[copy++]);
+                    if (state->head != Z_NULL &&
+                            state->head->comment != Z_NULL &&
+                            state->length < state->head->comm_max)
+                        state->head->comment[state->length++] = len;
+                } while (len && copy < have);
+                if (state->flags & 0x0200)
+                    state->check = crc32(state->check, next, copy);
+                have -= copy;
+                next += copy;
+                if (len) goto inf_leave;
+            }
+            else if (state->head != Z_NULL)
+                state->head->comment = Z_NULL;
+            state->mode = HCRC;
+        case HCRC:
+            if (state->flags & 0x0200) {
+                NEEDBITS(16);
+                if (hold != (state->check & 0xffff)) {
+                    strm->msg = (char *)"header crc mismatch";
+                    state->mode = BAD;
+                    break;
+                }
+                INITBITS();
+            }
+            if (state->head != Z_NULL) {
+                state->head->hcrc = (int)((state->flags >> 9) & 1);
+                state->head->done = 1;
+            }
+            strm->adler = state->check = crc32(0L, Z_NULL, 0);
+            state->mode = TYPE;
+            break;
+#endif
+        case DICTID:
+            strm->adler = state->check = adler32(0L, Z_NULL, 0);
+	        state->mode = TYPE;
+        case TYPE:
+            state->mode = TYPEDO;
+        case TYPEDO:
+            ret = QAT_RET_HEADER_COMPLETE;
+            goto inf_leave;
+        case BAD:
+            ret = QAT_RET_DATA_ERROR;
+            goto inf_leave;
+        }
+    }
+inf_leave:
+    RESTORE();
+    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
+            (state->mode < CHECK || flush != Z_FINISH)))
+        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
+            state->mode = MEM;
+            return Z_MEM_ERROR;
+        }
+    in -= strm->avail_in;
+    out -= strm->avail_out;
+    strm->total_in += in;
+    strm->total_out += out;
+    state->total += out;
+    if (state->wrap && out)
+        strm->adler = state->check =
+            UPDATE(state->check, strm->next_out - out, out);
+    strm->data_type = state->bits + (state->last ? 64 : 0) +
+                      (state->mode == TYPE ? 128 : 0) +
+                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
+    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == QAT_RET_MORE_INPUT_REQUIRED)
+        ret = QAT_RET_BUFFER_ERROR;
+    return ret;
+}
diff -uBbw -Nr ../zlib-1.2.8/inflate.h ./inflate.h
--- ../zlib-1.2.8/inflate.h	2009-12-26 00:32:08.000000000 +0000
+++ ./inflate.h	2016-09-06 13:13:26.646261000 +0100
@@ -16,6 +16,12 @@
 #  define GUNZIP
 #endif
 
+/* Additions for QAT hardware acceleration. */
+#include "cpa.h"
+#include "cpa_dc.h"
+#include "circharbuf.h"
+#include "engine.h"
+
 /* Possible inflate modes between inflate() calls */
 typedef enum {
     HEAD,       /* i: waiting for magic header */
@@ -77,6 +83,28 @@
         CHECK -> LENGTH -> DONE
  */
 
+ typedef enum {
+    QAT_INF_STATE_HEADER,
+    QAT_INF_STATE_BODY,
+    QAT_INF_STATE_ASSEMBLE_FOOTER,
+    QAT_INF_STATE_PROCESS_FOOTER,
+    QAT_INF_STATE_FINISHED,
+    QAT_INF_STATE_ERROR
+} qat_inflate_state;
+/*
+    State Transitions for above:-
+    
+    QAT_INF_STATE_HEADER->QAT_INF_STATE_BODY->
+    QAT_INF_STATE_ASSEMBLE_FOOTER->QAT_INF_STATE_PROCESS_FOOTER->
+    QAT_INF_STATE_FINISHED
+    
+    On a qatInflateReset all state will get reset including this state
+    machine back to QAT_INF_STATE_HEADER.
+    
+    Any state may transition to the QAT_INF_STATE_ERROR state. The only way to
+    recover once in the QAT_INF_STATE_ERROR state is to call a qatInflateReset.
+*/
+
 /* state maintained between inflate() calls.  Approximately 10K bytes. */
 struct inflate_state {
     inflate_mode mode;          /* current inflate mode */
@@ -119,4 +147,134 @@
     int sane;                   /* if false, allow invalid distance too far */
     int back;                   /* bits back of last unprocessed length/lit */
     unsigned was;               /* initial length of match */
+
+    /********************************************/
+    /* Additions for QAT hardware acceleration. */
+
+    /* The current state the inflate operation is at */
+    qat_inflate_state     qatState;
+    
+    /* Setup parameters for the decompression. They will be passed down on
+       each call to CpaDcDecompressData */
+    CpaDcSessionSetupData sd;
+
+    /* Pointer to a session handle that is passed into various functions */
+    void                  *session;
+
+    /* A pointer to the output flat buffer within the pinned memory output
+       buffer list */
+    CpaFlatBuffer         *out;
+
+    /* A pointer to the input flat buffer within the pinned memory input
+       buffer list */
+    CpaFlatBuffer         *in;
+
+    /* The buffer list of pinned memory that will be passed to the driver
+       via the QAT API as the output buffer */
+    CpaBufferList         outl;
+
+    /* The buffer list of pinned memory that will be passed to the driver
+       via the QAT API as the input buffer */
+    CpaBufferList         inl;
+
+    /* The results structure populated by calls to cpaDcDecompressData.
+       The result needs to be maintained across calls to
+       capDcDecompressData as the checksum needs to be fed back in */
+    CpaDcRqResults        res;
+
+    /* A pointer to the handle of the compression instance we will use */
+    CpaInstanceHandle     *instHandle;
+
+    /* The NUMA Node Id associated with a particular instance. This is
+       used so we may allocate memory on the same node Id. */
+    Cpa32U                nodeId;
+
+    /* A bufferlist that will contain metadata and the context flatbuffer.
+       It will be passed to the driver to use to hold context data */
+    CpaBufferList         contextBuffList;
+
+    /* A flat buffer that will be passed into the driver to hold context
+       data */
+    CpaFlatBuffer         contextFlatBuffer;
+    
+    /* Simpler footer buffer from DH895XCC onwards as we do not need
+       circular buffer functionality. We know where the footer starts. */
+    unsigned char        *simpleFooterBuffer;    
+    /* Circular buffer to copy the last bytes of every submitted request to
+       eventually we can be sure the buffer will have the footer in it */
+    CircularCharBuffer   *footerBuffer;
+
+    /* This flag is set after the Z_FINISH flag has been detected so we do
+       not process further input we are not expecting */
+    int                   ignoreFurtherExternalInput;
+
+    /* A pointer to the current input flatbuffer we are copying data into */
+    CpaFlatBuffer         *currentInputBuffer;
+
+    /* A pointer to the current output flatbuffer we are copying data out of */
+    CpaFlatBuffer         *currentOutputBuffer;
+
+    /* The size of one input flat buffer */
+    int                   totalBuffersize;
+
+    /* The amount of input buffers with input data in */
+    int                   fullInputBuffers;
+
+    /* The total number of flat buffers allocated for input but not necessarily
+       the amount of flat buffers that have input data in them. */
+    int                   totalNumOfInputBuffers;
+
+    /* The total number of flat buffers allocated for output but not necessarily
+       the amount of flat buffers that have output data in them. */
+    int                   totalNumOfOutputBuffers;
+
+    /* The total amount of bytes that have been placed into all the input flat
+       buffers for one call to cpaDcDecompressData */
+    int                   totalBytesPlacedInInputBuffer;
+
+    /* The total amount of bytes left in the output buffer list that needs
+       copying out to the zlib API output buffer */
+    int                   numBytesLeftToCopy;
+
+    /* The offset into the output flat buffer where we need to start copying
+       data from */
+    int                   positionInOutputBuffer;
+
+    /* The CRC32/Adler that was contained in the footer of the file */
+    uLong                 footerCrc;
+
+    /* The filesize that was contained in the footer of the file */
+    uLong                 footerFilesize;
+
+    /* The length of the footer expected, this may vary depending whether
+       it a zlib file or a gzip file we need to maintain this info across
+       the session */ 
+    int                   footerLength;	
+    
+    /* The length of footer remaining to be copied into the footerBuffer.
+       It will start off the same as footerLength and decrease as we
+       copy bytes. This needs to be maintained through the session as
+       we may have a footer split across calls */       
+    int                   footerBytesLeftToCopy;
+
+    /* A flag to store whether we have an open session or not. This is
+       used by qatInflateResetKeep to determine whether the session needs to
+       be reinitialised */
+    int                   sessionStarted;
+
+    /* The amount of bytes we were not making progress with and needed to 
+       buffer up internally in order to get more input. As we tell the client
+       we have consumed the bytes we need to keep track of them to make sure
+       we don't account for them twice when we finally do consume them. */
+    int                   inputBufferAdjustment;
+
+    /* Introduced as a workaround to fix hadoop issue
+       In hadoop, it was not sending Z_FINISH on completion of sending all the data for decompression*/
+    int                   clientWorkAround;     
+    int                   noProgressDetected;
+    QatDriverType      qatDriverType;
+
+    /* End of additions for QAT hardware acceleration. */
+    /***************************************************/
+
 };
diff -uBbw -Nr ../zlib-1.2.8/Makefile.in ./Makefile.in
--- ../zlib-1.2.8/Makefile.in	2013-04-28 23:57:11.000000000 +0100
+++ ./Makefile.in	2016-09-12 08:22:03.529608000 +0100
@@ -16,6 +16,16 @@
 # To install in $HOME instead of /usr/local, use:
 #    make install prefix=$HOME
 
+ifndef CMN_ROOT
+ZLIB_MEMORY_DRIVER=qat_contig_mem
+else
+ZLIB_MEMORY_DRIVER=usdm_drv
+endif
+
+ifndef ZLIB_ROOT
+ZLIB_ROOT=$(PWD)
+endif
+
 CC=cc
 
 CFLAGS=-O
@@ -30,6 +40,60 @@
 LDSHARED=$(CC)
 CPP=$(CC) -E
 
+# Additions for QAT acceleration.
+ifeq ($(ZLIB_MEMORY_DRIVER),qat_contig_mem)
+LOCAL_MEM_DRIVER_DIR?=contrib/qat/qat_contig_mem
+CFLAGS+=-DUSE_QAT_CONTIG_MEM -I$(LOCAL_MEM_DRIVER_DIR)
+SFLAGS+=-DUSE_QAT_CONTIG_MEM -I$(LOCAL_MEM_DRIVER_DIR)
+endif
+
+ifeq ($(ZLIB_MEMORY_DRIVER),usdm_drv)
+LOCAL_MEM_DRIVER_DIR?=contrib/qat/cmn_mem_drv
+CFLAGS+=-DUSE_QAE_MEM -I$(LOCAL_MEM_DRIVER_DIR) -I$(CMN_ROOT)
+SFLAGS+=-DUSE_QAE_MEM -I$(LOCAL_MEM_DRIVER_DIR) -I$(CMN_ROOT)
+endif
+ICP_API_DIR=$(ICP_ROOT)/quickassist/include/
+ICP_SAL_API_DIR=$(ICP_ROOT)/quickassist/lookaside/access_layer/include
+
+ICP_LAC_API_DIR=$(ICP_API_DIR)/lac/
+ICP_DC_API_DIR=$(ICP_API_DIR)/dc/
+CFLAGS+=-D_GNU_SOURCE -I$(ICP_API_DIR) -I$(ICP_DC_API_DIR) -I$(ICP_LAC_API_DIR) -I$(ICP_SAL_API_DIR)
+SFLAGS+=-D_GNU_SOURCE -I$(ICP_API_DIR) -I$(ICP_DC_API_DIR) -I$(ICP_LAC_API_DIR) -I$(ICP_SAL_API_DIR)
+ADDITIONAL_LDFLAGS+=-Wl,-rpath,$(ZLIB_ROOT) -lz  
+SHARED_APP_FLAGS=-Wl,-rpath,$(ZLIB_ROOT) -L$(ZLIB_ROOT) -lz  
+
+ifdef ICP_BUILD_OUTPUT
+    TEST_LDFLAGS+=-L$(ICP_BUILD_OUTPUT)
+    ADDITIONAL_LDFLAGS+=-Wl,-rpath,$(ICP_BUILD_OUTPUT) -L$(ICP_BUILD_OUTPUT)  
+endif
+
+ifdef UPSTREAM_DRIVER_CMN_ROOT
+DRIVER=qat
+else
+DRIVER=icp_qa_al
+endif
+ifdef WITH_CPA_MUX
+    DRIVER=qat_mux
+    BUILD_PATH=-L/$(ICP_ROOT)/../cpa_mux/src/build/linux_2.6/user_space
+    CFLAGS += -I$(ICP_ROOT)/quickassist/include/dc/ -I$(ICP_ROOT)/../QAT1.5/quickassist/include -DWITH_CPA_MUX
+    SFLAGS += -I$(ICP_ROOT)/quickassist/include/dc/ -I$(ICP_ROOT)/../QAT1.5/quickassist/include -DWITH_CPA_MUX
+    ADDITIONAL_LDFLAGS+= -ldl 
+    TEST_LDFLAGS+= -ldl
+endif
+
+ifdef UPSTREAM_DRIVER_CMN_ROOT
+TEST_LDFLAGS+= $(BUILD_PATH) -ludev -l$(DRIVER) -ladf -losal -lcrypto -lpthread -lrt
+TEST_LDFLAGS+= $(UPSTREAM_DRIVER_CMN_ROOT)/libusdm_drv.a
+else
+TEST_LDFLAGS+= $(BUILD_PATH) -l$(DRIVER) -ladf_proxy -losal -lcrypto -lpthread -lrt
+endif
+ADDITIONAL_SHAREDLIBC=-L$(ICP_BUILD_OUTPUT) -l$(DRIVER)_s -lpthread -lrt
+
+ifeq ($(ZLIB_MEMORY_DRIVER),usdm_drv)
+TEST_LDFLAGS+= $(CMN_ROOT)/libusdm_drv.a
+ADDITIONAL_LDFLAGS+=-Wl,-rpath,$(CMN_ROOT) -L$(CMN_ROOT) -lusdm_drv_s
+endif
+
 STATICLIB=libz.a
 SHAREDLIB=libz.so
 SHAREDLIBV=libz.so.1.2.8
@@ -44,6 +108,7 @@
 TAR=tar
 SHELL=/bin/sh
 EXE=
+DEPEND_OBJZ=
 
 prefix = /usr/local
 exec_prefix = ${prefix}
@@ -54,11 +119,25 @@
 man3dir = ${mandir}/man3
 pkgconfigdir = ${libdir}/pkgconfig
 
-OBJZ = adler32.o crc32.o deflate.o infback.o inffast.o inflate.o inftrees.o trees.o zutil.o
+OBJZ = adler32.o crc32.o deflate.o infback.o inffast.o inflate.o inftrees.o trees.o zutil.o qat_zlib.o \
+        circharbuf.o engine.o qat_parseconf.o 
+ifeq ($(ZLIB_MEMORY_DRIVER),qat_contig_mem)
+ADDITIONAL_OBJZ=qae_mem_utils.o
+endif
+ifeq ($(ZLIB_MEMORY_DRIVER),usdm_drv)
+ADDITIONAL_OBJZ=cmn_mem_drv_inf.o
+endif
 OBJG = compress.o uncompr.o gzclose.o gzlib.o gzread.o gzwrite.o
 OBJC = $(OBJZ) $(OBJG)
 
-PIC_OBJZ = adler32.lo crc32.lo deflate.lo infback.lo inffast.lo inflate.lo inftrees.lo trees.lo zutil.lo
+PIC_OBJZ = adler32.lo crc32.lo deflate.lo infback.lo inffast.lo inflate.lo inftrees.lo trees.lo zutil.lo qat_zlib.lo \
+           circharbuf.lo engine.lo qat_parseconf.lo 
+ifeq ($(ZLIB_MEMORY_DRIVER),qat_contig_mem)
+ADDITIONAL_PIC_OBJZ=qae_mem_utils.lo
+endif
+ifeq ($(ZLIB_MEMORY_DRIVER),usdm_drv)
+ADDITIONAL_PIC_OBJZ=cmn_mem_drv_inf.lo 
+endif
 PIC_OBJG = compress.lo uncompr.lo gzclose.lo gzlib.lo gzread.lo gzwrite.lo
 PIC_OBJC = $(PIC_OBJZ) $(PIC_OBJG)
 
@@ -72,11 +151,11 @@
 
 all: static shared
 
-static: example$(EXE) minigzip$(EXE)
+static: example$(EXE) minigzip$(EXE) zpipe$(EXE)
 
-shared: examplesh$(EXE) minigzipsh$(EXE)
+shared: examplesh$(EXE) minigzipsh$(EXE) zpipesh$(EXE)
 
-all64: example64$(EXE) minigzip64$(EXE)
+all64: example64$(EXE) minigzip64$(EXE) zpipe64$(EXE)
 
 check: test
 
@@ -124,8 +203,8 @@
 	./infcover
 	gcov inf*.c
 
-libz.a: $(OBJS)
-	$(AR) $(ARFLAGS) $@ $(OBJS)
+libz.a: $(OBJS) $(ADDITIONAL_OBJZ)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(ADDITIONAL_OBJZ)
 	-@ ($(RANLIB) $@ || true) >/dev/null 2>&1
 
 match.o: match.S
@@ -140,6 +219,18 @@
 	mv _match.o match.lo
 	rm -f _match.s
 
+qae_mem_utils.o: $(LOCAL_MEM_DRIVER_DIR)/qae_mem_utils.c
+	$(CC) $(CFLAGS) -I$(LOCAL_MEM_DRIVER_DIR) -c -o qae_mem_utils.o $(LOCAL_MEM_DRIVER_DIR)/qae_mem_utils.c  
+
+qae_mem_utils.lo: $(LOCAL_MEM_DRIVER_DIR)/qae_mem_utils.c
+	$(CC) $(SFLAGS) -DPIC -I$(LOCAL_MEM_DRIVER_DIR) -c -o qae_mem_utils.lo $(LOCAL_MEM_DRIVER_DIR)/qae_mem_utils.c  
+
+cmn_mem_drv_inf.o: $(LOCAL_MEM_DRIVER_DIR)/cmn_mem_drv_inf.c
+	$(CC) $(CFLAGS) -I$(LOCAL_MEM_DRIVER_DIR) -c -o cmn_mem_drv_inf.o $(LOCAL_MEM_DRIVER_DIR)/cmn_mem_drv_inf.c  
+
+cmn_mem_drv_inf.lo: $(LOCAL_MEM_DRIVER_DIR)/cmn_mem_drv_inf.c
+	$(CC) $(SFLAGS) -DPIC -I$(LOCAL_MEM_DRIVER_DIR) -c -o cmn_mem_drv_inf.lo $(LOCAL_MEM_DRIVER_DIR)/cmn_mem_drv_inf.c  
+
 example.o: test/example.c zlib.h zconf.h
 	$(CC) $(CFLAGS) -I. -c -o $@ test/example.c
 
@@ -152,6 +243,12 @@
 minigzip64.o: test/minigzip.c zlib.h zconf.h
 	$(CC) $(CFLAGS) -I. -D_FILE_OFFSET_BITS=64 -c -o $@ test/minigzip.c
 
+zpipe.o: examples/zpipe.c zlib.h zconf.h
+	$(CC) $(CFLAGS) -I. -c -o $@ examples/zpipe.c
+
+zpipe64.o: examples/zpipe.c zlib.h zconf.h
+	$(CC) $(CFLAGS) -I. -D_FILE_OFFSET_BITS=64 -c -o $@ examples/zpipe.c
+
 .SUFFIXES: .lo
 
 .c.lo:
@@ -159,31 +256,40 @@
 	$(CC) $(SFLAGS) -DPIC -c -o objs/$*.o $<
 	-@mv objs/$*.o $@
 
-placebo $(SHAREDLIBV): $(PIC_OBJS) libz.a
-	$(LDSHARED) $(SFLAGS) -o $@ $(PIC_OBJS) $(LDSHAREDLIBC) $(LDFLAGS)
+placebo $(SHAREDLIBV): $(PIC_OBJS) $(ADDITIONAL_PIC_OBJZ) libz.a
+	$(LDSHARED) $(SFLAGS) -o $@ $(PIC_OBJS) $(LDSHAREDLIBC) $(LDFLAGS) $(ADDITIONAL_SHAREDLIBC) $(ADDITIONAL_PIC_OBJZ) $(ADDITIONAL_LDFLAGS)
 	rm -f $(SHAREDLIB) $(SHAREDLIBM)
 	ln -s $@ $(SHAREDLIB)
 	ln -s $@ $(SHAREDLIBM)
 	-@rmdir objs
 
-example$(EXE): example.o $(STATICLIB)
+example$(EXE): check_icp_root check_mem_driver example.o $(STATICLIB)
 	$(CC) $(CFLAGS) -o $@ example.o $(TEST_LDFLAGS)
 
-minigzip$(EXE): minigzip.o $(STATICLIB)
+minigzip$(EXE): check_icp_root check_mem_driver minigzip.o $(STATICLIB)
 	$(CC) $(CFLAGS) -o $@ minigzip.o $(TEST_LDFLAGS)
 
-examplesh$(EXE): example.o $(SHAREDLIBV)
-	$(CC) $(CFLAGS) -o $@ example.o -L. $(SHAREDLIBV)
+examplesh$(EXE): check_icp_root check_mem_driver example.o $(SHAREDLIBV)
+	$(CC) $(CFLAGS) -o $@ example.o $(SHARED_APP_FLAGS) 
 
-minigzipsh$(EXE): minigzip.o $(SHAREDLIBV)
-	$(CC) $(CFLAGS) -o $@ minigzip.o -L. $(SHAREDLIBV)
+minigzipsh$(EXE): check_icp_root check_mem_driver minigzip.o $(SHAREDLIBV)
+	$(CC) $(CFLAGS) -o $@ minigzip.o $(SHARED_APP_FLAGS)
 
-example64$(EXE): example64.o $(STATICLIB)
+example64$(EXE): check_icp_root check_mem_driver example64.o $(STATICLIB)
 	$(CC) $(CFLAGS) -o $@ example64.o $(TEST_LDFLAGS)
 
-minigzip64$(EXE): minigzip64.o $(STATICLIB)
+minigzip64$(EXE): check_icp_root check_mem_driver minigzip64.o $(STATICLIB)
 	$(CC) $(CFLAGS) -o $@ minigzip64.o $(TEST_LDFLAGS)
 
+zpipe$(EXE):  check_icp_root check_mem_driver zpipe.o $(STATICLIB)
+	$(CC) $(CFLAGS) -o $@ zpipe.o $(TEST_LDFLAGS)
+
+zpipesh$(EXE):  check_icp_root check_mem_driver zpipe.o $(SHAREDLIBV)
+	$(CC) $(CFLAGS) -o $@ zpipe.o $(SHARED_APP_FLAGS) 
+
+zpipe64$(EXE):  check_icp_root check_mem_driver zpipe64.o $(STATICLIB)
+	$(CC) $(CFLAGS) -o $@ zpipe64.o $(TEST_LDFLAGS)
+
 install-libs: $(LIBS)
 	-@if [ ! -d $(DESTDIR)$(exec_prefix)  ]; then mkdir -p $(DESTDIR)$(exec_prefix); fi
 	-@if [ ! -d $(DESTDIR)$(libdir)       ]; then mkdir -p $(DESTDIR)$(libdir); fi
@@ -239,11 +345,29 @@
 zconf: zconf.h.in
 	cp -p zconf.h.in zconf.h
 
+.PHONEY: check_icp_root
+check_icp_root:
+ifndef ICP_ROOT
+	$(error You must define the environment variable ICP_ROOT)
+endif
+
+.PHONEY: check_mem_driver
+check_mem_driver:
+	@echo
+ifeq ($(ZLIB_MEMORY_DRIVER),qat_contig_mem)
+	@echo "Building for qat_contig_mem memory allocation driver"
+endif
+ifeq ($(ZLIB_MEMORY_DRIVER),usdm_drv)
+	@echo "Building for usdm_drv memory allocation driver"
+endif
+	@echo 
+
 mostlyclean: clean
 clean:
 	rm -f *.o *.lo *~ \
 	   example$(EXE) minigzip$(EXE) examplesh$(EXE) minigzipsh$(EXE) \
-	   example64$(EXE) minigzip64$(EXE) \
+	   example64$(EXE) minigzip64$(EXE) zpipe$(EXE) zpipe64$(EXE) \
+           zpipesh$(EXE) \
 	   infcover \
 	   libz.* foo.gz so_locations \
 	   _match.s maketree contrib/infback9/*.o
@@ -271,8 +395,8 @@
 gzclose.o gzlib.o gzread.o gzwrite.o: zlib.h zconf.h gzguts.h
 compress.o example.o minigzip.o uncompr.o: zlib.h zconf.h
 crc32.o: zutil.h zlib.h zconf.h crc32.h
-deflate.o: deflate.h zutil.h zlib.h zconf.h
-infback.o inflate.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h inffixed.h
+deflate.o: deflate.h zutil.h zlib.h zconf.h qat_zlib.h engine.h
+infback.o inflate.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h inffixed.h qat_zlib.h circharbuf.h engine.h
 inffast.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
 inftrees.o: zutil.h zlib.h zconf.h inftrees.h
 trees.o: deflate.h zutil.h zlib.h zconf.h trees.h
@@ -281,8 +405,8 @@
 gzclose.lo gzlib.lo gzread.lo gzwrite.lo: zlib.h zconf.h gzguts.h
 compress.lo example.lo minigzip.lo uncompr.lo: zlib.h zconf.h
 crc32.lo: zutil.h zlib.h zconf.h crc32.h
-deflate.lo: deflate.h zutil.h zlib.h zconf.h
-infback.lo inflate.lo: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h inffixed.h
+deflate.lo: deflate.h zutil.h zlib.h zconf.h qat_zlib.h engine.h
+infback.lo inflate.lo: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h inffixed.h qat_zlib.h circharbuf.h engine.h
 inffast.lo: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
 inftrees.lo: zutil.h zlib.h zconf.h inftrees.h
 trees.lo: deflate.h zutil.h zlib.h zconf.h trees.h
diff -uBbw -Nr ../zlib-1.2.8/qat_parseconf.c ./qat_parseconf.c
--- ../zlib-1.2.8/qat_parseconf.c	1970-01-01 01:00:00.000000000 +0100
+++ ./qat_parseconf.c	2016-09-06 13:13:26.650257000 +0100
@@ -0,0 +1,429 @@
+/* qat_parseconf.c -- Support code for Intel QAT hardware acceleration of zlib.
+ * Copyright (C) 2012 Intel Corporation. All rights reserved.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+ 
+#include "qat_parseconf.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <dirent.h>
+
+/**********************************************************************
+ * function:
+ *        confRemoveChar(char * inputStr,
+ *                       const char * charToRemove)
+ * @description
+ *     This function will strip matching characters from the start
+ *     and end of the string. It will strip until it encounters
+ *     a character that doesn't match. It will not touch matching
+ *     characters in the middle of the string.
+ *     If there are no matching characters then the string is
+ *     is left untouched.
+ * @param[in] inputStr - the string to be processed and have the
+ *                       characters removed from.
+ * @param[in] charToRemove - the character to strip from the start
+ *                           and end of the string.
+ * @retval char * - pointer to the adjusted string.
+ *
+ *********************************************************************/ 
+static char * confRemoveChar(char * inputStr, const char * charToRemove)
+{
+    /* Note: this function also alters the string inputStr that is
+       passed in */
+    char * endStr = NULL;
+    char * startStr = inputStr;
+
+    /* Check input parameter to see if NULL */
+    if (NULL == startStr) {
+        return startStr;
+    }
+
+    /* Remove any leading instances of the character passed in from
+       the input string by adjusting where the pointer to the
+       start of the string points to, to skip over them*/
+    while (*startStr && (strncmp(startStr, charToRemove, 1) == 0)) {
+        startStr++;
+    }
+
+    /* Find the end of the input string */
+    if(strlen(startStr) < 1)
+        return startStr;    
+
+    endStr = (char *)( startStr + (strlen(startStr)-1));
+
+    /* Remove any trailing instances of the character passed in
+       from the input string by placing a '\0' character at the
+       position of the first trailing matching character */
+    while (*endStr && (strncmp(endStr, charToRemove, 1) == 0)) {
+        *endStr='\0';
+        endStr--;
+    }   
+    
+    return startStr;
+}
+
+
+/*==========================================================*/
+static char * confRemoveWhiteSpace(char * inputStr)
+{
+    return confRemoveChar(inputStr, " ");
+}
+
+
+/*==========================================================*/
+static char * confRemoveDoubleQuotes(char * inputStr)
+{
+    return confRemoveChar(inputStr, "\"");
+}
+
+
+/*==========================================================*/
+static char * confRemoveStartingSquareBracket(char * inputStr)
+{
+    return confRemoveChar(inputStr, "[");
+}
+
+
+/*==========================================================*/
+static int confRemoveEndSquareBracket(char * inputStr)
+{
+    char * scannedInputStr = NULL;
+    if (NULL == inputStr) 
+        return 0;
+
+    scannedInputStr = strchr(inputStr, ']');
+    if (NULL == scannedInputStr) {
+        return 0;
+    }
+    else {
+        *scannedInputStr = '\0';
+    }
+    return 1;
+}
+
+
+/*==========================================================*/
+static int confIsLineASectionName(char * inputStr)
+{
+    /*Assumption: line has been stripped of leading/trailing 
+      white space already */
+    if (NULL == inputStr)
+        return 0;
+
+    if (strncmp(inputStr, "[", 1) == 0) {
+       if (strchr(inputStr, ']') != NULL) {;
+           return 1;
+       }
+    }
+ 
+    return 0;
+}
+
+
+/*==========================================================*/
+static int confParseSectionName(char * inputStr, char * sectionName)
+{
+    /*Assumption: line has been stripped of leading/trailing
+      whitespace already */
+    /*Assumption: It has already been determined that the 
+      input string is a Section Name by calling:
+      confIsLineASectionName */
+    char * strippedInputStr = confRemoveStartingSquareBracket(inputStr);
+
+    if (!confRemoveEndSquareBracket(strippedInputStr)) 
+        return 0;
+ 
+    if (NULL == strippedInputStr)
+        return 0;
+
+    if (strncmp(sectionName, strippedInputStr, strlen(sectionName)) == 0) {
+        return 1;
+    } 
+
+    return 0;
+}
+
+
+/*==========================================================*/
+static int confParseParameter(char * inputStr, char * keyName, 
+                              char * keyValue, size_t keyValueSize)
+{
+    char tempKeyName[ZLIB_CONF_MAX_LINE_LENGTH] = {0};
+    char tempKeyValue[ZLIB_CONF_MAX_LINE_LENGTH] = {0};
+    char * strippedKeyName = NULL;
+    char * strippedKeyValue = NULL;
+    char * doubleQuoteStrippedKeyValue = NULL;
+    int tempKeyNameLen = 0;
+    int tempKeyValueLen = 0;
+
+    /* Check input parameters */
+    if (NULL == inputStr)
+        return 0;
+
+    if ((strlen(keyName) > ZLIB_CONF_MAX_LINE_LENGTH) ||
+        (strlen(inputStr) > ZLIB_CONF_MAX_LINE_LENGTH))
+        return 0;
+
+    /* Separate the key name and value pair using the same method as the 
+       ia driver does for consistency */
+    if (sscanf(inputStr, "%[^=] = %[^#\n]", tempKeyName, tempKeyValue) != 
+        ZLIB_CONF_PARAM_EXP_NUM_ARGS) {
+        return 0;
+    }
+
+    /* Check the strings are not too long - they should not be as we
+       checked inputStr earlier*/
+    tempKeyNameLen = strlen(tempKeyName); 
+    tempKeyValueLen = strlen(tempKeyValue);
+    if ((tempKeyNameLen > ZLIB_CONF_MAX_LINE_LENGTH) || 
+        (tempKeyValueLen > ZLIB_CONF_MAX_LINE_LENGTH)) 
+        return 0;
+
+    tempKeyName[tempKeyNameLen] = '\0';
+    tempKeyValue[tempKeyValueLen] = '\0';
+  
+    /* Strip whitespace and quotes as appropriate */ 
+    strippedKeyName = confRemoveWhiteSpace(tempKeyName);
+    strippedKeyValue = confRemoveWhiteSpace(tempKeyValue);
+    doubleQuoteStrippedKeyValue = confRemoveDoubleQuotes(strippedKeyValue);
+
+    if (NULL == strippedKeyName || NULL == doubleQuoteStrippedKeyValue) 
+        return 0;
+
+    if (strncmp(keyName, strippedKeyName, strlen(keyName)) != 0)
+        return 0;
+
+    if (keyValueSize < strlen(doubleQuoteStrippedKeyValue))
+        return 0;
+
+    strncpy(keyValue, doubleQuoteStrippedKeyValue, strlen(doubleQuoteStrippedKeyValue));
+    return 1;
+}
+
+
+/*==========================================================*/
+int zlibConfFindKeyValue(char * fileName,
+                     char * sectionName, char * keyName,
+                     char * keyValue, size_t keyValueSize)
+{
+    FILE * conffile;
+    int inSection = 0;
+    int found = ZLIB_CONF_FIND_KEY_FAILED;
+    char lineBuffer[ZLIB_CONF_MAX_LINE_LENGTH] = {0};
+    int lineBufferLength = 0;
+    char * strippedLineBuffer = NULL;
+
+    if (strlen(fileName) > ZLIB_CONF_MAX_PATH) {
+        fprintf(stderr, "Invaid Configuration File Name Length\n"); 
+        return 0; 
+    }
+    conffile = fopen( fileName, "r" );
+    if (conffile != NULL) {
+        while (! feof( conffile )) {
+            if (fgets(lineBuffer, ZLIB_CONF_MAX_LINE_LENGTH, conffile) != NULL) {
+                 lineBufferLength = strlen(lineBuffer);
+                 if (lineBufferLength > 0) {
+
+                     /* Remove any leading or trailing whitespace before trying
+                        to process further. It is okay to pass a NULL string to
+                        the confRemoveWhiteSpace function */
+                     strippedLineBuffer = confRemoveWhiteSpace(lineBuffer);
+
+                     /* We didn't get a valid line, lets continue to next line*/
+                     if (NULL == strippedLineBuffer) 
+                         continue;
+
+                     /* We got a comment or empty line, ignore and continue to
+                        next line */
+                     if (('#' == *strippedLineBuffer) || (0 == *strippedLineBuffer))
+                         continue;
+
+                     /* Check whether line is a section name */
+                     if (confIsLineASectionName(strippedLineBuffer)) {
+                         /* Are we already in the desired section?*/
+                         if (inSection) {
+                             /* We are so we must have finished that section lets
+                                clear the flag so do not continue to process parameters
+                                within other sections */
+                             inSection = 0;
+                         }
+                         else {
+                             /* We aren't in the section already lets check whether
+                                this is the section we want */
+                             if (confParseSectionName(strippedLineBuffer, sectionName)) {
+                                 /* It is the section we want so set the flag */
+                                 inSection = 1;
+                                 found = ZLIB_CONF_FIND_KEY_SECTION_FOUND;
+                             }
+                         }
+                     }
+                     else { /* It's not a section name so assume it is a parameter */
+                         /* Are we in the correct section of the config file? */
+                         if (inSection) {
+                             /* We are so parse the parameter and deal with it 
+                                as appropriate */
+                             if (confParseParameter(strippedLineBuffer, keyName, 
+                                 keyValue, keyValueSize)) {
+                             /* Found the parameter we are looking for set flag
+                                and break out of loop*/
+                                 found = ZLIB_CONF_FIND_KEY_KEY_FOUND; 
+                                 break;
+                             }
+                         }
+                     } 
+                 }
+            }
+        }
+        fclose(conffile);
+    }
+    else
+    {
+        fprintf(stderr, "Unable to open file %s\n", fileName);
+    }
+    return found;
+}
+
+#define DH89XXCC_NAME "dh89xxcc"
+#define DH895XCC_NAME "dh895xcc"
+#define C6XX_NAME "c6xx"
+#define C3XXX_NAME "c3xxx"
+
+#define DH89XXCC_INDEX 0
+#define DH895XCC_INDEX 1
+#define C6XX_INDEX 2
+#define C3XXX_INDEX 3
+
+#define NUM_DEVICES_TYPES 4
+#define MAX_NUM_DEVICES 32
+
+/*==========================================================*/
+int zlibGetDevices(unsigned int dev_mask[], int *upstream_flag)
+{
+    DIR *proc = NULL, *kernel = NULL;
+    struct dirent *child;
+    char *tmp;
+    int dev_index;
+    int found = 0;
+    int shift_DH895XCC = 0, shift_C6XX = 0, shift_C3XXX = 0;
+    proc = opendir("/proc");
+    kernel = opendir("/sys/kernel/debug");
+    if ((!proc) && (!kernel)) {
+        fprintf(stderr, "No /proc or /sys/kernel/debug directory or it cannot be opened\n");
+        return 0;
+    }
+    /* This while loop is for legacy driver */
+
+    if (NULL != proc) {
+        while ((child = readdir(proc)) != NULL) {
+            if (!strncmp(child->d_name, "icp_", 4)) {
+                /* there is a /proc/icp_* directory */
+                if (strstr(child->d_name, DH89XXCC_NAME)) {
+                    dev_index = DH89XXCC_INDEX;
+                } else if (strstr(child->d_name, DH895XCC_NAME)) {
+                    dev_index = DH895XCC_INDEX;
+                } else if (strstr(child->d_name, C6XX_NAME)){
+                    dev_index = C6XX_INDEX;
+                } else if (strstr(child->d_name, C3XXX_NAME)) {
+                    dev_index = C3XXX_INDEX;
+                } else  
+                    continue;
+                if ((tmp = strstr(child->d_name, "dev")) != NULL) {
+                    if (isdigit(tmp[3])) {
+                        int shift = atoi(tmp + 3);
+                        if ((shift >= 0) && (shift < MAX_NUM_DEVICES)) {
+                            dev_mask[dev_index] |= 1 << shift;
+                            found = 1;
+                        }
+                    }
+                }
+            }
+        }
+        closedir(proc);
+    }
+
+    /* This while loop is for upstream driver */
+    if (NULL != kernel) {
+        while ((child = readdir(kernel)) != NULL) {
+            if (!strncmp(child->d_name, "qat_", 4)) {
+                /* there is a /sys/kernel/debug/qat_* directory */
+                if (upstream_flag != NULL)
+                    *upstream_flag = 1;
+                if (strstr(child->d_name, DH895XCC_NAME)) {
+                    dev_index = DH895XCC_INDEX;
+                    if ((shift_DH895XCC >= 0) && (shift_DH895XCC < MAX_NUM_DEVICES)) {
+                        dev_mask[dev_index] |= 1 << shift_DH895XCC;
+                        shift_DH895XCC++;
+                        found = 1;
+                    }
+                } else if (strstr(child->d_name, C6XX_NAME)){
+                    dev_index = C6XX_INDEX;
+                    if ((shift_C6XX >= 0) && (shift_C6XX < MAX_NUM_DEVICES)) {
+                        dev_mask[dev_index] |= 1 << shift_C6XX;
+                        shift_C6XX++;
+                        found = 1;
+                    }
+                } else if (strstr(child->d_name, C3XXX_NAME)) {
+                    dev_index = C3XXX_INDEX;
+                    if ((shift_C3XXX >= 0) && (shift_C3XXX < MAX_NUM_DEVICES)) {
+                        dev_mask[dev_index] |= 1 << shift_C3XXX;
+                        shift_C3XXX++;
+                        found = 1;
+                    }
+                } else
+                    continue;
+            }
+        }
+        closedir(kernel);
+    }
+    if (!found) {
+        fprintf(stderr, "No running Intel(R) QuickAssist devices detected \n");
+        return 0;
+    }
+    return 1;
+}
+
+int zlibCheckLimitDevAccessValue(int *limitDevAccess, char *section_name)
+{
+    unsigned int dev_masks[] = { 0, 0, 0, 0, 0 };
+    char * dev_names[] = {DH89XXCC_NAME, DH895XCC_NAME, C6XX_NAME, C3XXX_NAME};
+    char config_file_path[ZLIB_CONF_MAX_PATH];
+    char config_key_value[ZLIB_CONF_MAX_LINE_LENGTH] = { 0 };
+    int config_key_value_size = ZLIB_CONF_MAX_LINE_LENGTH;
+    int status;
+    int upstream_flags = 0;
+    int i, j;
+    if (!zlibGetDevices(dev_masks, &upstream_flags)) {
+        *limitDevAccess = 0;
+        return 0;
+    }
+    for (j = 0; j < NUM_DEVICES_TYPES; j++)
+        for (i = 0; i < MAX_NUM_DEVICES; i++) {
+            if ((dev_masks[j] & (1 << i)) && (!upstream_flags)) {
+                sprintf(config_file_path, "/etc/%s_qa_dev%d.conf",
+                        dev_names[j], i);
+            } else if ((dev_masks[j] & (1 << i)) && (upstream_flags)) { 
+                       sprintf(config_file_path, "/etc/%s_dev%d.conf",
+                               dev_names[j], i);
+            } else
+                continue;
+            status = zlibConfFindKeyValue(config_file_path, section_name,
+                                            "LimitDevAccess", config_key_value,
+                                            config_key_value_size);
+            if (status == ZLIB_CONF_FIND_KEY_SECTION_FOUND) {
+                /* if the SHIM section was found in the config file but no
+                   LimitDevAccess setting,
+                   LimitDevAccess is set to 0 */
+                *limitDevAccess = 0;
+                return 1;
+            } else if (status == ZLIB_CONF_FIND_KEY_KEY_FOUND) {
+                if (isdigit(config_key_value[0])) {
+                    *limitDevAccess = atoi(config_key_value);
+                    return 1;
+                }
+            }
+        }
+    *limitDevAccess = 0;
+    return 0;
+}
diff -uBbw -Nr ../zlib-1.2.8/qat_parseconf.h ./qat_parseconf.h
--- ../zlib-1.2.8/qat_parseconf.h	1970-01-01 01:00:00.000000000 +0100
+++ ./qat_parseconf.h	2016-09-06 13:13:26.651257000 +0100
@@ -0,0 +1,102 @@
+/* qat_parseconf.h -- Support code for Intel QAT hardware acceleration of zlib.
+ * Copyright (C) 2012 Intel Corporation. All rights reserved.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+#ifndef QAT_PARSECONF_H
+#define QAT_PARSECONF_H
+
+#include <stdio.h>
+
+/* The maximum amount of characters allowed per line in the 
+   config file*/
+#define ZLIB_CONF_MAX_LINE_LENGTH 160
+
+/* The number of arguments when we split a line of the form: 
+   "<arg1> = <arg2>" */
+#define ZLIB_CONF_PARAM_EXP_NUM_ARGS 2
+
+/* The maximum length of the path and filename to where the driver
+   configuration file is stored */ 
+#define ZLIB_CONF_MAX_PATH 1024
+
+# define ZLIB_CONF_FIND_KEY_KEY_FOUND 2
+# define ZLIB_CONF_FIND_KEY_SECTION_FOUND 1
+# define ZLIB_CONF_FIND_KEY_FAILED 0
+
+ /***********************************************************************
+  * function:
+  *         zlibCheckLimitDevAccessValue(int * limitDevAccess,
+  *                                  char * section_name);
+  * @description
+  *     This function will go through config files of running QA devices
+  *     and look for value of LimitDevAccess parameter in the section, whose name
+  *     is given in the section_name parameter. The value of LimitDevAccess found
+  *     in first config file that contains section_name section. If the first config
+  *     file that contains section_name section does not have LimitDevAccess set, then
+  *     it is assumed that LimitDevAccess=1
+  * @param[out] limitDevAccess - pointer to where the returned LimitDevAccess value
+  *                             will be stored
+  * @param[in] sectionName - a string containing the section name to
+  *                          match.
+  * @retval int - Return 1 the LimitDevAccess value was found.
+  *               Return 0 the LimitDevAccess could not be found, zero is returned in
+  *                         limitDevAccess
+  *
+  **********************************************************************/
+int zlibCheckLimitDevAccessValue(int *limitDevAccess, char *section_name);
+
+ /***********************************************************************
+  * function:
+  *         zlibGetDevices(unsigned int dev_mask[])
+  *
+  * @description
+  *     This function will check the availability of Acceleration devices
+  *     and if found, it will set the corresponding index to 1.
+  *
+  * @param[out] dev_mask - Corresponding dev index will be set to 1.
+  *
+  * @param[in] dev_mask - An empty array with all the values set to 0.
+  *
+  * @retval int - Return 1 The acceleration devices are found
+  *               Return 0 No Acceleration device is found
+  *
+  **********************************************************************/
+int zlibGetDevices(unsigned int dev_mask[], int *upstream_flag);
+
+/***********************************************************************
+ * function:
+ *         zlibConfFindKeyValue(char * filename
+ *                          char * sectionName, char * keyName
+ *                          char * keyValue, size_t keyValueSize)
+ * @description
+ *     This function will open the config file at the supplied path.
+ *     Parse the config file for the specified section and then parse
+ *     for the specified key name. If the key name is found then the
+ *     function will return 1 and copy the associated key value into
+ *     the string supplied as the keyValue parameter. If the key
+ *     name is not found then the function will return 0 and the
+ *     keyValue string will not be populated.
+ * @param[in] filename - a string containing the path and filename of
+ *                       the config file to parse.
+ * @param[in] sectionName - a string containing the section name to
+ *                          match.
+ * @param[in] keyName - a string containing the key name we are 
+ *                      trying to match.
+ * @param[in, out] keyValue - This parameter should be passed in as
+ *                            an allocated string. If a match is found
+ *                            for the sectionName and keyName then the
+ *                            key value associated with the key name
+ *                            will be copied into this string.
+ * @param[in] keyValueSize - the size of the allocated string passed
+ *                           in as keyValue. This allows size checking
+ *                           so we don't try and copy a key value that
+ *                           is too large into the keyValue string.
+ * @retval int - Return 1 if a key value was found. Return 0 if the
+ *               key value was not found or any errors occured.
+ *
+ **********************************************************************/
+int zlibConfFindKeyValue(char * fileName, 
+                     char * sectionName, char * keyName,
+                     char * keyValue, size_t keyValueSize);
+#endif /* QAT_PARSECONF_H */
diff -uBbw -Nr ../zlib-1.2.8/qat_zlib.c ./qat_zlib.c
--- ../zlib-1.2.8/qat_zlib.c	1970-01-01 01:00:00.000000000 +0100
+++ ./qat_zlib.c	2016-09-08 14:54:39.976358000 +0100
@@ -0,0 +1,225 @@
+/* qat_zlib.c -- Support code for Intel QAT hardware acceleration of zlib.
+ * Copyright (C) 2012 Intel Corporation. All rights reserved.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+ 
+#include "qat_zlib.h"
+#include "engine.h"
+#include "icp_sal_poll.h"
+#include <errno.h>
+#include <pthread.h>
+
+#define likely(x)   __builtin_expect (!!(x), 1)
+#define unlikely(x) __builtin_expect (!!(x), 0)
+
+extern int qat_keep_polling;
+
+/******************************************************************************
+* function:
+*         void *qatSendPoll(void *ih)
+*
+* @param ih [IN] - Instance handle
+*
+* description:
+*   Poll the QAT instances. 
+*
+******************************************************************************/
+void *qatSendPoll(void* ih) {
+
+    CpaStatus status                 = CPA_STATUS_FAIL;
+    struct timespec reqTime          = {0};
+    struct timespec remTime          = {0};
+    CpaInstanceHandle instanceHandle = NULL;
+    unsigned int retry_count = 0; //to prevent too much time drift
+
+    if (!ih)
+        return NULL;
+
+    instanceHandle  = (CpaInstanceHandle)ih;
+    reqTime.tv_sec  = 0;
+
+    while(qat_keep_polling) {
+        reqTime.tv_nsec = qatGetPollingInterval();
+        /* Poll for 0 means process all packets on the ET ring */
+        status = icp_sal_DcPollInstance(instanceHandle, 0);
+
+        if(likely(CPA_STATUS_SUCCESS == status 
+           || CPA_STATUS_RETRY == status)) {
+            /* Do nothing */
+        }
+        else {
+            fprintf(stderr, 
+                    "WARNING icp_sal_DcPollInstance returned status %d\n",
+                    status);
+        }
+        retry_count = 0;
+        do {
+            retry_count++;
+            nanosleep(&reqTime, &remTime);
+            reqTime.tv_nsec = remTime.tv_nsec;
+            if(unlikely((errno < 0) && (EINTR != errno)))
+            {
+                fprintf(stderr,
+                        "WARNING nanosleep system call failed: errno %i\n",
+                        errno);
+                break;
+            }
+        }	
+        while ((retry_count <= QAT_ZLIB_NUM_POLLING_RETRIES) 
+               && (EINTR == errno));
+    }
+    return NULL;
+}
+
+
+/******************************************************************************
+* function:
+*         qatInitOpDone(struct op_done *opDone)
+*
+* @param opDone [IN] - pointer to op done callback structure
+*
+* description:
+*   Initialise the QAT operation "done" callback structure.
+*
+******************************************************************************/
+void qatInitOpDone(struct op_done *opDone)
+{
+    int sts = 1;
+ 
+    if (!opDone) {
+        return;
+    }
+
+    sts = pthread_mutex_init(&(opDone->mutex), NULL);
+    if (sts != 0) {
+       fprintf(stderr,
+               "pthread_mutex_init failed - sts = %d. Continuing anyway.\n",
+               sts);
+    }
+    sts = pthread_cond_init(&(opDone->cond), NULL);
+    if (sts != 0) {
+       fprintf(stderr,
+               "pthread_cond_init failed - sts = %d. Continuing anyway.\n",
+               sts);
+    }
+    opDone->flag = 0;
+}
+
+/******************************************************************************
+* function:
+*         qatCleanupOpDone(struct op_done *opDone)
+*
+* @param opDone [IN] - pointer to op done callback structure
+*
+* description:
+*   Cleanup the thread and mutex used in the QAT operation "done" callback.
+*
+******************************************************************************/
+void qatCleanupOpDone(struct op_done *opDone)
+{
+    int sts = 1;
+ 
+    if (!opDone) {
+        return;
+    }
+
+    sts = pthread_mutex_destroy(&(opDone->mutex));
+    if (sts != 0) {
+       fprintf(stderr,
+               "pthread_mutex_destroy failed - sts = %d. Continuing anyway.\n",
+               sts);
+    }
+    sts = pthread_cond_destroy(&(opDone->cond));
+    if (sts != 0) {
+       fprintf(stderr, 
+               "pthread_cond_destroy failed - sts = %d. Continuing anyway.\n",
+               sts);
+    }
+}
+
+/******************************************************************************
+* function:
+*         qatWaitForOpToComplete(struct op_done *opDone)
+*
+* @param opdone [IN] - pointer to op done callback structure
+*
+* description:
+*   Wait on a mutex lock with a timeout for cpaCySymPerformOp to complete.
+*
+******************************************************************************/
+void qatWaitForOpToComplete(struct op_done *opDone)
+{
+    struct timespec ts;
+    int sts = 1;
+    
+    if (!opDone) {
+        return;
+    }
+
+    sts = pthread_mutex_lock(&(opDone->mutex));
+    if (sts != 0) {
+       fprintf(stderr,
+               "pthread_mutex_lock failed - sts = %d. Continuing anyway.\n",
+               sts);
+    }
+
+    while (!opDone->flag) {
+        clock_gettime(CLOCK_REALTIME, &ts);
+        ts.tv_sec += 1;
+        sts = pthread_cond_timedwait(&(opDone->cond), &(opDone->mutex), &ts);
+        if (sts != 0)
+            fprintf(stderr, "pthread_cond_timedwait: %s\n", strerror(sts));
+    }
+
+    sts = pthread_mutex_unlock(&(opDone->mutex));
+    if (sts != 0) {
+       fprintf(stderr,
+               "pthread_mutex_unlock failed - sts = %d. Continuing anyway.\n",
+               sts);
+    }
+}
+
+/******************************************************************************
+* function:
+*         qat_callbackFn(void *callbackTag, CpaStatus status)
+*
+* @param pCallbackTag  [IN] -  Opaque value provided by user while making
+*                              individual function call. Cast to op_done.
+* @param status        [IN] -  Status of the operation.
+* 
+*
+* description:
+*   Callback function used to indicate completion.
+*
+******************************************************************************/
+void qat_callbackFn(void *callbackTag, CpaStatus status)
+{
+    struct op_done *opDone = (struct op_done *)callbackTag;
+    int sts = 1;
+    
+    if (!opDone) {
+        return;
+    }
+
+    sts = pthread_mutex_lock(&(opDone->mutex));
+    if (sts != 0) {
+       fprintf(stderr,
+               "pthread_mutex_lock failed - sts = %d. Continuing anyway.\n",
+               sts);
+    }
+    opDone->flag = 1;
+    sts = pthread_cond_signal(&(opDone->cond));
+    if (sts != 0) {
+       fprintf(stderr,
+               "pthread_cond_signal failed - sts = %d. Continuing anyway.\n",
+               sts);
+    }
+    sts = pthread_mutex_unlock(&(opDone->mutex));
+    if (sts != 0) {
+       fprintf(stderr, 
+               "pthread_mutex_unlock failed - sts = %d. Continuing anyway.\n",
+               sts);
+    }
+}
+
+
diff -uBbw -Nr ../zlib-1.2.8/qat_zlib.h ./qat_zlib.h
--- ../zlib-1.2.8/qat_zlib.h	1970-01-01 01:00:00.000000000 +0100
+++ ./qat_zlib.h	2016-09-06 13:13:26.653257000 +0100
@@ -0,0 +1,94 @@
+/* qat_zlib.h -- Support code for Intel QAT hardware acceleration of zlib.
+ * Copyright (C) 2012 Intel Corporation. All rights reserved.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <time.h>
+
+#include "cpa_dc.h"
+#ifdef USE_QAE_MEM
+#include "cmn_mem_drv_inf.h"
+#endif
+#ifdef USE_QAT_CONTIG_MEM
+#include "qae_mem_utils.h"
+#endif
+
+/* This is the maximum amount of pinned memory that can be allocated in one
+   chunk. If you replace qat_contig_mem with your own memory allocation
+   routines you could change this value to match the new maximum. You can
+   also reduce this if you want to lower the memory footprint at the
+   expense of performance but you must not reduce this value below 74 */
+#define QAT_ZLIB_INTERNAL_FLATBUFFER_SIZE ((int)(128*1022))
+
+/* The compression overhead that needs to be taken into account when
+   calculating the size of the compression input buffer - do not change this
+   value
+   This value consists of the following:-
+   8 Bytes for fixed expansion value (for very small buffersizes)
+   10 Bytes for Max Header size (state machine optimization)
+   8 Bytes for Max Footer size (state machine optimization)
+   48 Bytes for skid pad */
+#define QAT_ZLIB_COMPRESSION_OVERHEAD (74)
+
+/* This is the maximum amount of flat buffers allocated for the input buffer
+   on compression/decompression and also the output buffer on compression. */
+#define QAT_ZLIB_NUM_INPUT_FLAT_BUFFERS (1)
+
+/* This is the maximum amount of flat buffers allocated for the output buffer
+   on decompression. This could be adjusted if predominantly decompressing
+   files that are large and compress very well. Increasing the the amount of
+   flat buffers may increase performance slightly but at the expense of
+   memory footprint. */
+#define QAT_ZLIB_NUM_OUTPUT_FLAT_BUFFERS (2)
+
+/* The retry mechanism will back off the number of seconds calculated by the
+   modulo of the number of retries (dividend) and this number (divisor). */
+#define QAT_RETRY_BACKOFF_MODULO_DIVISOR (8)
+
+/* The number of retries of the nanosleep if it gets interrupted
+   during waiting between polling. */
+#define QAT_ZLIB_NUM_POLLING_RETRIES (5)
+
+#define QAT_32K_WIN_SIZE      (7)
+#define QAT_16K_WIN_SIZE      (6)
+#define QAT_8K_WIN_SIZE       (5)
+#define QAT_DC_GZIP_FOOTER_SIZE   (8)
+#define QAT_DC_ZLIB_FOOTER_SIZE   (4)
+
+#define QAT_RET_HEADER_COMPLETE     (0)
+#define QAT_RET_MORE_INPUT_REQUIRED (1)
+#define QAT_RET_BUFFER_ERROR        (2)
+#define QAT_RET_DATA_ERROR          (3)
+
+#ifdef QAT_DEBUG
+#define QATDEBUG(...) fprintf (stderr, __VA_ARGS__)
+#else
+#define QATDEBUG(...)
+#endif
+
+/* Struct for tracking threaded QAT operation completion. */
+struct op_done {
+    pthread_mutex_t mutex;
+    pthread_cond_t cond;
+    int flag;
+};
+
+/* Poll the QAT instances. */
+void *qatSendPoll(void* ih);
+
+/* Callback to indicate QAT completion. */
+void qat_callbackFn(void *callbackTag, CpaStatus status);
+
+/* Initialise the QAT operation done callback. */
+void qatInitOpDone(struct op_done *opDone);
+
+/* Cleanup the QAT operation done callback. */
+void qatCleanupOpDone(struct op_done *opDone);
+
+/* Threaded wait for QAT completion. */
+void qatWaitForOpToComplete(struct op_done *opDone);
+
diff -uBbw -Nr ../zlib-1.2.8/test/example.c ./test/example.c
--- ../zlib-1.2.8/test/example.c	2012-08-13 08:02:40.000000000 +0100
+++ ./test/example.c	2016-04-06 08:50:14.088276000 +0100
@@ -572,6 +572,9 @@
         exit(1);
     }
 
+    zlibSetupEngine(Z_QAT_DEFAULT_POLLING_INTERVAL, Z_QAT_DEFAULT_MAX_NUM_RETRIES);
+    zlibStartupEngine(Z_HW_COMP_HW_DECOMP);
+    
 #ifdef Z_SOLO
     argc = strlen(argv[0]);
 #else
@@ -594,6 +597,8 @@
     test_dict_deflate(compr, comprLen);
     test_dict_inflate(compr, comprLen, uncompr, uncomprLen);
 
+    zlibShutdownEngine();
+    
     free(compr);
     free(uncompr);
 
diff -uBbw -Nr ../zlib-1.2.8/test/minigzip.c ./test/minigzip.c
--- ../zlib-1.2.8/test/minigzip.c	2012-06-04 00:28:40.000000000 +0100
+++ ./test/minigzip.c	2016-04-06 08:50:14.092275000 +0100
@@ -562,6 +562,8 @@
     gzFile file;
     char *bname, outmode[20];
 
+    zlibSetupEngine(Z_QAT_DEFAULT_POLLING_INTERVAL, Z_QAT_DEFAULT_MAX_NUM_RETRIES);
+    zlibStartupEngine(Z_HW_COMP_HW_DECOMP);
 #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
     snprintf(outmode, sizeof(outmode), "%s", "wb6 ");
 #else
@@ -647,5 +649,6 @@
             }
         } while (argv++, --argc);
     }
+    zlibShutdownEngine();
     return 0;
 }
diff -uBbw -Nr ../zlib-1.2.8/zlib.h ./zlib.h
--- ../zlib-1.2.8/zlib.h	2013-04-29 01:23:49.000000000 +0100
+++ ./zlib.h	2016-09-07 12:32:52.645211000 +0100
@@ -37,8 +37,8 @@
 extern "C" {
 #endif
 
-#define ZLIB_VERSION "1.2.8"
-#define ZLIB_VERNUM 0x1280
+#define ZLIB_VERSION "1.2.8.f-Intel-QAT-ver-0-4-9-001"
+#define ZLIB_VERNUM 0x128f
 #define ZLIB_VER_MAJOR 1
 #define ZLIB_VER_MINOR 2
 #define ZLIB_VER_REVISION 8
@@ -207,11 +207,53 @@
 
 #define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
 
+/*These are used as flags to zlibStartupEngine to control whether Hardware 
+or Software Compression/Decompression is used. */
+#define Z_SW_COMP_SW_DECOMP  0  /* Use Software Compression and Decompression */
+#define Z_SW_COMP_HW_DECOMP  1  /* Use Software Compression and Hardware Decompression */
+#define Z_HW_COMP_SW_DECOMP  2  /* Use Hardware Compression and Software Decompression */
+#define Z_HW_COMP_HW_DECOMP  3  /* Use Hardware Compression and Decompression */
+
+/* The default polling interval passed into zlibSetupEngine */
+#define Z_QAT_DEFAULT_POLLING_INTERVAL 100000
+
+/* The default maximum number of retries that is passed into zlibSetupEngine */
+#define Z_QAT_DEFAULT_MAX_NUM_RETRIES 100
+
+/* Use this define to set the maximum number of retries to infinite */
+#define Z_QAT_INFINITE_MAX_NUM_RETRIES -1
+
 #define zlib_version zlibVersion()
 /* for compatibility with versions < 1.0.2 */
 
 
                         /* basic functions */
+ZEXTERN void ZEXPORT zlibSetupEngine OF((long pollingInterval, int maxNumRetries));
+/*    Must be the first call from any application that wants to use the qat zlib.
+ * pollingInterval is the value in nanoseconds between calls to ask the QAT
+ * driver to poll its rings for new messages. The default value is 100000.
+ * The minumum value is 1 and the maximum value is 10000000.
+ * maxNumRetries is the maximum number of retries that should be attempted
+ * for a compression or decompression request if the QAT driver is reporting
+ * itself as too busy to handle the request. The default value is 100.
+ * The minimum value is -1 and the maximum value is 100000.
+ * Passing in -1 will cause infinite retries */
+
+ZEXTERN int ZEXPORT zlibStartupEngine OF((int SwHwCompressionFlag));
+/*    Needs to called once per process after the call to zlibSetupEngine. The
+ * SwHwCompressionFlag must be one of the flags defined just above that determine
+ * whether to use Hardware or Software compression and decompression.
+ *
+ *    zlibStartupEngine will return Z_OK if successful or Z_MEM_ERROR if an
+ * error occured. If an error has occured then zlibShutdownEngine should be
+ * called to clean up. */
+
+ZEXTERN int ZEXPORT zlibShutdownEngine OF((void));
+/*    Needs to be called when finished with the zlib library once per process.
+ *
+ *    Currently zlibShutdownEngine will make it's best attempt at cleaning up
+ * and always return Z_OK. This may change in future so it returns Z_MEM_ERROR
+ * if it fails anything */
 
 ZEXTERN const char * ZEXPORT zlibVersion OF((void));
 /* The application can compare zlibVersion and ZLIB_VERSION for consistency.
diff -uBbw -Nr ../zlib-1.2.8/zlib.map ./zlib.map
--- ../zlib-1.2.8/zlib.map	2013-03-24 06:47:15.000000000 +0000
+++ ./zlib.map	2016-04-06 08:50:14.128277000 +0100
@@ -81,3 +81,9 @@
     inflateGetDictionary;
     gzvprintf;
 } ZLIB_1.2.5.2;
+
+ZLIB_1.2.8 {
+    zlibSetupEngine;
+    zlibStartupEngine;
+    zlibShutdownEngine;
+} ZLIB_1.2.7.1;
